var documenterSearchIndex = {"docs":
[{"location":"man/querying_frameworks/#Data-manipulation-frameworks-1","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"","category":"section"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Two popular frameworks provide convenience methods to manipulate DataFrames: DataFramesMeta.jl and Query.jl. They implement a functionality similar to dplyr or LINQ.","category":"page"},{"location":"man/querying_frameworks/#DataFramesMeta.jl-1","page":"Data manipulation frameworks","title":"DataFramesMeta.jl","text":"","category":"section"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The DataFramesMeta.jl package provides a convenient yet fast macro-based interface to work with DataFrames.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"First install the DataFramesMeta.jl package:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"DataFramesMeta\")","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The major benefit of the package is that it allows you to refer to columns of a DataFrame as Symbols. Therefore instead of writing verylongdataframename.variable you can simply write :variable in expressions. Additionally you can chain a sequence of transformations of a DataFrame using the @linq macro.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Here is a minimal example of usage of the package. Observe that we refer to names of columns using only their names and that chaining is performed using the @linq macro and the |> operator:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54., 34., 79.],\n                      children=[0, 2, 4])\n3×3 DataFrame\n│ Row │ name   │ age     │ children │\n│     │ String │ Float64 │ Int64    │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ John   │ 54.0    │ 0        │\n│ 2   │ Sally  │ 34.0    │ 2        │\n│ 3   │ Roger  │ 79.0    │ 4        │\n\njulia> @linq df |>\n           where(:age .> 40) |>\n           select(number_of_children=:children, :name)\n2×2 DataFrame\n│ Row │ number_of_children │ name   │\n│     │ Int64              │ String │\n├─────┼────────────────────┼────────┤\n│ 1   │ 0                  │ John   │\n│ 2   │ 4                  │ Roger  │","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"In the following examples we show that DataFramesMeta.jl also supports the split-apply-combine pattern:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> df = DataFrame(key=repeat(1:3, 4), value=1:12)\n12×2 DataFrame\n│ Row │ key   │ value │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 4     │\n│ 5   │ 2     │ 5     │\n│ 6   │ 3     │ 6     │\n│ 7   │ 1     │ 7     │\n│ 8   │ 2     │ 8     │\n│ 9   │ 3     │ 9     │\n│ 10  │ 1     │ 10    │\n│ 11  │ 2     │ 11    │\n│ 12  │ 3     │ 12    │\n\njulia> @linq df |>\n           where(:value .> 3) |>\n           by(:key, min=minimum(:value), max=maximum(:value)) |>\n           select(:key, range=:max - :min)\n3×2 DataFrame\n│ Row │ key   │ range │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 6     │\n│ 3   │ 3     │ 6     │\n\njulia> @linq df |>\n           groupby(:key) |>\n           transform(value0 = :value .- minimum(:value))\n12×3 DataFrame\n│ Row │ key   │ value │ value0 │\n│     │ Int64 │ Int64 │ Int64  │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 1     │ 1     │ 0      │\n│ 2   │ 1     │ 4     │ 3      │\n│ 3   │ 1     │ 7     │ 6      │\n│ 4   │ 1     │ 10    │ 9      │\n│ 5   │ 2     │ 2     │ 0      │\n│ 6   │ 2     │ 5     │ 3      │\n│ 7   │ 2     │ 8     │ 6      │\n│ 8   │ 2     │ 11    │ 9      │\n│ 9   │ 3     │ 3     │ 0      │\n│ 10  │ 3     │ 6     │ 3      │\n│ 11  │ 3     │ 9     │ 6      │\n│ 12  │ 3     │ 12    │ 9      │","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"You can find more details about how this package can be used on the DataFramesMeta.jl GitHub page.","category":"page"},{"location":"man/querying_frameworks/#Query.jl-1","page":"Data manipulation frameworks","title":"Query.jl","text":"","category":"section"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The Query.jl package provides advanced data manipulation capabilities for DataFrames (and many other data structures). This section provides a short introduction to the package, the Query.jl documentation has a more comprehensive documentation of the package.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"To get started, install the Query.jl package:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"Query\")","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query is started with the @from macro and consists of a series of query commands. Query.jl provides commands that can filter, project, join, flatten and group data from a DataFrame. A query can return an iterator, or one can materialize the results of a query into a variety of data structures, including a new DataFrame.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A simple example of a query looks like this:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, Query\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54., 34., 79.],\n                      children=[0, 2, 4])\n3×3 DataFrame\n│ Row │ name   │ age     │ children │\n│     │ String │ Float64 │ Int64    │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ John   │ 54.0    │ 0        │\n│ 2   │ Sally  │ 34.0    │ 2        │\n│ 3   │ Roger  │ 79.0    │ 4        │\n\njulia> q1 = @from i in df begin\n            @where i.age > 40\n            @select {number_of_children=i.children, i.name}\n            @collect DataFrame\n       end\n2×2 DataFrame\n│ Row │ number_of_children │ name   │\n│     │ Int64              │ String │\n├─────┼────────────────────┼────────┤\n│ 1   │ 0                  │ John   │\n│ 2   │ 4                  │ Roger  │","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The query starts with the @from macro. The first argument i is the name of the range variable that will be used to refer to an individual row in later query commands. The next argument df is the data source that one wants to query. The @where command in this query will filter the source data by applying the filter condition i.age > 40. This filters out any rows in which the age column is not larger than 40. The @select command then projects the columns of the source data onto a new column structure. The example here applies three specific modifications: 1) it only keeps a subset of the columns in the source DataFrame, i.e. the age column will not be part of the transformed data; 2) it changes the order of the two columns that are selected; and 3) it renames one of the columns that is selected from children to number_of_children. The example query uses the {} syntax to achieve this. A {} in a Query.jl expression instantiates a new NamedTuple, i.e. it is a shortcut for writing @NT(number_of_children=>i.children, name=>i.name). The @collect statement determines the data structure that the query returns. In this example the results are returned as a DataFrame.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query without a @collect statement returns a standard julia iterator that can be used with any normal julia language construct that can deal with iterators. The following code returns a julia iterator for the query results:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q2 = @from i in df begin\n                   @where i.age > 40\n                   @select {number_of_children=i.children, i.name}\n              end; # suppress printing the iterator type\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"One can loop over the results using a standard julia for statement:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> total_children = 0\n0\n\njulia> for i in q2\n           global total_children += i.number_of_children\n       end\n\njulia> total_children\n4\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Or one can use a comprehension to extract the name of a subset of rows:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> y = [i.name for i in q2 if i.number_of_children > 0]\n1-element Array{String,1}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The last example (extracting only the name and applying a second filter) could of course be completely expressed as a query expression:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q3 = @from i in df begin\n            @where i.age > 40 && i.children > 0\n            @select i.name\n            @collect\n       end\n1-element Array{String,1}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query that ends with a @collect statement without a specific type will materialize the query results into an array. Note also the difference in the @select statement: The previous queries all used the {} syntax in the @select statement to project results into a tabular format. The last query instead just selects a single value from each row in the @select statement.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"These examples only scratch the surface of what one can do with Query.jl, and the interested reader is referred to the Query.jl documentation for more information.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/indexing/#Indexing-1","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Pages = [\"indexing.md\"]","category":"page"},{"location":"lib/indexing/#General-rules-1","page":"Indexing","title":"General rules","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following rules explain target functionality of how getindex, setindex!, view, and broadcasting are intended to work with DataFrame, SubDataFrame and DataFrameRow objects.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The rules for a valid type of index into a column are the following:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"a value, later denoted as col:\na Symbol;\nan AbstractString;\nan Integer that is not Bool;\na vector, later denoted as cols:\na vector of Symbol (does not have to be a subtype of AbstractVector{Symbol});\na vector of AbstractString (does not have to be a subtype of AbstractVector{<:AbstractString});\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na regular expression, which gets expanded to a vector of matching column names;\na Not expression (see InvertedIndices.jl);\nan All or Between expression (see DataAPI.jl);\na colon literal :.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The rules for a valid type of index into a row are the following:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"a value, later denoted as row:\nan Integer that is not Bool;\na vector, later denoted as rows:\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na Not expression;\na colon literal :;\nan exclamation mark !.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Additionally it is allowed to index into an AbstractDataFrame using a two-dimensional CartesianIndex.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"In the descriptions below df represents a DataFrame, sdf is a SubDataFrame and dfr is a DataFrameRow.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":": always expands to axes(df, 1) or axes(sdf, 1).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"df.col works like df[!, col] and sdf.col works like sdf[!, col] in all cases except that df.col .= v and sdf.col .= v perform in-place broadcasting if col is present in df/sdf and is a valid identifier.","category":"page"},{"location":"lib/indexing/#getindex-and-view-1","page":"Indexing","title":"getindex and view","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of getindex and view operations depending on argument types.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions that the data is copied or reused without copying.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"For performance reasons, accessing, via getindex or view, a single row and multiple cols of a DataFrame, a SubDataFrame or a DataFrameRow always returns a DataFrameRow (which is a view type).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"getindex on DataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"df[row, col] -> the value contained in row row of column col, the same as df[!, col][row];\ndf[CartesianIndex(row, col)] -> the same as df[row,col];\ndf[row, cols] -> a DataFrameRow with parent df;\ndf[rows, col] -> a copy of the vector df[!, col] with only the entries corresponding to rows selected,                    the same as df[!, col][rows];\ndf[rows, cols] -> a DataFrame containing copies of columns cols with only the entries corresponding to rows selected;\ndf[!, col] -> the vector contained in column col returned without copying; the same as df.col if col is a valid identifier.\ndf[!, cols] -> create a new DataFrame with columns cols without copying of columns;                  the same as select(df, cols, copycols=false).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"view on DataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"@view df[row, col] -> a 0-dimensional view into df[!, col] in row row, the same as view(df[!, col], row);\n@view df[CartesianIndex(row, col)] -> the same as @view df[row, col];\n@view df[row, cols] -> the same as df[row, cols];\n@view df[rows, col] -> a view into df[!, col] with rows selected, the same as view(df[!, col], rows);\n@view df[rows, cols] -> a SubDataFrame with rows selected with parent df;\n@view df[!, col] -> a view into df[!, col]  with all rows.\n@view df[!, cols] -> the same as @view df[:, cols].","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"getindex on SubDataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"sdf[row, col] -> a value contained in row row of column col;\nsdf[CartesianIndex(row, col)] -> the same as sdf[row,col];\nsdf[row, cols] -> a DataFrameRow with parent parent(sdf);\nsdf[rows, col] -> a copy of sdf[!, col] with only rows rows selected, the same as sdf[!, col][rows];\nsdf[rows, cols] -> a DataFrame containing columns cols and sdf[rows, col] as a vector for each col in cols;\nsdf[!, col] -> a view of entries corresponding to sdf in the vector parent(sdf)[!, col];                  the same as sdf.col if col is a valid identifier.\nsdf[!, cols] -> create a new SubDataFrame with columns cols, the same parent as sdf, and the same rows selected;                   the same as select(sdf, cols, copycols=false).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"view on SubDataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"@view sdf[row, col] -> a 0-dimensional view into df[!, col] at row row, the same as view(sdf[!, col], row);\n@view sdf[CartesianIndex(row, col)] -> the same as @view sdf[row, col];\n@view sdf[row, cols] -> a DataFrameRow with parent parent(sdf);\n@view sdf[rows, col] -> a view into sdf[!, col] vector with rows selected, the same as view(sdf[!, col], rows);\n@view sdf[rows, cols] -> a SubDataFrame with parent parent(sdf);\n@view sdf[!, col] -> a view into sdf[!, col] vector with all rows.\n@view sdf[!, cols] -> the same as @view sdf[:, cols].","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"getindex on DataFrameRow:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"dfr[col] -> the value contained in column col of dfr; the same as dfr.col if col is a valid identifier;\ndfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"view on DataFrameRow:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"@view dfr[col] -> a 0-dimensional view into parent(dfr)[DataFrames.row(dfr), col];\n@view dfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that views created with columns selector set to : change their columns' count if columns are added/removed/renamed in the parent; if column selector is other than : then view points to selected columns by their number at the moment of creation of the view.","category":"page"},{"location":"lib/indexing/#setindex!-1","page":"Indexing","title":"setindex!","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of setindex! operations depending on argument types.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions if the assignment is in-place.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that if a setindex! operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"setindex! on DataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"df[row, col] = v -> set value of col in row row to v in-place;\ndf[CartesianIndex(row, col)] = v -> the same as df[row, col] = v;\ndf[row, cols] = v -> set row row of columns cols in-place; the same as dfr = df[row, cols]; dfr[:] = v;\ndf[rows, col] = v -> set rows rows of column col in-place; v must be an AbstractVector;                        if rows is : and col is a Symbol or AbstractString                        that is not present in df then a new column in df is created and holds a copy of v; equivalent to df.col = copy(v) if col is a valid identifier;\ndf[rows, cols] = v -> set rows rows of columns cols in-place; v must be an AbstractMatrix or an AbstractDataFrame                     (in this case column names must match);\ndf[!, col] = v -> replaces col with v without copying                     (with the exception that if v is an AbstractRange it gets converted to a Vector);                     also if col is a Symbol or AbstractString that is not present in df then                     a new column in df is created and holds v;                     equivalent to df.col = v if col is a valid identifier;                     this is allowed if ncol(df) == 0 || length(v) == nrow(df);\ndf[!, cols] = v -> replaces existing columns cols in data frame df with copying;                      v must be an AbstractMatrix or an AbstractDataFrame                      (in the latter case column names must match);","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"setindex! on SubDataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"sdf[row, col] = v -> set value of col in row row to v in-place;\nsdf[CartesianIndex(row, col)] = v -> the same as sdf[row, col] = v;\nsdf[row, cols] = v -> the same as dfr = df[row, cols]; dfr[:] = v in-place;\nsdf[rows, col] = v -> set rows rows of column col, in-place; v must be an abstract vector;\nsdf[rows, cols] = v -> set rows rows of columns cols in-place;                          v can be an AbstractMatrix or v can be AbstractDataFrame when column names must match;","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] = v, sdf[!, cols] = v and sdf.col = v are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"setindex! on DataFrameRow:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"dfr[col] = v -> set value of col in row row to v in-place;                   equivalent to dfr.col = v if col is a valid identifier;\ndfr[cols] = v -> set values of entries in columns cols in dfr by elements of v in place;                    v can be:                    1) a Tuple or an AbstractArray,                       in which cases it must have a number of elements equal to length(dfr),                    2) an AbstractDict, in which case column names must match,                    3) a NamedTuple or DataFrameRow, in which case column names and order must match;","category":"page"},{"location":"lib/indexing/#Broadcasting-1","page":"Indexing","title":"Broadcasting","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following broadcasting rules apply to AbstractDataFrame objects:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"AbstractDataFrame behaves in broadcasting like a two-dimensional collection compatible with matrices.\nIf an AbstractDataFrame takes part in broadcasting then a DataFrame is always produced as a result. In this case the requested broadcasting operation produces an object with exactly two dimensions. An exception is when an AbstractDataFrame is used only as a source of broadcast assignment into an object of dimensionality higher than two.\nIf multiple AbstractDataFrame objects take part in broadcasting then they have to have identical column names.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that if broadcasting assignment operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Broadcasting DataFrameRow is currently not allowed (which is consistent with NamedTuple).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"It is possible to assign a value to AbstractDataFrame and DataFrameRow objects using the .= operator. In such an operation AbstractDataFrame is considered as two-dimensional and DataFrameRow as single-dimensional.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"note: Note\nThe rule above means that, similar to single-dimensional objects in Base (e.g. vectors), DataFrameRow is considered to be column-oriented.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Additional rules:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"in the df[CartesianIndex(row, col)] .= v, df[row, col] .= v syntaxes v is broadcasted into the contents of df[row, col] (this is consistent with Julia Base);\nin the df[row, cols] .= v syntaxes the assignment to df is performed in-place;\nin the df[rows, col] .= v and df[rows, cols] .= v syntaxes the assignment to df is performed in-place; if rows is : and col is Symbol or AbstractString and it is missing from df then a new column is allocated and added; the length of the column is always the value of nrow(df) before the assignment takes place;\nin the df[!, col] .= v syntax column col is replaced by a freshly allocated vector; if col is Symbol or AbstractString and it is missing from df then a new column is allocated added; the length of the column is always the value of nrow(df) before the assignment takes place;\nthe df[!, cols] .= v syntax replaces existing columns cols in data frame df with freshly allocated vectors;\ndf.col .= v syntax is allowed and performs in-place assignment to an existing vector df.col.\nin the sdf[CartesianIndex(row, col)] .= v, sdf[row, col] .= v and sdf[row, cols] .= v syntaxes the assignment to sdf is performed in-place;\nin the sdf[rows, col] .= v and sdf[rows, cols] .= v syntaxes the assignment to sdf is performed in-place;\nsdf.col .= v syntax is allowed and performs in-place assignment to an existing vector sdf.col.\ndfr.col .= v syntax is allowed and performs in-place assignment to a value extracted by dfr.col.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] .= v and sdf[!, cols] .= v syntaxes are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"If column indexing using Symbol or AbstractString names in cols is performed, the order of columns in the operation is specified by the order of names.","category":"page"},{"location":"lib/indexing/#Indexing-GroupedDataFrames-1","page":"Indexing","title":"Indexing GroupedDataFrames","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"A GroupedDataFrame can behave as either an AbstractVector or AbstractDict depending on the type of index used. Integers (or arrays of them) trigger vector-like indexing while Tupless and NamedTuples trigger dictionary-like indexing. An intermediate between the two is the GroupKey type returned by keys(::GroupedDataFrame), which behaves similarly to a NamedTuple but has performance on par with integer indexing.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The elements of a GroupedDataFrame are SubDataFrames of its parent.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"gd[i::Integer] -> Get the ith group.\ngd[key::NamedTuple] -> Get the group corresponding to the given values of the grouping columns. The fields of the NamedTuple must match the grouping columns columns passed to groupby (including order).\ngd[key::Tuple] -> Same as previous, but omitting the names on key.\nget(gd, key::Union{Tuple, NamedTuple}, default) -> Get group for key key, returning default if it does not exist.\ngd[key::GroupKey] -> Get the group corresponding to the GroupKey key (one of the elements of the vector returned by keys(::GroupedDataFrame)). This should be nearly as fast as integer indexing.\ngd[a::AbstractVector] -> Select multiple groups and return them in a new GroupedDataFrame object. Groups may be selected by integer position using an array of Integers or Bools, similar to a standard array. Alternatively the array may contain keys of any of the types supported for dictionary-like indexing (GroupKey, Tuple, or NamedTuple). Selected groups must be unique, and different types of indices cannot be mixed.\ngd[n::Not] -> Any of the above types wrapped in Not. The result  will be a new GroupedDataFrame containing all groups in gd not selected  by the wrapped index.","category":"page"},{"location":"lib/indexing/#Common-API-for-types-defined-in-DataFrames.jl-1","page":"Indexing","title":"Common API for types defined in DataFrames.jl","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"This table presents return value types of calling names, propertynames and keys on types exposed to the user by DataFrames.jl:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Type names propertynames keys\nAbstractDataFrame Vector{String} Vector{Symbol} undefined\nDataFrameRow Vector{String} Vector{Symbol} Vector{Symbol}\nDataFrameRows Vector{String} Vector{Symbol} vector of Int\nDataFrameColumns Vector{String} Vector{Symbol} Vector{Symbol}\nGroupedDataFrame Vector{String} tuple of fields GroupKeys\nGroupKeys undefined tuple of fields vector of Int\nGroupKey Vector{String} Vector{Symbol} Vector{Symbol}","category":"page"},{"location":"man/reshaping_and_pivoting/#Reshaping-and-Pivoting-Data-1","page":"Reshaping","title":"Reshaping and Pivoting Data","text":"","category":"section"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Reshape data from wide to long format using the stack function:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> using DataFrames, CSV\n\njulia> iris = DataFrame(CSV.File(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\")));\n\njulia> first(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64     │ Float64    │ Float64     │ Float64    │ String      │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ Iris-setosa │\n│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n\njulia> last(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64     │ Float64    │ Float64     │ Float64    │ String         │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ Iris-virginica │\n│ 2   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ Iris-virginica │\n│ 3   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ Iris-virginica │\n│ 4   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ Iris-virginica │\n│ 5   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 6   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ Iris-virginica │\n\njulia> d = stack(iris, 1:4);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ Species     │ variable    │ value   │\n│     │ String      │ Cat…        │ Float64 │\n├─────┼─────────────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ SepalLength │ 5.4     │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ Species        │ variable   │ value   │\n│     │ String         │ Cat…       │ Float64 │\n├─────┼────────────────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ PetalWidth │ 2.5     │\n│ 2   │ Iris-virginica │ PetalWidth │ 2.3     │\n│ 3   │ Iris-virginica │ PetalWidth │ 1.9     │\n│ 4   │ Iris-virginica │ PetalWidth │ 2.0     │\n│ 5   │ Iris-virginica │ PetalWidth │ 2.3     │\n│ 6   │ Iris-virginica │ PetalWidth │ 1.8     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"The second optional argument to stack indicates the columns to be stacked. These are normally referred to as the measured variables. Column names can also be given:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, [:SepalLength, :SepalWidth, :PetalLength, :PetalWidth]);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ Species     │ variable    │ value   │\n│     │ String      │ Cat…        │ Float64 │\n├─────┼─────────────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ SepalLength │ 5.4     │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ Species        │ variable   │ value   │\n│     │ String         │ Cat…       │ Float64 │\n├─────┼────────────────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ PetalWidth │ 2.5     │\n│ 2   │ Iris-virginica │ PetalWidth │ 2.3     │\n│ 3   │ Iris-virginica │ PetalWidth │ 1.9     │\n│ 4   │ Iris-virginica │ PetalWidth │ 2.0     │\n│ 5   │ Iris-virginica │ PetalWidth │ 2.3     │\n│ 6   │ Iris-virginica │ PetalWidth │ 1.8     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Note that all columns can be of different types. Type promotion follows the rules of vcat.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"The stacked DataFrame that results includes all of the columns not specified to be stacked. These are repeated for each stacked column. These are normally refered to as identifier (id) columns. In addition to the id columns, two additional columns labeled :variable and :values contain the column identifier and the stacked columns.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"A third optional argument to stack represents the id columns that are repeated. This makes it easier to specify which variables you want included in the long format:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, [:SepalLength, :SepalWidth], :Species);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ Species     │ variable    │ value   │\n│     │ String      │ Cat…        │ Float64 │\n├─────┼─────────────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ SepalLength │ 5.4     │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ Species        │ variable   │ value   │\n│     │ String         │ Cat…       │ Float64 │\n├─────┼────────────────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ SepalWidth │ 3.3     │\n│ 2   │ Iris-virginica │ SepalWidth │ 3.0     │\n│ 3   │ Iris-virginica │ SepalWidth │ 2.5     │\n│ 4   │ Iris-virginica │ SepalWidth │ 3.0     │\n│ 5   │ Iris-virginica │ SepalWidth │ 3.4     │\n│ 6   │ Iris-virginica │ SepalWidth │ 3.0     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"If you prefer to specify the id columns then use Not with stack like this:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, Not(:Species));\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ Species     │ variable    │ value   │\n│     │ String      │ Cat…        │ Float64 │\n├─────┼─────────────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ SepalLength │ 5.4     │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ Species        │ variable   │ value   │\n│     │ String         │ Cat…       │ Float64 │\n├─────┼────────────────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ PetalWidth │ 2.5     │\n│ 2   │ Iris-virginica │ PetalWidth │ 2.3     │\n│ 3   │ Iris-virginica │ PetalWidth │ 1.9     │\n│ 4   │ Iris-virginica │ PetalWidth │ 2.0     │\n│ 5   │ Iris-virginica │ PetalWidth │ 2.3     │\n│ 6   │ Iris-virginica │ PetalWidth │ 1.8     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"unstack converts from a long format to a wide format. The default is requires specifying which columns are an id variable, column variable names, and column values:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> iris.id = 1:size(iris, 1)\n1:150\n\njulia> longdf = stack(iris, Not([:Species, :id]));\n\njulia> first(longdf, 6)\n6×4 DataFrame\n│ Row │ Species     │ id    │ variable    │ value   │\n│     │ String      │ Int64 │ Cat…        │ Float64 │\n├─────┼─────────────┼───────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ 1     │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ 2     │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ 3     │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ 4     │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ 5     │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ 6     │ SepalLength │ 5.4     │\n\njulia> last(longdf, 6)\n6×4 DataFrame\n│ Row │ Species        │ id    │ variable   │ value   │\n│     │ String         │ Int64 │ Cat…       │ Float64 │\n├─────┼────────────────┼───────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ 145   │ PetalWidth │ 2.5     │\n│ 2   │ Iris-virginica │ 146   │ PetalWidth │ 2.3     │\n│ 3   │ Iris-virginica │ 147   │ PetalWidth │ 1.9     │\n│ 4   │ Iris-virginica │ 148   │ PetalWidth │ 2.0     │\n│ 5   │ Iris-virginica │ 149   │ PetalWidth │ 2.3     │\n│ 6   │ Iris-virginica │ 150   │ PetalWidth │ 1.8     │\n\njulia> widedf = unstack(longdf, :id, :variable, :value);\n\njulia> first(widedf, 6)\n6×5 DataFrame\n│ Row │ id    │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ Int64 │ Float64?    │ Float64?   │ Float64?    │ Float64?   │\n├─────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ 1     │ 5.1         │ 3.5        │ 1.4         │ 0.2        │\n│ 2   │ 2     │ 4.9         │ 3.0        │ 1.4         │ 0.2        │\n│ 3   │ 3     │ 4.7         │ 3.2        │ 1.3         │ 0.2        │\n│ 4   │ 4     │ 4.6         │ 3.1        │ 1.5         │ 0.2        │\n│ 5   │ 5     │ 5.0         │ 3.6        │ 1.4         │ 0.2        │\n│ 6   │ 6     │ 5.4         │ 3.9        │ 1.7         │ 0.4        │\n\njulia> last(widedf, 6)\n6×5 DataFrame\n│ Row │ id    │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ Int64 │ Float64?    │ Float64?   │ Float64?    │ Float64?   │\n├─────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ 145   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │\n│ 2   │ 146   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │\n│ 3   │ 147   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │\n│ 4   │ 148   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │\n│ 5   │ 149   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │\n│ 6   │ 150   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"If the remaining columns are unique, you can skip the id variable and use:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> longdf = stack(iris, Not([:Species, :id]));\n\njulia> first(longdf, 6)\n6×4 DataFrame\n│ Row │ Species     │ id    │ variable    │ value   │\n│     │ String      │ Int64 │ Cat…        │ Float64 │\n├─────┼─────────────┼───────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ 1     │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ 2     │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ 3     │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ 4     │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ 5     │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ 6     │ SepalLength │ 5.4     │\n\njulia> last(longdf, 6)\n6×4 DataFrame\n│ Row │ Species        │ id    │ variable   │ value   │\n│     │ String         │ Int64 │ Cat…       │ Float64 │\n├─────┼────────────────┼───────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ 145   │ PetalWidth │ 2.5     │\n│ 2   │ Iris-virginica │ 146   │ PetalWidth │ 2.3     │\n│ 3   │ Iris-virginica │ 147   │ PetalWidth │ 1.9     │\n│ 4   │ Iris-virginica │ 148   │ PetalWidth │ 2.0     │\n│ 5   │ Iris-virginica │ 149   │ PetalWidth │ 2.3     │\n│ 6   │ Iris-virginica │ 150   │ PetalWidth │ 1.8     │\n\njulia> widedf = unstack(longdf, :variable, :value);\n\njulia> first(widedf, 6)\n6×6 DataFrame\n│ Row │ Species     │ id    │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ String      │ Int64 │ Float64?    │ Float64?   │ Float64?    │ Float64?   │\n├─────┼─────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ Iris-setosa │ 1     │ 5.1         │ 3.5        │ 1.4         │ 0.2        │\n│ 2   │ Iris-setosa │ 2     │ 4.9         │ 3.0        │ 1.4         │ 0.2        │\n│ 3   │ Iris-setosa │ 3     │ 4.7         │ 3.2        │ 1.3         │ 0.2        │\n│ 4   │ Iris-setosa │ 4     │ 4.6         │ 3.1        │ 1.5         │ 0.2        │\n│ 5   │ Iris-setosa │ 5     │ 5.0         │ 3.6        │ 1.4         │ 0.2        │\n│ 6   │ Iris-setosa │ 6     │ 5.4         │ 3.9        │ 1.7         │ 0.4        │\n\njulia> last(widedf, 6)\n6×6 DataFrame\n│ Row │ Species        │ id    │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ String         │ Int64 │ Float64?    │ Float64?   │ Float64?    │ Float64?   │\n├─────┼────────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ Iris-virginica │ 145   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │\n│ 2   │ Iris-virginica │ 146   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │\n│ 3   │ Iris-virginica │ 147   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │\n│ 4   │ Iris-virginica │ 148   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │\n│ 5   │ Iris-virginica │ 149   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │\n│ 6   │ Iris-virginica │ 150   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"You can even skip passing the :variable and :value values as positional arguments, as they will be used by default, and write:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> widedf = unstack(longdf);\n\njulia> first(widedf, 6)\n6×6 DataFrame\n│ Row │ Species     │ id    │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ String      │ Int64 │ Float64?    │ Float64?   │ Float64?    │ Float64?   │\n├─────┼─────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ Iris-setosa │ 1     │ 5.1         │ 3.5        │ 1.4         │ 0.2        │\n│ 2   │ Iris-setosa │ 2     │ 4.9         │ 3.0        │ 1.4         │ 0.2        │\n│ 3   │ Iris-setosa │ 3     │ 4.7         │ 3.2        │ 1.3         │ 0.2        │\n│ 4   │ Iris-setosa │ 4     │ 4.6         │ 3.1        │ 1.5         │ 0.2        │\n│ 5   │ Iris-setosa │ 5     │ 5.0         │ 3.6        │ 1.4         │ 0.2        │\n│ 6   │ Iris-setosa │ 6     │ 5.4         │ 3.9        │ 1.7         │ 0.4        │\n\njulia> last(widedf, 6)\n6×6 DataFrame\n│ Row │ Species        │ id    │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ String         │ Int64 │ Float64?    │ Float64?   │ Float64?    │ Float64?   │\n├─────┼────────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ Iris-virginica │ 145   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │\n│ 2   │ Iris-virginica │ 146   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │\n│ 3   │ Iris-virginica │ 147   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │\n│ 4   │ Iris-virginica │ 148   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │\n│ 5   │ Iris-virginica │ 149   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │\n│ 6   │ Iris-virginica │ 150   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Passing view=true to stack returns a data frame whose columns are views into the original wide data frame. Here is an example:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, view=true);\n\njulia> first(d, 6)\n6×4 DataFrame\n│ Row │ Species     │ id    │ variable    │ value   │\n│     │ String      │ Int64 │ Cat…        │ Float64 │\n├─────┼─────────────┼───────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ 1     │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ 2     │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ 3     │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ 4     │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ 5     │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ 6     │ SepalLength │ 5.4     │\n\njulia> last(d, 6)\n6×4 DataFrame\n│ Row │ Species        │ id    │ variable   │ value   │\n│     │ String         │ Int64 │ Cat…       │ Float64 │\n├─────┼────────────────┼───────┼────────────┼─────────┤\n│ 1   │ Iris-virginica │ 145   │ PetalWidth │ 2.5     │\n│ 2   │ Iris-virginica │ 146   │ PetalWidth │ 2.3     │\n│ 3   │ Iris-virginica │ 147   │ PetalWidth │ 1.9     │\n│ 4   │ Iris-virginica │ 148   │ PetalWidth │ 2.0     │\n│ 5   │ Iris-virginica │ 149   │ PetalWidth │ 2.3     │\n│ 6   │ Iris-virginica │ 150   │ PetalWidth │ 1.8     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"This saves memory. To create the view, several AbstractVectors are defined:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":":variable column – EachRepeatedVector This repeats the variables N times where N is the number of rows of the original AbstractDataFrame.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":":value column – StackedVector This is provides a view of the original columns stacked together.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Id columns – RepeatedVector This repeats the original columns N times where N is the number of columns stacked.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"None of these reshaping functions perform any aggregation. To do aggregation, use the split-apply-combine functions in combination with reshaping. Here is an example:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> using Statistics\n\njulia> d = stack(iris, Not(:Species));\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ Species     │ variable    │ value   │\n│     │ String      │ Cat…        │ Float64 │\n├─────┼─────────────┼─────────────┼─────────┤\n│ 1   │ Iris-setosa │ SepalLength │ 5.1     │\n│ 2   │ Iris-setosa │ SepalLength │ 4.9     │\n│ 3   │ Iris-setosa │ SepalLength │ 4.7     │\n│ 4   │ Iris-setosa │ SepalLength │ 4.6     │\n│ 5   │ Iris-setosa │ SepalLength │ 5.0     │\n│ 6   │ Iris-setosa │ SepalLength │ 5.4     │\n\njulia> x = by(d, [:variable, :Species], :value => mean => :vsum);\n\njulia> first(x, 6)\n│ Row │ variable    │ Species         │ vsum    │\n│     │ Cat…        │ String          │ Float64 │\n├─────┼─────────────┼─────────────────┼─────────┤\n│ 1   │ SepalLength │ Iris-setosa     │ 5.006   │\n│ 2   │ SepalLength │ Iris-versicolor │ 5.936   │\n│ 3   │ SepalLength │ Iris-virginica  │ 6.588   │\n│ 4   │ SepalWidth  │ Iris-setosa     │ 3.418   │\n│ 5   │ SepalWidth  │ Iris-versicolor │ 2.77    │\n│ 6   │ SepalWidth  │ Iris-virginica  │ 2.974   │\n\njulia> first(unstack(x, :Species, :vsum), 6)\n5×4 DataFrame\n│ Row │ variable    │ Iris-setosa │ Iris-versicolor │ Iris-virginica │\n│     │ Cat…        │ Float64?    │ Float64?        │ Float64?       │\n├─────┼─────────────┼─────────────┼─────────────────┼────────────────┤\n│ 1   │ SepalLength │ 5.006       │ 5.936           │ 6.588          │\n│ 2   │ SepalWidth  │ 3.418       │ 2.77            │ 2.974          │\n│ 3   │ PetalLength │ 1.464       │ 4.26            │ 5.552          │\n│ 4   │ PetalWidth  │ 0.244       │ 1.326           │ 2.026          │\n│ 5   │ id          │ 25.5        │ 75.5            │ 125.5          │","category":"page"},{"location":"man/categorical/#Categorical-Data-1","page":"Categorical Data","title":"Categorical Data","text":"","category":"section"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Often, we have to deal with factors that take on a small number of levels:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> v = [\"Group A\", \"Group A\", \"Group A\", \"Group B\", \"Group B\", \"Group B\"]\n6-element Array{String,1}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"The naive encoding used in an Array represents every entry of this vector as a full string. In contrast, we can represent the data more efficiently by replacing the strings with indices into a small pool of levels. This is what the CategoricalArray type does:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> using CategoricalArrays\n\njulia> cv = CategoricalArray(v)\n6-element CategoricalArray{String,1,UInt32}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"CategoricalArrays support missing values.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = CategoricalArray([\"Group A\", missing, \"Group A\",\n                              \"Group B\", \"Group B\", missing])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"In addition to representing repeated data efficiently, the CategoricalArray type allows us to determine efficiently the allowed levels of the variable at any time using the levels function (note that levels may or may not be actually used in the data):","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> levels(cv)\n2-element Array{String,1}:\n \"Group A\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"The levels! function also allows changing the order of appearance of the levels, which can be useful for display purposes or when working with ordered variables.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> levels!(cv, [\"Group B\", \"Group A\"]);\n\njulia> levels(cv)\n2-element Array{String,1}:\n \"Group B\"\n \"Group A\"\n\njulia> sort(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group B\"\n \"Group B\"\n \"Group A\"\n \"Group A\"\n missing\n missing\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"By default, a CategoricalArray is able to represent 2^32 different levels. You can use less memory by calling the compress function:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = compress(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt8}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Instead of using the CategoricalArray constructor directly you can use categorical function. It additionally accepts a keyword argument compress which when set to true is equivalent to calling compress on the new vector:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv1 = categorical([\"A\", \"B\"], compress=true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"If the ordered keyword argument is set to true, the resulting CategoricalArray will be ordered, which means that its levels can be tested for order (rather than throwing an error):","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv2 = categorical([\"A\", \"B\"], ordered=true)\n2-element CategoricalArray{String,1,UInt32}:\n \"A\"\n \"B\"\n\njulia> cv1[1] < cv1[2]\nERROR: ArgumentError: Unordered CategoricalValue objects cannot be tested for order using <. Use isless instead, or call the ordered! function on the parent array to change this\n\njulia> cv2[1] < cv2[2]\ntrue","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"You can check if a CategoricalArray is ordered using the isordered function and change between ordered and unordered using ordered! function.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> isordered(cv1)\nfalse\n\njulia> ordered!(cv1, true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> isordered(cv1)\ntrue\n\njulia> cv1[1] < cv1[2]\ntrue","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Often, you will have factors encoded inside a DataFrame with Vector columns instead of CategoricalVector columns. You can convert one or more columns of the DataFrame using the categorical! function, which modifies the input DataFrame in-place. Compression can be applied by setting the compress keyword argument to true.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = [\"A\", \"B\", \"C\", \"D\", \"D\", \"A\"],\n                      B = [\"X\", \"X\", \"X\", \"Y\", \"Y\", \"Y\"])\n6×2 DataFrame\n│ Row │ A      │ B      │\n│     │ String │ String │\n├─────┼────────┼────────┤\n│ 1   │ A      │ X      │\n│ 2   │ B      │ X      │\n│ 3   │ C      │ X      │\n│ 4   │ D      │ Y      │\n│ 5   │ D      │ Y      │\n│ 6   │ A      │ Y      │\n\njulia> categorical!(df, :A) # change the column `:A` to be categorical\n6×2 DataFrame\n│ Row │ A    │ B      │\n│     │ Cat… │ String │\n├─────┼──────┼────────┤\n│ 1   │ A    │ X      │\n│ 2   │ B    │ X      │\n│ 3   │ C    │ X      │\n│ 4   │ D    │ Y      │\n│ 5   │ D    │ Y      │\n│ 6   │ A    │ Y      │","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"If columns are not specified, all columns with an AbstractString element type are converted to be categorical. In the example below we also enable compression:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> categorical!(df, compress=true)\n6×2 DataFrame\n│ Row │ A    │ B    │\n│     │ Cat… │ Cat… │\n├─────┼──────┼──────┤\n│ 1   │ A    │ X    │\n│ 2   │ B    │ X    │\n│ 3   │ C    │ X    │\n│ 4   │ D    │ Y    │\n│ 5   │ D    │ Y    │\n│ 6   │ A    │ Y    │\n\njulia> eltype.(eachcol(df))\n2-element Array{DataType,1}:\n CategoricalValue{String,UInt8}\n CategoricalValue{String,UInt8}\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Using categorical arrays is important for working with the GLM package. When fitting regression models, CategoricalVector columns in the input are translated into 0/1 indicator columns in the ModelMatrix with one column for each of the levels of the CategoricalVector. This allows one to analyze categorical data efficiently.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"See the CategoricalArrays package for more information regarding categorical arrays.","category":"page"},{"location":"man/sorting/#Sorting-1","page":"Sorting","title":"Sorting","text":"","category":"section"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"Sorting is a fundamental component of data analysis. Basic sorting is trivial: just calling sort! will sort all columns, in place:","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"julia> using DataFrames, CSV\n\njulia> iris = DataFrame(CSV.File(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\")));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ Iris-virginica │\n│ 2   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ Iris-virginica │\n│ 3   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 4   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ Iris-virginica │\n\njulia> sort!(iris);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.3         │ 3.0        │ 1.1         │ 0.1        │ Iris-setosa │\n│ 2   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.4         │ 3.0        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.4         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 7.7         │ 2.8        │ 6.7         │ 2.0        │ Iris-virginica │\n│ 2   │ 7.7         │ 3.0        │ 6.1         │ 2.3        │ Iris-virginica │\n│ 3   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n│ 4   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"Observe that all columns are taken into account lexicographically when sorting the DataFrame.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"You can also call the sort function to create a new DataFrame with freshly allocated sorted vectors.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"In sorting DataFrames, you may want to sort different columns with different options. Here are some examples showing most of the possible options:","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, rev = true);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │\n│ 2   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n│ 3   │ 7.7         │ 3.0        │ 6.1         │ 2.3        │ Iris-virginica │\n│ 4   │ 7.7         │ 2.8        │ 6.7         │ 2.0        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.4         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.4         │ 3.0        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.3         │ 3.0        │ 1.1         │ 0.1        │ Iris-setosa │\n\njulia> sort!(iris, [:Species, :SepalWidth]);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.5         │ 2.3        │ 1.3         │ 0.3        │ Iris-setosa │\n│ 2   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 5.0         │ 3.0        │ 1.6         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 2   │ 7.2         │ 3.6        │ 6.1         │ 2.5        │ Iris-virginica │\n│ 3   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │\n│ 4   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n\njulia> sort!(iris, (order(:Species, by=length), order(:SepalLength, rev=true)));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.8         │ 4.0        │ 1.2         │ 0.2        │ Iris-setosa │\n│ 2   │ 5.7         │ 3.8        │ 1.7         │ 0.3        │ Iris-setosa │\n│ 3   │ 5.7         │ 4.4        │ 1.5         │ 0.4        │ Iris-setosa │\n│ 4   │ 5.5         │ 3.5        │ 1.3         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species         │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?         │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────────┤\n│ 1   │ 5.1         │ 2.5        │ 3.0         │ 1.1        │ Iris-versicolor │\n│ 2   │ 5.0         │ 2.0        │ 3.5         │ 1.0        │ Iris-versicolor │\n│ 3   │ 5.0         │ 2.3        │ 3.3         │ 1.0        │ Iris-versicolor │\n│ 4   │ 4.9         │ 2.4        │ 3.3         │ 1.0        │ Iris-versicolor │","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"Keywords used above include rev (to sort in reverse), and by (to apply a function to values before comparing them). Each keyword can either be a single value, a vector with values corresponding to individual columns, or a selector: :, All, Not, Between, or Regex.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"As an alternative to using a vector values you can use order to specify an ordering for a particular column within a set of columns.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"The following two examples show two ways to sort the iris dataset with the same result: :Species will be ordered in reverse order, and within groups, rows will be sorted by increasing :PetalLength:","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, [:Species, :PetalLength], rev=(true, false));\n\njulia> julia> sort!(iris, [:Species, :PetalLength], rev=(true, false));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 4.9         │ 2.5        │ 4.5         │ 1.7        │ Iris-virginica │\n│ 2   │ 6.2         │ 2.8        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 3   │ 6.0         │ 3.0        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 4   │ 6.3         │ 2.7        │ 4.9         │ 1.8        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n│ 2   │ 5.1         │ 3.3        │ 1.7         │ 0.5        │ Iris-setosa │\n│ 3   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ Iris-setosa │\n│ 4   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ Iris-setosa │\n\njulia> sort!(iris, [order(:Species, rev=true), :PetalLength]);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 4.9         │ 2.5        │ 4.5         │ 1.7        │ Iris-virginica │\n│ 2   │ 6.2         │ 2.8        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 3   │ 6.0         │ 3.0        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 4   │ 6.3         │ 2.7        │ 4.9         │ 1.8        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64?    │ Float64?   │ Float64?    │ Float64?   │ String?     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n│ 2   │ 5.1         │ 3.3        │ 1.7         │ 0.5        │ Iris-setosa │\n│ 3   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ Iris-setosa │\n│ 4   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ Iris-setosa │","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"lib/types/#Type-hierarchy-design-1","page":"Types","title":"Type hierarchy design","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractDataFrame is an abstract type that provides an interface for data frame types. It is not intended as a fully generic interface for working with tabular data, which is the role of interfaces defined by Tables.jl instead.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"DataFrame is the most fundamental subtype of AbstractDataFrame, which stores a set of columns as AbstractVector objects.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"SubDataFrame is an AbstractDataFrame subtype representing a view into a DataFrame. It stores only a reference to the parent DataFrame and information about which rows and columns from the parent are selected (both as integer indices referring to the parent). Typically it is created using the view function or is returned by indexing into a GroupedDataFrame object.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"GroupedDataFrame is a type that stores the result of a  grouping operation performed on an AbstractDataFrame. It is intended to be created as a result of a call to the groupby function.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"DataFrameRow is a view into a single row of an AbstractDataFrame. It stores only a reference to a parent DataFrame and information about which row and columns from the parent are selected (both as integer indices referring to the parent) The DataFrameRow type supports iteration over columns of the row and is similar in functionality to the NamedTuple type, but allows for modification of data stored in the parent DataFrame and reflects changes done to the parent after the creation of the view. Typically objects of the DataFrameRow type are encountered when returned by the eachrow function, or when accessing a single row of a DataFrame or SubDataFrame via getindex or view.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The eachrow function returns a value of the DataFrameRows type, which serves as an iterator over rows of an AbstractDataFrame, returning DataFrameRow objects.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Similarly, the eachcol function returns a value of the DataFrameColumns type, which serves as an iterator over columns of an AbstractDataFrame.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The DataFrameRows and DataFrameColumns types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but using the eachrow and eachcol functions.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The RepeatedVector and StackedVector types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but they are columns of a DataFrame returned by stack with view=true.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The ByRow type is a special type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The AsTable type is a special type used for selection operations to signal that the columns selected by a wrapped selector should be passed as a NamedTuple to the function.","category":"page"},{"location":"lib/types/#man-columnhandling-1","page":"Types","title":"The design of handling of columns of a DataFrame","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"When a DataFrame is constructed columns are copied by default. You can disable this behavior by setting copycols keyword argument to false or by using the DataFrame! function. The exception is if an AbstractRange is passed as a column, then it is always collected to a Vector.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Also functions that transform a DataFrame to produce a new DataFrame perform a copy of the columns, unless they are passed copycols=false (available only for functions that could perform a transformation without copying the columns). Examples of such functions are vcat, hcat, filter, dropmissing, join, getindex, copy or the DataFrame constructor mentioned above.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"On the contrary, functions that create a view of a DataFrame do not by definition make copies of the columns, and therefore require particular caution. This includes view, which returns a SubDataFrame or a DataFrameRow, and groupby, which returns a GroupedDataFrame.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"A partial exception to this rule is the stack function with view=true which creates a DataFrame that contains views of the columns from the source DataFrame.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"In-place functions whose names end with ! (like sort! or dropmissing!, setindex!, push!, append!) may mutate the column vectors of the DataFrame they take as an argument. These functions are safe to call due to the rules described above, except when a view of the DataFrame is in use (via a SubDataFrame, a DataFrameRow or a GroupedDataFrame). In the latter case, calling such a function on the parent might corrupt the view, which make trigger errors, silently return invalid data or even cause Julia to crash. The same caution applies when DataFrame was created using columns of another DataFrame without copying (for instance when copycols=false in functions such as DataFrame or hcat).","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"It is possible to have a direct access to a column col of a DataFrame df (e.g. this can be useful in performance critical code to avoid copying), using one of the following methods:","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"via the getproperty function using the syntax df.col;\nvia the getindex function using the syntax df[!, :col] (note this is in contrast to df[:, :col] which copies);\nby creating a DataFrameColumns object using the eachcol function;\nby calling the parent function on a view of a column of the DataFrame, e.g. parent(@view df[:, :col]);\nby storing the reference to the column before creating a DataFrame with copycols=false;","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"A column obtained from a DataFrame using one of the above methods should not be mutated without caution because:","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"resizing a column vector will corrupt its parent DataFrame and any associated views as methods only check the length of the column when it is added to the DataFrame and later assume that all columns have the same length;\nreordering values in a column vector (e.g. using sort!) will break the consistency of rows with other columns, which will also affect views (if any);\nchanging values contained in a column vector is acceptable as long as it is not used as a grouping column in a GroupedDataFrame created based on the DataFrame.","category":"page"},{"location":"lib/types/#Types-specification-1","page":"Types","title":"Types specification","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractDataFrame\nAsTable\nByRow\nDataFrame\nDataFrameRow\nGroupedDataFrame\nGroupKey\nGroupKeys\nSubDataFrame\nDataFrameRows\nDataFrameColumns\nRepeatedVector\nStackedVector","category":"page"},{"location":"lib/types/#DataFrames.AbstractDataFrame","page":"Types","title":"DataFrames.AbstractDataFrame","text":"AbstractDataFrame\n\nAn abstract type for which all concrete types expose an interface for working with tabular data.\n\nCommon methods\n\nAn AbstractDataFrame is a two-dimensional table with Symbols or strings for column names.\n\nThe following are normally implemented for AbstractDataFrames:\n\ndescribe : summarize columns\nsummary : show number of rows and columns\nhcat : horizontal concatenation\nvcat : vertical concatenation\nrepeat : repeat rows\nnames : columns names\nrename! : rename columns names based on keyword arguments\nlength : number of columns\nsize : (nrows, ncols)\nfirst : first n rows\nlast : last n rows\nconvert : convert to an array\ncompletecases : boolean vector of complete cases (rows with no missings)\ndropmissing : remove rows with missing values\ndropmissing! : remove rows with missing values in-place\nnonunique : indexes of duplicate rows\nunique : remove duplicate rows\nunique! : remove duplicate rows in-place\ndisallowmissing : drop support for missing values in columns\ndisallowmissing! : drop support for missing values in columns in-place\nallowmissing : add support for missing values in columns\nallowmissing! : add support for missing values in columns in-place\ncategorical : change column types to categorical\ncategorical! : change column types to categorical in-place\nsimilar : a DataFrame with similar columns as d\nfilter : remove rows\nfilter! : remove rows in-place\n\nIndexing and broadcasting\n\nAbstractDataFrame can be indexed by passing two indices specifying row and column selectors. The allowed indices are a superset of indices that can be used for standard arrays. You can also access a single column of an AbstractDataFrame using getproperty and setproperty! functions. Columns can be selected using integers, Symbols, or strings. In broadcasting AbstractDataFrame behavior is similar to a Matrix.\n\nA detailed description of getindex, setindex!, getproperty, setproperty!, broadcasting and broadcasting assignment for data frames is given in the \"Indexing\" section of the manual.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.AsTable","page":"Types","title":"DataFrames.AsTable","text":"AsTable(cols)\n\nA type used for selection operations to signal that the columns selected by the wrapped selector should be passed as a NamedTuple to the function.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.ByRow","page":"Types","title":"DataFrames.ByRow","text":"ByRow\n\nA type used for selection operations to signal that the wrapped function should be applied to each element (row) of the selection.\n\nNote that ByRow always collects values returned by fun in a vector. Therefore, to allow for future extensions, returning NamedTuple or DataFrameRow from fun is currently disallowed.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrame","page":"Types","title":"DataFrames.DataFrame","text":"DataFrame <: AbstractDataFrame\n\nAn AbstractDataFrame that stores a set of named columns\n\nThe columns are normally AbstractVectors stored in memory, particularly a Vector or CategoricalVector.\n\nConstructors\n\nDataFrame(columns::AbstractVector, names::AbstractVector{Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::AbstractVector, names::AbstractVector{<:AbstractString};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::NTuple{N,AbstractVector}, names::NTuple{N,Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::NTuple{N,AbstractVector}, names::NTuple{N,<:AbstractString};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::Matrix, names::AbstractVector{Symbol}; makeunique::Bool=false)\nDataFrame(columns::Matrix, names::AbstractVector{<:AbstractString};\n          makeunique::Bool=false)\nDataFrame(kwargs...)\nDataFrame(pairs::Pair{Symbol,<:Any}...; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(pairs::Pair{<:AbstractString,<:Any}...; makeunique::Bool=false,\n          copycols::Bool=true)\nDataFrame() # an empty DataFrame\nDataFrame(column_eltypes::AbstractVector, names::AbstractVector{Symbol},\n          nrows::Integer=0; makeunique::Bool=false)\nDataFrame(column_eltypes::AbstractVector, names::AbstractVector{<:AbstractString},\n          nrows::Integer=0; makeunique::Bool=false)\nDataFrame(ds::AbstractDict; copycols::Bool=true)\nDataFrame(table; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(::Union{DataFrame, SubDataFrame}; copycols::Bool=true)\nDataFrame(::GroupedDataFrame)\n\nArguments\n\ncolumns : a Vector with each column as contents or a Matrix\nnames : the column names\nmakeunique : if false (the default), an error will be raised if duplicates in names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nkwargs : the key gives the column names, and the value is the column contents; note that the copycols keyword argument indicates if if vectors passed as columns should be copied so it is not possible to create a column whose name is :copycols using this constructor\nt : elemental type of all columns\nnrows, ncols : number of rows and columns\ncolumn_eltypes : element type of each column\ncategorical : a vector of Bool indicating which columns should be converted to CategoricalVector\nds : AbstractDict of columns\ntable : any type that implements the Tables.jl interface; in particular a tuple or vector of Pair{Symbol, <:AbstractVector}} objects is a table.\ncopycols : whether vectors passed as columns should be copied; if set to false then the constructor will still copy the passed columns if it is not possible to construct a DataFrame without materializing new columns.\n\nAll columns in columns must be AbstractVectors and have the same length. An exception are DataFrame(kwargs...) and DataFrame(pairs::Pair...) form constructors which additionally allow a column to be of any other type that is not an AbstractArray, in which case the passed value is automatically repeated to fill a new vector of the appropriate length. As a particular rule values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way.\n\nNotes\n\nThe DataFrame constructor by default copies all columns vectors passed to it. Pass copycols=false to reuse vectors without copying them\n\nIf a column is passed to a DataFrame constructor or is assigned as a whole using setindex! then its reference is stored in the DataFrame. An exception to this rule is assignment of an AbstractRange as a column, in which case the range is collected to a Vector.\n\nBecause column types can vary, a DataFrame is not type stable. For performance-critical code, do not index into a DataFrame inside of loops.\n\nExamples\n\ndf = DataFrame()\nv = [\"x\",\"y\",\"z\"][rand(1:3, 10)]\ndf1 = DataFrame(Any[collect(1:10), v, rand(10)], [:A, :B, :C])\ndf2 = DataFrame(A = 1:10, B = v, C = rand(10))\nsummary(df1)\ndescribe(df2)\nfirst(df1, 10)\ndf1.B\ndf2[!, :C]\ndf1[:, :A]\ndf1[1:4, 1:2]\ndf1[Not(1:4), Not(1:2)]\ndf1[1:2, [:A,:C]]\ndf1[1:2, r\"[AC]\"]\ndf1[:, [:A,:C]]\ndf1[:, [1,3]]\ndf1[1:4, :]\ndf1[1:4, :C]\ndf1[1:4, :C] = 40. * df1[1:4, :C]\n[df1; df2]  # vcat\n[df1 df2]  # hcat\nsize(df1)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRow","page":"Types","title":"DataFrames.DataFrameRow","text":"DataFrameRow{<:AbstractDataFrame,<:AbstractIndex}\n\nA view of one row of an AbstractDataFrame.\n\nA DataFrameRow is returned by getindex or view functions when one row and a selection of columns are requested, or when iterating the result of the call to the eachrow function.\n\nThe DataFrameRow constructor can also be called directly:\n\nDataFrameRow(parent::AbstractDataFrame, row::Integer, cols=:)\n\nA DataFrameRow supports the iteration interface and can therefore be passed to functions that expect a collection as an argument.\n\nIndexing is one-dimensional like specifying a column of a DataFrame. You can also access the data in a DataFrameRow using the getproperty and setproperty! functions and convert it to a NamedTuple using the copy function.\n\nIt is possible to create a DataFrameRow with duplicate columns. All such columns will have a reference to the same entry in the parent DataFrame.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then DataFrameRow will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\ndf = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n               b = repeat([2, 1], outer=[4]),\n               c = randn(8))\nsdf1 = view(df, 2, :)\nsdf2 = @view df[end, [:a]]\nsdf3 = eachrow(df)[1]\nsdf4 = DataFrameRow(df, 2, 1:2)\nsdf5 = DataFrameRow(df, 1)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupedDataFrame","page":"Types","title":"DataFrames.GroupedDataFrame","text":"GroupedDataFrame\n\nThe result of a groupby operation on an AbstractDataFrame; a view into the AbstractDataFrame grouped by rows.\n\nNot meant to be constructed directly, see groupby.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKey","page":"Types","title":"DataFrames.GroupKey","text":"GroupKey{T<:GroupedDataFrame}\n\nKey for one of the groups of a GroupedDataFrame. Contains the values of the corresponding grouping columns and behaves similarly to a NamedTuple, but using it to index its GroupedDataFrame is much more effecient than using the equivalent Tuple or NamedTuple.\n\nInstances of this type are returned by keys(::GroupedDataFrame) and are not meant to be constructed directly.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKeys","page":"Types","title":"DataFrames.GroupKeys","text":"GroupKeys{T<:GroupedDataFrame} <: AbstractVector{GroupKey{T}}\n\nA vector containing all GroupKey objects for a given GroupedDataFrame.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.SubDataFrame","page":"Types","title":"DataFrames.SubDataFrame","text":"SubDataFrame{<:AbstractDataFrame,<:AbstractIndex,<:AbstractVector{Int}} <: AbstractDataFrame\n\nA view of an AbstractDataFrame. It is returned by a call to the view function on an AbstractDataFrame if a collections of rows and columns are specified.\n\nA SubDataFrame is an AbstractDataFrame, so expect that most DataFrame functions should work. Such methods include describe, summary, nrow, size, by, stack, and join.\n\nIndexing is just like a DataFrame except that it is possible to create a SubDataFrame with duplicate columns. All such columns will have a reference to the same entry in the parent DataFrame.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then SubDataFrame will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\ndf = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n               b = repeat([2, 1], outer=[4]),\n               c = randn(8))\nsdf1 = view(df, 2:3) # column subsetting\nsdf2 = @view df[end:-1:1, [1,3]]  # row and column subsetting\nsdf3 = groupby(df, :a)[1]  # indexing a GroupedDataFrame returns a SubDataFrame\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRows","page":"Types","title":"DataFrames.DataFrameRows","text":"DataFrameRows{D<:AbstractDataFrame} <: AbstractVector{DataFrameRow{D,S}}\n\nIterator over rows of an AbstractDataFrame, with each row represented as a DataFrameRow.\n\nA value of this type is returned by the eachrow function.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameColumns","page":"Types","title":"DataFrames.DataFrameColumns","text":"DataFrameColumns{<:AbstractDataFrame} <: AbstractVector{AbstractVector}\n\nAn AbstractVector that allows iteration over columns of an AbstractDataFrame. Indexing into DataFrameColumns objects using integer or symbol indices returns the corresponding column (without copying).\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.RepeatedVector","page":"Types","title":"DataFrames.RepeatedVector","text":"RepeatedVector{T} <: AbstractVector{T}\n\nAn AbstractVector that is a view into another AbstractVector with repeated elements\n\nNOTE: Not exported.\n\nConstructor\n\nRepeatedVector(parent::AbstractVector, inner::Int, outer::Int)\n\nArguments\n\nparent : the AbstractVector that's repeated\ninner : the numer of times each element is repeated\nouter : the numer of times the whole vector is repeated after expanded by inner\n\ninner and outer have the same meaning as similarly named arguments to repeat.\n\nExamples\n\nRepeatedVector([1,2], 3, 1)   # [1,1,1,2,2,2]\nRepeatedVector([1,2], 1, 3)   # [1,2,1,2,1,2]\nRepeatedVector([1,2], 2, 2)   # [1,2,1,2,1,2,1,2]\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.StackedVector","page":"Types","title":"DataFrames.StackedVector","text":"StackedVector <: AbstractVector\n\nAn AbstractVector that is a linear, concatenated view into another set of AbstractVectors\n\nNOTE: Not exported.\n\nConstructor\n\nStackedVector(d::AbstractVector)\n\nArguments\n\nd... : one or more AbstractVectors\n\nExamples\n\nStackedVector(Any[[1,2], [9,10], [11,12]])  # [1,2,9,10,11,12]\n\n\n\n\n\n","category":"type"},{"location":"man/joins/#Database-Style-Joins-1","page":"Joins","title":"Database-Style Joins","text":"","category":"section"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"We often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> using DataFrames\n\njulia> people = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n│ 2   │ 40    │ Jane Doe │\n\njulia> jobs = DataFrame(ID = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 40    │ Doctor │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"We might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the innerjoin function:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> innerjoin(people, jobs, on = :ID)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n│ 2   │ 40    │ Jane Doe │ Doctor │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"The following functions are provided to perform seven kinds of joins:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"innerjoin: the output contains rows for values of the key that exist in all passed data frames.\nleftjoin: the output contains rows for values of the key that exist in the first (left) argument,   whether or not that value exists in the second (right) argument.\nrightjoin: the output contains rows for values of the key that exist in the second (right) argument,   whether or not that value exists in the first (left) argument.\nouterjoin: the output contains rows for values of the key that exist in any of the passed data frames.\nsemijoin: Like an inner join, but output is restricted to columns from the first (left) argument.\nantijoin: The output contains rows for values of the key that exist in the first (left) but not the second (right) argument.   As with semijoin, output is restricted to columns from the first (left) argument.\ncrossjoin: The output is the cartesian product of rows from all passed data frames.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"See the Wikipedia page on SQL joins for more information.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Here are examples of different kinds of join:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> jobs = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Astronaut\"])\n2×2 DataFrame\n│ Row │ ID    │ Job       │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 20    │ Lawyer    │\n│ 2   │ 60    │ Astronaut │\n\njulia> innerjoin(people, jobs, on = :ID)\n1×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n\njulia> leftjoin(people, jobs, on = :ID)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job     │\n│     │ Int64 │ String   │ String? │\n├─────┼───────┼──────────┼─────────┤\n│ 1   │ 20    │ John Doe │ Lawyer  │\n│ 2   │ 40    │ Jane Doe │ missing │\n\njulia> rightjoin(people, jobs, on = :ID)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job       │\n│     │ Int64 │ String?  │ String    │\n├─────┼───────┼──────────┼───────────┤\n│ 1   │ 20    │ John Doe │ Lawyer    │\n│ 2   │ 60    │ missing  │ Astronaut │\n\njulia> outerjoin(people, jobs, on = :ID)\n3×3 DataFrame\n│ Row │ ID    │ Name     │ Job       │\n│     │ Int64 │ String?  │ String?   │\n├─────┼───────┼──────────┼───────────┤\n│ 1   │ 20    │ John Doe │ Lawyer    │\n│ 2   │ 40    │ Jane Doe │ missing   │\n│ 3   │ 60    │ missing  │ Astronaut │\n\njulia> semijoin(people, jobs, on = :ID)\n1×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n\njulia> antijoin(people, jobs, on = :ID)\n1×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 40    │ Jane Doe │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Cross joins are the only kind of join that does not use a on key:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> crossjoin(people, jobs, makeunique = true)\n4×4 DataFrame\n│ Row │ ID    │ Name     │ ID_1  │ Job       │\n│     │ Int64 │ String   │ Int64 │ String    │\n├─────┼───────┼──────────┼───────┼───────────┤\n│ 1   │ 20    │ John Doe │ 20    │ Lawyer    │\n│ 2   │ 20    │ John Doe │ 60    │ Astronaut │\n│ 3   │ 40    │ Jane Doe │ 20    │ Lawyer    │\n│ 4   │ 40    │ Jane Doe │ 60    │ Astronaut │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"In order to join data frames on keys which have different names in the left and right tables, you may pass (left, right) tuples or left => right pairs as on argument:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n│ 2   │ 40    │ Jane Doe │\n\njulia> b = DataFrame(IDNew = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ IDNew │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 40    │ Doctor │\n\njulia> innerjoin(a, b, on = :ID => :IDNew)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n│ 2   │ 40    │ Jane Doe │ Doctor │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Here is another example with multiple columns:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> a = DataFrame(City = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Job = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Category = [1, 2, 3, 4, 5])\n5×3 DataFrame\n│ Row │ City      │ Job    │ Category │\n│     │ String    │ String │ Int64    │\n├─────┼───────────┼────────┼──────────┤\n│ 1   │ Amsterdam │ Lawyer │ 1        │\n│ 2   │ London    │ Lawyer │ 2        │\n│ 3   │ London    │ Lawyer │ 3        │\n│ 4   │ New York  │ Doctor │ 4        │\n│ 5   │ New York  │ Doctor │ 5        │\n\njulia> b = DataFrame(Location = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Work = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Name = [\"a\", \"b\", \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ Location  │ Work   │ Name   │\n│     │ String    │ String │ String │\n├─────┼───────────┼────────┼────────┤\n│ 1   │ Amsterdam │ Lawyer │ a      │\n│ 2   │ London    │ Lawyer │ b      │\n│ 3   │ London    │ Lawyer │ c      │\n│ 4   │ New York  │ Doctor │ d      │\n│ 5   │ New York  │ Doctor │ e      │\n\njulia> innerjoin(a, b, on = [(:City, :Location), (:Job, :Work)])\n9×4 DataFrame\n│ Row │ City      │ Job    │ Category │ Name   │\n│     │ String    │ String │ Int64    │ String │\n├─────┼───────────┼────────┼──────────┼────────┤\n│ 1   │ Amsterdam │ Lawyer │ 1        │ a      │\n│ 2   │ London    │ Lawyer │ 2        │ b      │\n│ 3   │ London    │ Lawyer │ 2        │ c      │\n│ 4   │ London    │ Lawyer │ 3        │ b      │\n│ 5   │ London    │ Lawyer │ 3        │ c      │\n│ 6   │ New York  │ Doctor │ 4        │ d      │\n│ 7   │ New York  │ Doctor │ 4        │ e      │\n│ 8   │ New York  │ Doctor │ 5        │ d      │\n│ 9   │ New York  │ Doctor │ 5        │ e      │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Additionally, notice that in the last join rows 2 and 3 had the same values on on variables in both joined DataFrames. In such a situation innerjoin, outerjoin, leftjoin and rightjoin will produce all combinations of matching rows. In our example rows from 2 to 5 were created as a result. The same behavior can be observed for rows 4 and 5 in both joined DataFrames.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"In order to check that columns passed as the on argument define unique keys (according to isequal) in each input data frame you can set the validate keyword argument to a two-element tuple or a pair of Bool values, with each element indicating whether to run check for the corresponding data frame. Here is an example for the join operation described above:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> innerjoin(a, b, on = [(:City, :Location), (:Job, :Work)], validate=(true, true))\nERROR: ArgumentError: Merge key(s) are not unique in both df1 and df2. First duplicate in df1 at 3. First duplicate in df2 at 3","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Finally, using the indicator keyword argument you can add a column to the resulting data frame indicating whether the given row appeared only in the left, the right or both data frames. Here is an example:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID = [20, 40], Name = [\"John\", \"Jane\"])\n2×2 DataFrame\n│ Row │ ID    │ Name   │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ John   │\n│ 2   │ 40    │ Jane   │\n\njulia> b = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 60    │ Doctor │\n\njulia> outerjoin(a, b, on=:ID, validate=(true, true), indicator=:source)\n3×4 DataFrame\n│ Row │ ID    │ Name    │ Job     │ source     │\n│     │ Int64 │ String? │ String? │ Cat…       │\n├─────┼───────┼─────────┼─────────┼────────────┤\n│ 1   │ 20    │ John    │ Lawyer  │ both       │\n│ 2   │ 40    │ Jane    │ missing │ left_only  │\n│ 3   │ 60    │ missing │ Doctor  │ right_only │","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Note that this time we also used the validate keyword argument and it did not produce errors as the keys defined in both source data frames were unique.","category":"page"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#Joining,-Grouping,-and-Split-Apply-Combine-1","page":"Functions","title":"Joining, Grouping, and Split-Apply-Combine","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"innerjoin\nleftjoin\nrightjoin\nouterjoin\nantijoin\nsemijoin\ncrossjoin\nby\ncombine\ngroupby\ngroupindices\ngroupcols\nvaluecols\nkeys\nget\nmap\nstack\nunstack","category":"page"},{"location":"lib/functions/#DataFrames.innerjoin","page":"Functions","title":"DataFrames.innerjoin","text":"innerjoin(df1, df2; on, makeunique = false,\n          validate = (false, false))\ninnerjoin(df1, df2, dfs...; on, makeunique = false,\n          validate = (false, false))\n\nPerform an inner join of two or more data frame objects and return a DataFrame containing the result. An inner join includes rows with keys that match in all passed data frames.\n\nArguments\n\ndf1, df2, dfs...: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the validate keyword argument is applied recursively with left associativity.\n\nSee also: leftjoin, rightjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ John Doe  │\n│ 2   │ 2     │ Jane Doe  │\n│ 3   │ 3     │ Joe Blogs │\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ Lawyer │\n│ 2   │ 2     │ Doctor │\n│ 3   │ 4     │ Farmer │\n\njulia> innerjoin(name, job, on = :ID)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 1     │ John Doe │ Lawyer │\n│ 2   │ 2     │ Jane Doe │ Doctor │\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ identifier │ Job    │\n│     │ Int64      │ String │\n├─────┼────────────┼────────┤\n│ 1   │ 1          │ Lawyer │\n│ 2   │ 2          │ Doctor │\n│ 3   │ 4          │ Farmer │\n\njulia> innerjoin(name, job2, on = :ID => :identifier)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 1     │ John Doe │ Lawyer │\n│ 2   │ 2     │ Jane Doe │ Doctor │\n\njulia> innerjoin(name, job2, on = [:ID => :identifier])\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 1     │ John Doe │ Lawyer │\n│ 2   │ 2     │ Jane Doe │ Doctor │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.leftjoin","page":"Functions","title":"DataFrames.leftjoin","text":"leftjoin(df1, df2; on, makeunique = false,\n         indicator = nothing, validate = (false, false))\n\nPerform a left join of twodata frame objects and return a DataFrame containing the result. A left join includes all rows from df1.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol, adds categorical indicator  column named Symbol for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If Symbol is already in use,  the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nAll columns of the returned data table will support missing values.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, rightjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ John Doe  │\n│ 2   │ 2     │ Jane Doe  │\n│ 3   │ 3     │ Joe Blogs │\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ Lawyer │\n│ 2   │ 2     │ Doctor │\n│ 3   │ 4     │ Farmer │\n\njulia> leftjoin(name, job, on = :ID)\n3×3 DataFrame\n│ Row │ ID    │ Name      │ Job     │\n│     │ Int64 │ String    │ String? │\n├─────┼───────┼───────────┼─────────┤\n│ 1   │ 1     │ John Doe  │ Lawyer  │\n│ 2   │ 2     │ Jane Doe  │ Doctor  │\n│ 3   │ 3     │ Joe Blogs │ missing │\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ identifier │ Job    │\n│     │ Int64      │ String │\n├─────┼────────────┼────────┤\n│ 1   │ 1          │ Lawyer │\n│ 2   │ 2          │ Doctor │\n│ 3   │ 4          │ Farmer │\n\njulia> leftjoin(name, job2, on = :ID => :identifier)\n3×3 DataFrame\n│ Row │ ID    │ Name      │ Job     │\n│     │ Int64 │ String    │ String? │\n├─────┼───────┼───────────┼─────────┤\n│ 1   │ 1     │ John Doe  │ Lawyer  │\n│ 2   │ 2     │ Jane Doe  │ Doctor  │\n│ 3   │ 3     │ Joe Blogs │ missing │\n\njulia> leftjoin(name, job2, on = [:ID => :identifier])\n3×3 DataFrame\n│ Row │ ID    │ Name      │ Job     │\n│     │ Int64 │ String    │ String? │\n├─────┼───────┼───────────┼─────────┤\n│ 1   │ 1     │ John Doe  │ Lawyer  │\n│ 2   │ 2     │ Jane Doe  │ Doctor  │\n│ 3   │ 3     │ Joe Blogs │ missing │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rightjoin","page":"Functions","title":"DataFrames.rightjoin","text":"rightjoin(df1, df2; on, makeunique = false,\n          indicator = nothing, validate = (false, false))\n\nPerform a right join on two data frame objects and return a DataFrame containing the result. A right join includes all rows from df2.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol, adds categorical indicator  column named Symbol for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If Symbol is already in use,  the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nAll columns of the returned data table will support missing values.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, leftjoin, outerjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ John Doe  │\n│ 2   │ 2     │ Jane Doe  │\n│ 3   │ 3     │ Joe Blogs │\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ Lawyer │\n│ 2   │ 2     │ Doctor │\n│ 3   │ 4     │ Farmer │\n\njulia> rightjoin(name, job, on = :ID)\n3×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String?  │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 1     │ John Doe │ Lawyer │\n│ 2   │ 2     │ Jane Doe │ Doctor │\n│ 3   │ 4     │ missing  │ Farmer │\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ identifier │ Job    │\n│     │ Int64      │ String │\n├─────┼────────────┼────────┤\n│ 1   │ 1          │ Lawyer │\n│ 2   │ 2          │ Doctor │\n│ 3   │ 4          │ Farmer │\n\njulia> rightjoin(name, job2, on = :ID => :identifier)\n3×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String?  │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 1     │ John Doe │ Lawyer │\n│ 2   │ 2     │ Jane Doe │ Doctor │\n│ 3   │ 4     │ missing  │ Farmer │\n\njulia> rightjoin(name, job2, on = [:ID => :identifier])\n3×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String?  │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 1     │ John Doe │ Lawyer │\n│ 2   │ 2     │ Jane Doe │ Doctor │\n│ 3   │ 4     │ missing  │ Farmer │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.outerjoin","page":"Functions","title":"DataFrames.outerjoin","text":"outerjoin(df1, df2; on, kind = :inner, makeunique = false,\n          indicator = nothing, validate = (false, false))\nouterjoin(df1, df2, dfs...; on, kind = :inner, makeunique = false,\n          validate = (false, false))\n\nPerform an outer join of two or more data frame objects and return a DataFrame containing the result. An outer join includes rows with keys that appear in any of the passed data frames.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. on is a required argument.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol, adds categorical indicator  column named Symbol for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If Symbol is already in use,  the column name will be modified if makeunique=true.  This argument is only supported when joining exactly two data frames.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nAll columns of the returned data table will support missing values.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the indicator keyword argument is not supported and validate keyword argument is applied recursively with left associativity.\n\nSee also: innerjoin, leftjoin, rightjoin,           semijoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ John Doe  │\n│ 2   │ 2     │ Jane Doe  │\n│ 3   │ 3     │ Joe Blogs │\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ Lawyer │\n│ 2   │ 2     │ Doctor │\n│ 3   │ 4     │ Farmer │\n\njulia> outerjoin(name, job, on = :ID)\n4×3 DataFrame\n│ Row │ ID    │ Name      │ Job     │\n│     │ Int64 │ String?   │ String? │\n├─────┼───────┼───────────┼─────────┤\n│ 1   │ 1     │ John Doe  │ Lawyer  │\n│ 2   │ 2     │ Jane Doe  │ Doctor  │\n│ 3   │ 3     │ Joe Blogs │ missing │\n│ 4   │ 4     │ missing   │ Farmer  │\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ identifier │ Job    │\n│     │ Int64      │ String │\n├─────┼────────────┼────────┤\n│ 1   │ 1          │ Lawyer │\n│ 2   │ 2          │ Doctor │\n│ 3   │ 4          │ Farmer │\n\njulia> outerjoin(name, job2, on = :ID => :identifier)\n4×3 DataFrame\n│ Row │ ID    │ Name      │ Job     │\n│     │ Int64 │ String?   │ String? │\n├─────┼───────┼───────────┼─────────┤\n│ 1   │ 1     │ John Doe  │ Lawyer  │\n│ 2   │ 2     │ Jane Doe  │ Doctor  │\n│ 3   │ 3     │ Joe Blogs │ missing │\n│ 4   │ 4     │ missing   │ Farmer  │\n\njulia> outerjoin(name, job2, on = [:ID => :identifier])\n4×3 DataFrame\n│ Row │ ID    │ Name      │ Job     │\n│     │ Int64 │ String?   │ String? │\n├─────┼───────┼───────────┼─────────┤\n│ 1   │ 1     │ John Doe  │ Lawyer  │\n│ 2   │ 2     │ Jane Doe  │ Doctor  │\n│ 3   │ 3     │ Joe Blogs │ missing │\n│ 4   │ 4     │ missing   │ Farmer  │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.antijoin","page":"Functions","title":"DataFrames.antijoin","text":"antijoin(df1, df2; on, makeunique = false, validate = (false, false))\n\nPerform an anti join of two data frame objects and return a DataFrame containing the result. An anti join returns the subset of rows of df1 that do not match with the keys in df2.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, semijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ John Doe  │\n│ 2   │ 2     │ Jane Doe  │\n│ 3   │ 3     │ Joe Blogs │\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ Lawyer │\n│ 2   │ 2     │ Doctor │\n│ 3   │ 4     │ Farmer │\n\njulia> antijoin(name, job, on = :ID)\n1×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 3     │ Joe Blogs │\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ identifier │ Job    │\n│     │ Int64      │ String │\n├─────┼────────────┼────────┤\n│ 1   │ 1          │ Lawyer │\n│ 2   │ 2          │ Doctor │\n│ 3   │ 4          │ Farmer │\n\njulia> antijoin(name, job2, on = :ID => :identifier)\n1×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 3     │ Joe Blogs │\n\njulia> antijoin(name, job2, on = [:ID => :identifier])\n1×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 3     │ Joe Blogs │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.semijoin","page":"Functions","title":"DataFrames.semijoin","text":"semijoin(df1, df2; on, makeunique = false, validate = (false, false))\n\nPerform a semi join of two data frame objects and return a DataFrame containing the result. A semi join returns the subset of rows of df1 that match with the keys in df2.\n\nArguments\n\ndf1, df2: the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed).\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol, adds categorical indicator  column named Symbol for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If Symbol is already in use,  the column name will be modified if makeunique=true.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left data frame takes precedence over the ordering of the right data frame.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, antijoin, crossjoin.\n\nExamples\n\njulia> name = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 DataFrame\n│ Row │ ID    │ Name      │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ John Doe  │\n│ 2   │ 2     │ Jane Doe  │\n│ 3   │ 3     │ Joe Blogs │\n\njulia> job = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ Lawyer │\n│ 2   │ 2     │ Doctor │\n│ 3   │ 4     │ Farmer │\n\njulia> semijoin(name, job, on = :ID)\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 1     │ John Doe │\n│ 2   │ 2     │ Jane Doe │\n\njulia> job2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n3×2 DataFrame\n│ Row │ identifier │ Job    │\n│     │ Int64      │ String │\n├─────┼────────────┼────────┤\n│ 1   │ 1          │ Lawyer │\n│ 2   │ 2          │ Doctor │\n│ 3   │ 4          │ Farmer │\n\njulia> semijoin(name, job2, on = :ID => :identifier)\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 1     │ John Doe │\n│ 2   │ 2     │ Jane Doe │\n\njulia> semijoin(name, job2, on = [:ID => :identifier])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 1     │ John Doe │\n│ 2   │ 2     │ Jane Doe │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.crossjoin","page":"Functions","title":"DataFrames.crossjoin","text":"crossjoin(df1, df2, dfs...; makeunique = false)\n\nPerform a cross join of two or more data frame objects and return a DataFrame containing the result. A cross join returns the cartesian product of rows from all passed data frames.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf more than two data frames are passed, the join is performed recursively with left associativity.\n\nSee also: innerjoin, leftjoin, rightjoin,           outerjoin, semijoin, antijoin.\n\nExamples\n\njulia> df1 = DataFrame(X=1:3)\n3×1 DataFrame\n│ Row │ X     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> df2 = DataFrame(Y=[\"a\", \"b\"])\n2×1 DataFrame\n│ Row │ Y      │\n│     │ String │\n├─────┼────────┤\n│ 1   │ a      │\n│ 2   │ b      │\n\njulia> crossjoin(df1, df2)\n6×2 DataFrame\n│ Row │ X     │ Y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ a      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 2     │ b      │\n│ 5   │ 3     │ a      │\n│ 6   │ 3     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.by","page":"Functions","title":"DataFrames.by","text":"by(d::AbstractDataFrame, cols::Any, args...;\n   sort::Bool=false, skipmissing::Bool=false, keepkeys::Bool=true)\nby(fun::Union{Function, Type}, d::AbstractDataFrame, cols::Any;\n   sort::Bool=false, skipmissing::Bool=false, keepkeys::Bool=true)\nby(pair::Pair, d::AbstractDataFrame, cols::Any;\n   sort::Bool=false, skipmissing::Bool=false, keepkeys::Bool=true)\nby(d::AbstractDataFrame, cols::Any, fun::Union{Function, Type};\n   sort::Bool=false, skipmissing::Bool=false, keepkeys::Bool=true)\nby(d::AbstractDataFrame, cols::Any, pair::Pair;\n   sort::Bool=false, skipmissing::Bool=false, keepkeys::Bool=true)\n\nSplit-apply-combine in one step: apply fun, pair or args to each grouping in df based on grouping columns cols, and return a DataFrame. This is a shorthand for combine called on groupby(df, cols, sort=sort, skipmissing=skipmissing).\n\nArguments passed as args... can be:\n\nAny index that is allowed for column indexing (Symbol, string or integer, :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\nColumn transformation operations using the Pair notation that is described below and vectors of such pairs.\n\nTransformations allowed using Pairs follow the rules specified for select and have the form source_cols => fun, source_cols => fun => target_col, or source_col => target_col. Function fun is passed SubArray views as positional arguments for each column specified to be selected, or a NamedTuple containing these SubArrays if source_cols is an AsTable selector. It can return a vector or a single value (defined precisely below).\n\nAs a special case nrow or nrow => target_col can be passed without specifying input columns to efficiently calculate number of rows in each group. If nrow is passed the resulting column name is :nrow.\n\nIf multiple args are passed then return values of different funs are allowed to mix single values and vectors. In this case single values will be broadcasted to match the length of columns specified by returned vectors. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then broadcasted.\n\nIf the first or last argument is pair then it must be a Pair following the rules for pairs described above, except that in this case function defined by fun can return any return value defined below.\n\nIf the first or last argument is a function fun, it is passed a SubDataFrame view for each group and can return any return value defined below. Note that this form is slower than pair or args due to type instability.\n\nfun can return a single value, a row, a vector, or multiple rows. The type of the returned value determines the shape of the resulting DataFrame. There are four kind of return values allowed:\n\nA single value gives a DataFrame with a single additional column and one row per group.\nA named tuple of single values or a DataFrameRow gives a DataFrame with one additional column for each field and one row per group (returning a named tuple will be faster). It is not allowed to mix single values and vectors if a named tuple is returned.\nA vector gives a DataFrame with a single additional column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a DataFrame with the same additional columns and as many rows for each group as the rows returned for that group (returning a named tuple is the fastest option). Returning a table with zero columns is allowed, whatever the number of columns returned for other groups.\n\nfun must always return the same kind of object (out of four kinds defined above) for all groups, and with the same column names.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the Pair syntax (e.g. :col => sum). When computing the sum or mean over floating point columns, results will be less accurate than the standard sum function (which uses pairwise summation). Use col => x -> sum(x) to avoid the optimized method and use the slower, more accurate one.\n\nColumn names are automatically generated when necessary using the rules defined in select if the Pair syntax is used and fun returns a single value or a vector (e.g. for :col => sum the column name is col_sum); otherwise (if fun is a function or a return value is an AbstractMatrix) columns are named x1, x2 and so on.\n\nIf keepkeys=true, the resulting DataFrame contains all the grouping columns in addition to those generated. In this case if the returned value contains columns with the same names as the grouping columns, they are required to be equal.\n\nThe resulting data frame will be sorted if sort=true is passed. Otherwise, ordering of rows is undefined.\n\nIf skipmissing=true rows with missing values in one of the grouping columns cols will be skipped.\n\nSee groupby and combine and for details and more examples.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> by(df, :a, :c => sum, nrow)\n4×3 DataFrame\n│ Row │ a     │ c_sum │ nrow  │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 6     │ 2     │\n│ 2   │ 2     │ 8     │ 2     │\n│ 3   │ 3     │ 10    │ 2     │\n│ 4   │ 4     │ 12    │ 2     │\n\njulia> by(sdf -> sum(sdf.c), df, :a) # Slower variant\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a) do d # do syntax for the slower variant\n           sum(d.c)\n       end\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a, :c => (x -> sum(log, x)) => :sum_log_c) # specifying a name for target column\n4×2 DataFrame\n│ Row │ a     │ sum_log_c │\n│     │ Int64 │ Float64   │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ 1.60944   │\n│ 2   │ 2     │ 2.48491   │\n│ 3   │ 3     │ 3.04452   │\n│ 4   │ 4     │ 3.46574   │\n\njulia> by(df, :a, [:b, :c] .=> sum) # passing a vector of pairs\n4×3 DataFrame\n│ Row │ a     │ b_sum │ c_sum │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 4     │ 6     │\n│ 2   │ 2     │ 2     │ 8     │\n│ 3   │ 3     │ 4     │ 10    │\n│ 4   │ 4     │ 2     │ 12    │\n\njulia> by(df, :a) do sdf # dropping group when DataFrame() is returned\n          sdf.c[1] != 1 ? sdf : DataFrame()\n       end\n6×3 DataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 2     │\n│ 2   │ 2     │ 1     │ 6     │\n│ 3   │ 3     │ 2     │ 3     │\n│ 4   │ 3     │ 2     │ 7     │\n│ 5   │ 4     │ 1     │ 4     │\n│ 6   │ 4     │ 1     │ 8     │\n\njulia> by(df, :a, :b => :b1, :c => :c1,\n               [:b, :c] => +, keepkeys=false) # auto-splatting, renaming and keepkeys\n8×3 DataFrame\n│ Row │ b1    │ c1    │ b_c_+ │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 3     │\n│ 2   │ 2     │ 5     │ 7     │\n│ 3   │ 1     │ 2     │ 3     │\n│ 4   │ 1     │ 6     │ 7     │\n│ 5   │ 2     │ 3     │ 5     │\n│ 6   │ 2     │ 7     │ 9     │\n│ 7   │ 1     │ 4     │ 5     │\n│ 8   │ 1     │ 8     │ 9     │\n\njulia> by(df, :a, :b, :c => sum) # passing columns and broadcasting\n8×3 DataFrame\n│ Row │ a     │ b     │ c_sum │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 6     │\n│ 2   │ 1     │ 2     │ 6     │\n│ 3   │ 2     │ 1     │ 8     │\n│ 4   │ 2     │ 1     │ 8     │\n│ 5   │ 3     │ 2     │ 10    │\n│ 6   │ 3     │ 2     │ 10    │\n│ 7   │ 4     │ 1     │ 12    │\n│ 8   │ 4     │ 1     │ 12    │\n\njulia> by(df, :a, [:b, :c] .=> Ref)\n4×3 DataFrame\n│ Row │ a     │ b_Ref    │ c_Ref    │\n│     │ Int64 │ SubArra… │ SubArra… │\n├─────┼───────┼──────────┼──────────┤\n│ 1   │ 1     │ [2, 2]   │ [1, 5]   │\n│ 2   │ 2     │ [1, 1]   │ [2, 6]   │\n│ 3   │ 3     │ [2, 2]   │ [3, 7]   │\n│ 4   │ 4     │ [1, 1]   │ [4, 8]   │\n\njulia> by(df, :a, AsTable(:) => Ref)\n4×2 DataFrame\n│ Row │ a     │ a_b_c_Ref                            │\n│     │ Int64 │ NamedTuple…                          │\n├─────┼───────┼──────────────────────────────────────┤\n│ 1   │ 1     │ (a = [1, 1], b = [2, 2], c = [1, 5]) │\n│ 2   │ 2     │ (a = [2, 2], b = [1, 1], c = [2, 6]) │\n│ 3   │ 3     │ (a = [3, 3], b = [2, 2], c = [3, 7]) │\n│ 4   │ 4     │ (a = [4, 4], b = [1, 1], c = [4, 8]) │\n\njulia> by(df, :a, :, AsTable(Not(:a)) => sum)\n8×4 DataFrame\n│ Row │ a     │ b     │ c     │ b_c_sum │\n│     │ Int64 │ Int64 │ Int64 │ Int64   │\n├─────┼───────┼───────┼───────┼─────────┤\n│ 1   │ 1     │ 2     │ 1     │ 3       │\n│ 2   │ 1     │ 2     │ 5     │ 7       │\n│ 3   │ 2     │ 1     │ 2     │ 3       │\n│ 4   │ 2     │ 1     │ 6     │ 7       │\n│ 5   │ 3     │ 2     │ 3     │ 5       │\n│ 6   │ 3     │ 2     │ 7     │ 9       │\n│ 7   │ 4     │ 1     │ 4     │ 5       │\n│ 8   │ 4     │ 1     │ 8     │ 9       │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.combine","page":"Functions","title":"DataFrames.combine","text":"combine(gd::GroupedDataFrame, args...; keepkeys::Bool=true)\ncombine(fun::Union{Function, Type}, gd::GroupedDataFrame; keepkeys::Bool=true)\ncombine(pair::Pair, gd::GroupedDataFrame; keepkeys::Bool=true)\ncombine(gd::GroupedDataFrame, fun::Union{Function, Type}; keepkeys::Bool=true)\ncombine(gd::GroupedDataFrame, pair::Pair; keepkeys::Bool=true)\n\nTransform a GroupedDataFrame into a DataFrame.\n\nArguments passed as args... can be:\n\nAny index that is allowed for column indexing (Symbol, string or integer, :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\nColumn transformation operations using the Pair notation that is described below and vectors of such pairs.\n\nTransformations allowed using Pairs follow the rules specified for select and have the form source_cols => fun, source_cols => fun => target_col, or source_col => target_col. Function fun is passed SubArray views as positional arguments for each column specified to be selected, or a NamedTuple containing these SubArrays if source_cols is an AsTable selector. It can return a vector or a single value (defined precisely below).\n\nAs a special case nrow or nrow => target_col can be passed without specifying input columns to efficiently calculate number of rows in each group. If nrow is passed the resulting column name is :nrow.\n\nIf multiple args are passed then return values of different funs are allowed to mix single values and vectors. In this case single values will be broadcasted to match the length of columns specified by returned vectors. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then broadcasted.\n\nIf the first or last argument is pair then it must be a Pair following the rules for pairs described above, except that in this case function defined by fun can return any return value defined below.\n\nIf the first or last argument is a function fun, it is passed a SubDataFrame view for each group and can return any return value defined below. Note that this form is slower than pair or args due to type instability.\n\nfun can return a single value, a row, a vector, or multiple rows. The type of the returned value determines the shape of the resulting DataFrame. There are four kind of return values allowed:\n\nA single value gives a DataFrame with a single additional column and one row per group.\nA named tuple of single values or a DataFrameRow gives a DataFrame with one additional column for each field and one row per group (returning a named tuple will be faster). It is not allowed to mix single values and vectors if a named tuple is returned.\nA vector gives a DataFrame with a single additional column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a DataFrame with the same additional columns and as many rows for each group as the rows returned for that group (returning a named tuple is the fastest option). Returning a table with zero columns is allowed, whatever the number of columns returned for other groups.\n\nfun must always return the same kind of object (out of four kinds defined above) for all groups, and with the same column names.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the Pair syntax (e.g. :col => sum). When computing the sum or mean over floating point columns, results will be less accurate than the standard sum function (which uses pairwise summation). Use col => x -> sum(x) to avoid the optimized method and use the slower, more accurate one.\n\nColumn names are automatically generated when necessary using the rules defined in select if the Pair syntax is used and fun returns a single value or a vector (e.g. for :col => sum the column name is col_sum); otherwise (if fun is a function or a return value is an AbstractMatrix) columns are named x1, x2 and so on.\n\nIf keepkeys=true, the resulting DataFrame contains all the grouping columns in addition to those generated. In this case if the returned value contains columns with the same names as the grouping columns, they are required to be equal.\n\nThe resulting data frame will be sorted if sort=true was passed to the groupby call from which gd was constructed. Otherwise, ordering of rows is undefined.\n\nSee also:\n\nby(f, df, cols) is a shorthand for combine(f, groupby(df, cols)).\nmap: combine(f, groupby(df, cols)) is a more efficient equivalent of combine(map(f, groupby(df, cols))).\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :c => sum, nrow)\n4×3 DataFrame\n│ Row │ a     │ c_sum │ nrow  │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 6     │ 2     │\n│ 2   │ 2     │ 8     │ 2     │\n│ 3   │ 3     │ 10    │ 2     │\n│ 4   │ 4     │ 12    │ 2     │\n\njulia> combine(sdf -> sum(sdf.c), gd) # Slower variant\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a) do d # do syntax for the slower variant\n           sum(d.c)\n       end\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> combine(gd, :c => (x -> sum(log, x)) => :sum_log_c) # specifying a name for target column\n4×2 DataFrame\n│ Row │ a     │ sum_log_c │\n│     │ Int64 │ Float64   │\n├─────┼───────┼───────────┤\n│ 1   │ 1     │ 1.60944   │\n│ 2   │ 2     │ 2.48491   │\n│ 3   │ 3     │ 3.04452   │\n│ 4   │ 4     │ 3.46574   │\n\n\njulia> combine(gd, [:b, :c] .=> sum) # passing a vector of pairs\n4×3 DataFrame\n│ Row │ a     │ b_sum │ c_sum │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 4     │ 6     │\n│ 2   │ 2     │ 2     │ 8     │\n│ 3   │ 3     │ 4     │ 10    │\n│ 4   │ 4     │ 2     │ 12    │\n\njulia> combine(gd) do sdf # dropping group when DataFrame() is returned\n          sdf.c[1] != 1 ? sdf : DataFrame()\n       end\n6×3 DataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 2     │\n│ 2   │ 2     │ 1     │ 6     │\n│ 3   │ 3     │ 2     │ 3     │\n│ 4   │ 3     │ 2     │ 7     │\n│ 5   │ 4     │ 1     │ 4     │\n│ 6   │ 4     │ 1     │ 8     │\n\njulia> combine(gd, :b => :b1, :c => :c1,\n               [:b, :c] => +, keepkeys=false) # auto-splatting, renaming and keepkeys\n8×3 DataFrame\n│ Row │ b1    │ c1    │ b_c_+ │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 3     │\n│ 2   │ 2     │ 5     │ 7     │\n│ 3   │ 1     │ 2     │ 3     │\n│ 4   │ 1     │ 6     │ 7     │\n│ 5   │ 2     │ 3     │ 5     │\n│ 6   │ 2     │ 7     │ 9     │\n│ 7   │ 1     │ 4     │ 5     │\n│ 8   │ 1     │ 8     │ 9     │\n\njulia> combine(gd, :b, :c => sum) # passing columns and broadcasting\n8×3 DataFrame\n│ Row │ a     │ b     │ c_sum │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 6     │\n│ 2   │ 1     │ 2     │ 6     │\n│ 3   │ 2     │ 1     │ 8     │\n│ 4   │ 2     │ 1     │ 8     │\n│ 5   │ 3     │ 2     │ 10    │\n│ 6   │ 3     │ 2     │ 10    │\n│ 7   │ 4     │ 1     │ 12    │\n│ 8   │ 4     │ 1     │ 12    │\n\njulia> combine(gd, [:b, :c] .=> Ref)\n4×3 DataFrame\n│ Row │ a     │ b_Ref    │ c_Ref    │\n│     │ Int64 │ SubArra… │ SubArra… │\n├─────┼───────┼──────────┼──────────┤\n│ 1   │ 1     │ [2, 2]   │ [1, 5]   │\n│ 2   │ 2     │ [1, 1]   │ [2, 6]   │\n│ 3   │ 3     │ [2, 2]   │ [3, 7]   │\n│ 4   │ 4     │ [1, 1]   │ [4, 8]   │\n\njulia> combine(gd, AsTable(:) => Ref)\n4×2 DataFrame\n│ Row │ a     │ a_b_c_Ref                            │\n│     │ Int64 │ NamedTuple…                          │\n├─────┼───────┼──────────────────────────────────────┤\n│ 1   │ 1     │ (a = [1, 1], b = [2, 2], c = [1, 5]) │\n│ 2   │ 2     │ (a = [2, 2], b = [1, 1], c = [2, 6]) │\n│ 3   │ 3     │ (a = [3, 3], b = [2, 2], c = [3, 7]) │\n│ 4   │ 4     │ (a = [4, 4], b = [1, 1], c = [4, 8]) │\n\njulia> combine(gd, :, AsTable(Not(:a)) => sum)\n8×4 DataFrame\n│ Row │ a     │ b     │ c     │ b_c_sum │\n│     │ Int64 │ Int64 │ Int64 │ Int64   │\n├─────┼───────┼───────┼───────┼─────────┤\n│ 1   │ 1     │ 2     │ 1     │ 3       │\n│ 2   │ 1     │ 2     │ 5     │ 7       │\n│ 3   │ 2     │ 1     │ 2     │ 3       │\n│ 4   │ 2     │ 1     │ 6     │ 7       │\n│ 5   │ 3     │ 2     │ 3     │ 5       │\n│ 6   │ 3     │ 2     │ 7     │ 9       │\n│ 7   │ 4     │ 1     │ 4     │ 5       │\n│ 8   │ 4     │ 1     │ 8     │ 9       │\n\nSee by for more examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupby","page":"Functions","title":"DataFrames.groupby","text":"groupby(d::AbstractDataFrame, cols; sort=false, skipmissing=false)\n\nReturn a GroupedDataFrame representing a view of an AbstractDataFrame split into row groups.\n\nArguments\n\ndf : an AbstractDataFrame to split\ncols : data frame columns to group by. Can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\nsort : whether to sort rows according to the values of the grouping columns cols\nskipmissing : whether to skip rows with missing values in one of the grouping columns cols\n\nDetails\n\nAn iterator over a GroupedDataFrame returns a SubDataFrame view for each grouping into df. Within each group, the order of rows in df is preserved.\n\ncols can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group GroupedDataFrame is created.\n\nA GroupedDataFrame also supports indexing by groups, map (which applies a function to each group) and combine (which applies a function to each group and combines the result into a data frame).\n\nSee the following for additional split-apply-combine operations:\n\nby : split-apply-combine using functions\nmap : apply a function to each group of a GroupedDataFrame (without combining)\ncombine : combine a GroupedDataFrame, optionally applying a function to each group\n\nGroupedDataFrame also supports the dictionary interface. The keys are GroupKey objects returned by keys(::GroupedDataFrame), which can also be used to get the values of the grouping columns for each group. Tuples and NamedTuples containing the values of the grouping columns (in the same order as the cols argument) are also accepted as indices, but this will be slower than using the equivalent GroupKey.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (2 rows): a = 1\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n⋮\nLast Group (2 rows): a = 4\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\njulia> gd[1]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n\njulia> last(gd)\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\njulia> gd[(a=3,)]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n\njulia> gd[(3,)]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n\njulia> k = first(keys(gd))\nGroupKey: (a = 3)\n\njulia> gd[k]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n\njulia> for g in gd\n           println(g)\n       end\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 2     │\n│ 2   │ 2     │ 1     │ 6     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupindices","page":"Functions","title":"DataFrames.groupindices","text":"groupindices(gd::GroupedDataFrame)\n\nReturn a vector of group indices for each row of parent(gd).\n\nRows appearing in group gd[i] are attributed index i. Rows not present in any group are attributed missing (this can happen if skipmissing=true was passed when creating gd, or if gd is a subset from a larger GroupedDataFrame).\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupcols","page":"Functions","title":"DataFrames.groupcols","text":"groupcols(gd::GroupedDataFrame)\n\nReturn a vector of Symbol column names in parent(gd) used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.valuecols","page":"Functions","title":"DataFrames.valuecols","text":"valuecols(gd::GroupedDataFrame)\n\nReturn a vector of Symbol column names in parent(gd) not used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.keys","page":"Functions","title":"Base.keys","text":"keys(gd::GroupedDataFrame)\n\nGet the set of keys for each group of the GroupedDataFrame gd as a GroupKeys object. Each key is a GroupKey, which behaves like a NamedTuple holding the values of the grouping columns for a given group. Unlike the equivalent Tuple and NamedTuple, these keys can be used to index into gd efficiently. The ordering of the keys is identical to the ordering of the groups of gd under iteration and integer indexing.\n\nExamples\n\njulia> df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[4]),\n                      b = repeat([2, 1], outer=[6]),\n                      c = 1:12);\n\njulia> gd = groupby(df, [:a, :b])\nGroupedDataFrame with 6 groups based on keys: a, b\nFirst Group (2 rows): a = :foo, b = 2\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ foo    │ 2     │ 1     │\n│ 2   │ foo    │ 2     │ 7     │\n⋮\nLast Group (2 rows): a = :baz, b = 1\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ baz    │ 1     │ 6     │\n│ 2   │ baz    │ 1     │ 12    │\n\njulia> keys(gd)\n6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (a = :foo, b = 2)\n GroupKey: (a = :bar, b = 1)\n GroupKey: (a = :baz, b = 2)\n GroupKey: (a = :foo, b = 1)\n GroupKey: (a = :bar, b = 2)\n GroupKey: (a = :baz, b = 1)\n\nGroupKey objects behave similarly to NamedTuples:\n\njulia> k = keys(gd)[1]\nGroupKey: (a = :foo, b = 2)\n\njulia> keys(k)\n(:a, :b)\n\njulia> values(k)  # Same as Tuple(k)\n(:foo, 2)\n\njulia> NamedTuple(k)\n(a = :foo, b = 2)\n\njulia> k.a\n:foo\n\njulia> k[:a]\n:foo\n\njulia> k[1]\n:foo\n\nKeys can be used as indices to retrieve the corresponding group from their GroupedDataFrame:\n\njulia> gd[k]\n2×3 SubDataFrame\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ foo    │ 2     │ 1     │\n│ 2   │ foo    │ 2     │ 7     │\n\njulia> gd[keys(gd)[1]] == gd[1]\ntrue\n\n\n\n\n\nkeys(dfc::DataFrameColumns)\n\nGet a vector of column names of dfc as Symbols.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.get","page":"Functions","title":"Base.get","text":"get(gd::GroupedDataFrame, key, default)\n\nGet a group based on the values of the grouping columns.\n\nkey may be a NamedTuple or Tuple of grouping column values (in the same order as the cols argument to groupby).\n\nExamples\n\njulia> df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[2]),\n                      b = repeat([2, 1], outer=[3]),\n                      c = 1:6);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 3 groups based on key: a\nFirst Group (2 rows): a = :foo\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ foo    │ 2     │ 1     │\n│ 2   │ foo    │ 1     │ 4     │\n⋮\nLast Group (2 rows): a = :baz\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ baz    │ 2     │ 3     │\n│ 2   │ baz    │ 1     │ 6     │\n\njulia> get(gd, (a=:bar,), nothing)\n2×3 SubDataFrame\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ bar    │ 1     │ 2     │\n│ 2   │ bar    │ 2     │ 5     │\n\njulia> get(gd, (:baz,), nothing)\n2×3 SubDataFrame\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ baz    │ 2     │ 3     │\n│ 2   │ baz    │ 1     │ 6     │\n\njulia> get(gd, (:qux,), nothing)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.map","page":"Functions","title":"Base.map","text":"map(fun::Union{Function, Type}, gd::GroupedDataFrame)\nmap(pair::Pair, gd::GroupedDataFrame)\n\nApply fun or pair to each group of rows and return a GroupedDataFrame.\n\nIf fun is specified it must be a function, and it is passed a SubDataFrame view for each group and can return any return value defined below. Note that this form is slower than pair due to type instability.\n\nIf pair is passed then it must follow the rules specified for transformations in select and have the form source_cols => fun, source_cols => fun => target_col, or source_col => target_col. Function defined by fun is passed SubArray views as positional arguments for each column specified to be selected and can return any return value defined below, or a NamedTuple containing these SubArrays if source_cols is an AsTable selector. As a special case nrow or nrow => target_col can be passed without specifying input columns to efficiently calculate number of rows in each group. If nrow is passed the resulting column name is :nrow.\n\nfun can return a single value, a row, a vector, or multiple rows. The type of the returned value determines the shape of the resulting DataFrame. There are four kind of return values allowed:\n\nA single value gives a DataFrame with a single additional column and one row per group.\nA named tuple of single values or a DataFrameRow gives a DataFrame with one additional column for each field and one row per group (returning a named tuple will be faster). It is not allowed to mix single values and vectors if a named tuple is returned.\nA vector gives a DataFrame with a single additional column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a DataFrame with the same additional columns and as many rows for each group as the rows returned for that group (returning a named tuple is the fastest option). Returning a table with zero columns is allowed, whatever the number of columns returned for other groups.\n\nfun must always return the same kind of object (out of four kinds defined above) for all groups, and with the same column names.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the Pair syntax (e.g. :col => sum). When computing the sum or mean over floating point columns, results will be less accurate than the standard sum function (which uses pairwise summation). Use col => x -> sum(x) to avoid the optimized method and use the slower, more accurate one.\n\nColumn names are automatically generated when necessary using the rules defined in select if the Pair syntax is used and fun returns a single value or a vector (e.g. for :col => sum the column name is col_sum); otherwise (if fun is a function or a return value is an AbstractMatrix) columns are named x1, x2 and so on.\n\nSee also combine that returns a DataFrame rather than a GroupedDataFrame.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> map(sdf -> sum(sdf.c), gd)\nGroupedDataFrame{DataFrame} with 4 groups based on key: :a\nFirst Group: 1 row\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n⋮\nLast Group: 1 row\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 12    │\n\njulia> map(:c => sum, gd)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (1 row): a = 1\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n⋮\nLast Group (1 row): a = 4\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 12    │\n\njulia> map(nrow, gd)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (1 row): a = 1\n│ Row │ a     │ nrow  │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 2     │\n⋮\nLast Group (1 row): a = 4\n│ Row │ a     │ nrow  │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 2     │\n\njulia> map(AsTable(valuecols(gd)) => sum, gd)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (2 rows): a = 1\n│ Row │ a     │ b_c_sum │\n│     │ Int64 │ Int64   │\n├─────┼───────┼─────────┤\n│ 1   │ 1     │ 3       │\n│ 2   │ 1     │ 7       │\n⋮\nLast Group (2 rows): a = 4\n│ Row │ a     │ b_c_sum │\n│     │ Int64 │ Int64   │\n├─────┼───────┼─────────┤\n│ 1   │ 4     │ 5       │\n│ 2   │ 4     │ 9       │\n\nSee by for more examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.stack","page":"Functions","title":"DataFrames.stack","text":"stack(df::AbstractDataFrame, [measure_vars], [id_vars];\n      variable_name=:variable, value_name=:value,\n      view::Bool=false, variable_eltype::Type=CategoricalValue{String})\n\nStack a data frame df, i.e. convert it from wide to long format.\n\nReturn the long-format DataFrame with: columns for each of the id_vars, column variable_name (:value by default) holding the values of the stacked columns (measure_vars), and column variable_name (:variable by default) a vector holding the name of the corresponding measure_vars variable.\n\nIf view=true then return a stacked view of a data frame (long format). The result is a view because the columns are special AbstractVectors that return views into the original data frame.\n\nArguments\n\ndf : the AbstractDataFrame to be stacked\nmeasure_vars : the columns to be stacked (the measurement variables), as a column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). If neither measure_vars or id_vars are given, measure_vars defaults to all floating point columns.\nid_vars : the identifier columns that are repeated during stacking, as a column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers). Defaults to all variables that are not measure_vars\nvariable_name : the name (Symbol or string) of the new stacked column that shall hold the names of each of measure_vars\nvalue_name : the name (Symbol or string) of the new stacked column containing the values from each of measure_vars\nview : whether the stacked data frame should be a view rather than contain freshly allocated vectors.\nvariable_eltype : determines the element type of column variable_name. By default a categorical vector of strings is created. If variable_eltype=Symbol it is a vector of Symbol, and if variable_eltype=String a vector of String is produced.\n\nExamples\n\nd1 = DataFrame(a = repeat([1:3;], inner = [4]),\n               b = repeat([1:4;], inner = [3]),\n               c = randn(12),\n               d = randn(12),\n               e = map(string, 'a':'l'))\n\nd1s = stack(d1, [:c, :d])\nd1s2 = stack(d1, [:c, :d], [:a])\nd1m = stack(d1, Not([:a, :b, :e]))\nd1s_name = stack(d1, Not([:a, :b, :e]), variable_name=:somemeasure)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.unstack","page":"Functions","title":"DataFrames.unstack","text":"unstack(df::AbstractDataFrame, rowkeys, colkey, value; renamecols::Function=identity)\nunstack(df::AbstractDataFrame, colkey, value; renamecols::Function=identity)\nunstack(df::AbstractDataFrame; renamecols::Function=identity)\n\nUnstack data frame df, i.e. convert it from long to wide format.\n\nIf colkey contains missing values then they will be skipped and a warning will be printed.\n\nIf combination of rowkeys and colkey contains duplicate entries then last value will be retained and a warning will be printed.\n\nArguments\n\ndf : the AbstractDataFrame to be unstacked\nrowkeys : the columns with a unique key for each row, if not given, find a key by grouping on anything not a colkey or value. Can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\ncolkey : the column (Symbol, string or integer) holding the column names in wide format, defaults to :variable\nvalue : the value column (Symbol, string or integer), defaults to :value\nrenamecols : a function called on each unique value in colkey which must                return the name of the column to be created (typically as a string                or a Symbol). Duplicate names are not allowed.\n\nExamples\n\nwide = DataFrame(id = 1:12,\n                 a  = repeat([1:3;], inner = [4]),\n                 b  = repeat([1:4;], inner = [3]),\n                 c  = randn(12),\n                 d  = randn(12))\n\nlong = stack(wide)\nwide0 = unstack(long)\nwide1 = unstack(long, :variable, :value)\nwide2 = unstack(long, :id, :variable, :value)\nwide3 = unstack(long, [:id, :a], :variable, :value)\nwide4 = unstack(long, :id, :variable, :value, renamecols=x->Symbol(:_, x))\n\nNote that there are some differences between the widened results above.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Basics-1","page":"Functions","title":"Basics","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"allowmissing\nallowmissing!\nappend!\ncategorical\ncategorical!\ncompletecases\ncopy\nDataFrame!\ndelete!\ndescribe\ndisallowmissing\ndisallowmissing!\ndropmissing\ndropmissing!\neachcol\neachrow\nfilter\nfilter!\nflatten\nhcat\ninsertcols!\nlength\nmapcols\nnames\nncol\nndims\nnonunique\nnrow\norder\npush!\nrename\nrename!\nrepeat\nselect\nselect!\nshow\nsize\nsort\nsort!\ntransform\ntransform!\nunique!\nvcat","category":"page"},{"location":"lib/functions/#Missings.allowmissing","page":"Functions","title":"Missings.allowmissing","text":"allowmissing(df::AbstractDataFrame, cols=:)\n\nReturn a copy of data frame df with columns cols converted to element type Union{T, Missing} from T to allow support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nExamples\n\njulia> df = DataFrame(a=[1,2])\n2×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n\njulia> allowmissing(df)\n2×1 DataFrame\n│ Row │ a      │\n│     │ Int64? │\n├─────┼────────┤\n│ 1   │ 1      │\n│ 2   │ 2      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.allowmissing!","page":"Functions","title":"DataFrames.allowmissing!","text":"allowmissing!(df::DataFrame, cols=:)\n\nConvert columns cols of data frame df from element type T to Union{T, Missing} to support missing values.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.append!","page":"Functions","title":"Base.append!","text":"append!(df::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal,\n        promote::Bool=(cols in [:union, :subset]))\nappend!(df::DataFrame, table; cols::Symbol=:setequal,\n        promote::Bool=(cols in [:union, :subset]))\n\nAdd the rows of df2 to the end of df. If the second argument table is not an AbstractDataFrame then it is converted using DataFrame(table, copycols=false) before being appended.\n\nThe exact behavior of append! depends on the cols argument:\n\nIf cols == :setequal (this is the default) then df2 must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then df2 must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if df2 is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then df2 may contain more columns than df, but all column names that are present in df must be present in df2 and only these are used.\nIf cols == :subset then append! behaves like for :intersect but if some column is missing in df2 then a missing value is pushed to df.\nIf cols == :union then append! adds columns missing in df that are present in row, for columns present in df but missing in row a missing value is pushed.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nThe above rule has the following exceptions:\n\nIf df has no columns then copies of columns from df2 are added to it.\nIf df2 has no columns then calling append! leaves df unchanged.\n\nPlease note that append! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nSee also\n\nUse push! to add individual rows to a data frame and vcat to vertically concatenate data frames.\n\nExamples\n\njulia> df1 = DataFrame(A=1:3, B=1:3);\n\njulia> df2 = DataFrame(A=4.0:6.0, B=4:6);\n\njulia> append!(df1, df2);\n\njulia> df1\n6×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 4     │ 4     │\n│ 5   │ 5     │ 5     │\n│ 6   │ 6     │ 6     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#CategoricalArrays.categorical","page":"Functions","title":"CategoricalArrays.categorical","text":"categorical(df::AbstractDataFrame, cols=Union{AbstractString, Missing};\n            compress::Bool=false)\n\nReturn a copy of data frame df with columns cols converted to CategoricalVector.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers) or a Type.\n\nIf categorical is called with the cols argument being a Type, then all columns whose element type is a subtype of this type (by default Union{AbstractString, Missing}) will be converted to categorical.\n\nIf the compress keyword argument is set to true then the created CategoricalVectors will be compressed.\n\nAll created CategoricalVectors are unordered.\n\nExamples\n\njulia> df = DataFrame(a=[1,2], b=[\"a\",\"b\"])\n2×2 DataFrame\n│ Row │ a     │ b      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ a      │\n│ 2   │ 2     │ b      │\n\njulia> categorical(df)\n2×2 DataFrame\n│ Row │ a     │ b    │\n│     │ Int64 │ Cat… │\n├─────┼───────┼──────┤\n│ 1   │ 1     │ a    │\n│ 2   │ 2     │ b    │\n\njulia> categorical(df, :)\n2×2 DataFrame\n│ Row │ a    │ b    │\n│     │ Cat… │ Cat… │\n├─────┼──────┼──────┤\n│ 1   │ 1    │ a    │\n│ 2   │ 2    │ b    │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.categorical!","page":"Functions","title":"DataFrames.categorical!","text":"categorical!(df::DataFrame, cols=Union{AbstractString, Missing};\n             compress::Bool=false)\n\nChange columns selected by cols in data frame df to CategoricalVector.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers) or a Type.\n\nIf categorical! is called with the cols argument being a Type, then all columns whose element type is a subtype of this type (by default Union{AbstractString, Missing}) will be converted to categorical.\n\nIf the compress keyword argument is set to true then the created CategoricalVectors will be compressed.\n\nAll created CategoricalVectors are unordered.\n\nExamples\n\njulia> df = DataFrame(X=[\"a\", \"b\"], Y=[1, 2], Z=[\"p\", \"q\"])\n2×3 DataFrame\n│ Row │ X      │ Y     │ Z      │\n│     │ String │ Int64 │ String │\n├─────┼────────┼───────┼────────┤\n│ 1   │ a      │ 1     │ p      │\n│ 2   │ b      │ 2     │ q      │\n\njulia> categorical!(df)\n2×3 DataFrame\n│ Row │ X    │ Y     │ Z    │\n│     │ Cat… │ Int64 │ Cat… │\n├─────┼──────┼───────┼──────┤\n│ 1   │ a    │ 1     │ p    │\n│ 2   │ b    │ 2     │ q    │\n\njulia> eltype.(eachcol(df))\n3-element Array{DataType,1}:\n CategoricalValue{String,UInt32}\n Int64\n CategoricalValue{String,UInt32}\n\njulia> df = DataFrame(X=[\"a\", \"b\"], Y=[1, 2], Z=[\"p\", \"q\"])\n2×3 DataFrame\n│ Row │ X      │ Y     │ Z      │\n│     │ String │ Int64 │ String │\n├─────┼────────┼───────┼────────┤\n│ 1   │ a      │ 1     │ p      │\n│ 2   │ b      │ 2     │ q      │\n\njulia> categorical!(df, :Y, compress=true)\n2×3 DataFrame\n│ Row │ X      │ Y    │ Z      │\n│     │ String │ Cat… │ String │\n├─────┼────────┼──────┼────────┤\n│ 1   │ a      │ 1    │ p      │\n│ 2   │ b      │ 2    │ q      │\n\njulia> eltype.(eachcol(df))\n3-element Array{DataType,1}:\n String\n CategoricalValue{Int64,UInt8}\n String\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.completecases","page":"Functions","title":"DataFrames.completecases","text":"completecases(df::AbstractDataFrame, cols=:)\n\nReturn a Boolean vector with true entries indicating rows without missing values (complete cases) in data frame df.\n\nIf cols is provided, only missing values in the corresponding columns areconsidered. cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nSee also: dropmissing and dropmissing!. Use findall(completecases(df)) to get the indices of the rows.\n\nExamples\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ i     │ x       │ y       │\n│     │ Int64 │ Int64?  │ String? │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ missing │ missing │\n│ 2   │ 2     │ 4       │ missing │\n│ 3   │ 3     │ missing │ c       │\n│ 4   │ 4     │ 2       │ d       │\n│ 5   │ 5     │ 1       │ e       │\n\njulia> completecases(df)\n5-element BitArray{1}:\n false\n false\n false\n  true\n  true\n\njulia> completecases(df, :x)\n5-element BitArray{1}:\n false\n  true\n false\n  true\n  true\n\njulia> completecases(df, [:x, :y])\n5-element BitArray{1}:\n false\n false\n false\n  true\n  true\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.copy","page":"Functions","title":"Base.copy","text":"copy(df::DataFrame; copycols::Bool=true)\n\nCopy data frame df. If copycols=true (the default), return a new  DataFrame holding copies of column vectors in df. If copycols=false, return a new DataFrame sharing column vectors with df.\n\n\n\n\n\ncopy(dfr::DataFrameRow)\n\nConstruct a NamedTuple with the same contents as the DataFrameRow. This method returns a NamedTuple so that the returned object is not affected by changes to the parent data frame of which dfr is a view.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.DataFrame!","page":"Functions","title":"DataFrames.DataFrame!","text":"DataFrame!(args...; kwargs...)\n\nEquivalent to DataFrame(args...; copycols=false, kwargs...).\n\nIf kwargs contains the copycols keyword argument an error is thrown.\n\nExamples\n\njulia> df1 = DataFrame(a=1:3)\n3×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> df2 = DataFrame!(df1)\n\njulia> df1.a === df2.a\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.delete!","page":"Functions","title":"Base.delete!","text":"delete!(df::DataFrame, inds)\n\nDelete rows specified by inds from a DataFrame df in place and return it.\n\nInternally deleteat! is called for all columns so inds must be: a vector of sorted and unique integers, a boolean vector, an integer, or Not.\n\nExamples\n\njulia> d = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> delete!(d, 2)\n2×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 3     │ 6     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.describe","page":"Functions","title":"DataAPI.describe","text":"describe(df::AbstractDataFrame; cols=:)\ndescribe(df::AbstractDataFrame, stats::Union{Symbol, Pair}...; cols=:)\n\nReturn descriptive statistics for a data frame as a new DataFrame where each row represents a variable and each column a summary statistic.\n\nArguments\n\ndf : the AbstractDataFrame\nstats::Union{Symbol, Pair}... : the summary statistics to report. Arguments can be:\nA symbol from the list :mean, :std, :min, :q25, :median, :q75, :max, :eltype, :nunique, :first, :last, and :nmissing. The default statistics used are :mean, :min, :median, :max, :nunique, :nmissing, and :eltype.\n:all as the only Symbol argument to return all statistics.\nA name => function pair where name is a Symbol or string. This will create a column of summary statistics with the provided name.\ncols : a keyword argument allowing to select only a subset of columns from df to describe. Can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nDetails\n\nFor Real columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from Real, describe will attempt to calculate all statistics, using nothing as a fall-back in the case of an error.\n\nWhen stats contains :nunique, describe will report the number of unique values in a column. If a column's base type derives from Real, :nunique will return nothings.\n\nMissing values are filtered in the calculation of all statistics, however the column :nmissing will report the number of missing values of that variable. If the column does not allow missing values, nothing is returned. Consequently, nmissing = 0 indicates that the column allows missing values, but does not currently contain any.\n\nIf custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to skipmissing: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.\n\nExamples\n\njulia> df = DataFrame(i=1:10, x=0.1:0.1:1.0, y='a':'j')\n10×3 DataFrame\n│ Row │ i     │ x       │ y    │\n│     │ Int64 │ Float64 │ Char │\n├─────┼───────┼─────────┼──────┤\n│ 1   │ 1     │ 0.1     │ 'a'  │\n│ 2   │ 2     │ 0.2     │ 'b'  │\n│ 3   │ 3     │ 0.3     │ 'c'  │\n│ 4   │ 4     │ 0.4     │ 'd'  │\n│ 5   │ 5     │ 0.5     │ 'e'  │\n│ 6   │ 6     │ 0.6     │ 'f'  │\n│ 7   │ 7     │ 0.7     │ 'g'  │\n│ 8   │ 8     │ 0.8     │ 'h'  │\n│ 9   │ 9     │ 0.9     │ 'i'  │\n│ 10  │ 10    │ 1.0     │ 'j'  │\n\njulia> describe(df)\n3×8 DataFrame\n│ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │\n│     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │\n├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤\n│ 1   │ i        │ 5.5    │ 1   │ 5.5    │ 10  │         │          │ Int64    │\n│ 2   │ x        │ 0.55   │ 0.1 │ 0.55   │ 1.0 │         │          │ Float64  │\n│ 3   │ y        │        │ 'a' │        │ 'j' │ 10      │          │ Char     │\n\njulia> describe(df, :min, :max)\n3×3 DataFrame\n│ Row │ variable │ min │ max │\n│     │ Symbol   │ Any │ Any │\n├─────┼──────────┼─────┼─────┤\n│ 1   │ i        │ 1   │ 10  │\n│ 2   │ x        │ 0.1 │ 1.0 │\n│ 3   │ y        │ 'a' │ 'j' │\n\njulia> describe(df, :min, :sum => sum)\n3×3 DataFrame\n│ Row │ variable │ min │ sum │\n│     │ Symbol   │ Any │ Any │\n├─────┼──────────┼─────┼─────┤\n│ 1   │ i        │ 1   │ 55  │\n│ 2   │ x        │ 0.1 │ 5.5 │\n│ 3   │ y        │ 'a' │     │\n\njulia> describe(df, :min, :sum => sum, cols=:x)\n1×3 DataFrame\n│ Row │ variable │ min     │ sum     │\n│     │ Symbol   │ Float64 │ Float64 │\n├─────┼──────────┼─────────┼─────────┤\n│ 1   │ x        │ 0.1     │ 5.5     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Missings.disallowmissing","page":"Functions","title":"Missings.disallowmissing","text":"disallowmissing(df::AbstractDataFrame, cols=:; error::Bool=true)\n\nReturn a copy of data frame df with columns cols converted from element type Union{T, Missing} to T to drop support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\nExamples\n\njulia> df = DataFrame(a=Union{Int,Missing}[1,2])\n2×1 DataFrame\n│ Row │ a      │\n│     │ Int64? │\n├─────┼────────┤\n│ 1   │ 1      │\n│ 2   │ 2      │\n\njulia> disallowmissing(df)\n2×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n\njulia> df = DataFrame(a=[1,missing]) 2×2 DataFrame │ Row │ a       │ b      │ │     │ Int64?  │ Int64? │ ├─────┼─────────┼────────┤ │ 1   │ 1       │ 1      │ │ 2   │ missing │ 2      │\n\njulia> disallowmissing(df, error=false) 2×2 DataFrame │ Row │ a       │ b     │ │     │ Int64?  │ Int64 │ ├─────┼─────────┼───────┤ │ 1   │ 1       │ 1     │ │ 2   │ missing │ 2     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.disallowmissing!","page":"Functions","title":"DataFrames.disallowmissing!","text":"disallowmissing!(df::DataFrame, cols=:; error::Bool=true)\n\nConvert columns cols of data frame df from element type Union{T, Missing} to T to drop support for missing values.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing","page":"Functions","title":"DataFrames.dropmissing","text":"dropmissing(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)\n\nReturn a copy of data frame df excluding rows with missing values.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf disallowmissing is true (the default) then columns specified in cols will be converted so as not to allow for missing values using disallowmissing!.\n\nSee also: completecases and dropmissing!.\n\nExamples\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ i     │ x       │ y       │\n│     │ Int64 │ Int64?  │ String? │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ missing │ missing │\n│ 2   │ 2     │ 4       │ missing │\n│ 3   │ 3     │ missing │ c       │\n│ 4   │ 4     │ 2       │ d       │\n│ 5   │ 5     │ 1       │ e       │\n\njulia> dropmissing(df)\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\njulia> dropmissing(df, disallowmissing=false)\n2×3 DataFrame\n│ Row │ i     │ x      │ y       │\n│     │ Int64 │ Int64? │ String? │\n├─────┼───────┼────────┼─────────┤\n│ 1   │ 4     │ 2      │ d       │\n│ 2   │ 5     │ 1      │ e       │\n\njulia> dropmissing(df, :x)\n3×3 DataFrame\n│ Row │ i     │ x     │ y       │\n│     │ Int64 │ Int64 │ String? │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 2     │ 4     │ missing │\n│ 2   │ 4     │ 2     │ d       │\n│ 3   │ 5     │ 1     │ e       │\n\njulia> dropmissing(df, [:x, :y])\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing!","page":"Functions","title":"DataFrames.dropmissing!","text":"dropmissing!(df::AbstractDataFrame, cols=:; disallowmissing::Bool=true)\n\nRemove rows with missing values from data frame df and return it.\n\nIf cols is provided, only missing values in the corresponding columns are considered. cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf disallowmissing is true (the default) then the cols columns will get converted using disallowmissing!.\n\nSee also: dropmissing and completecases.\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ i     │ x       │ y       │\n│     │ Int64 │ Int64?  │ String? │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ missing │ missing │\n│ 2   │ 2     │ 4       │ missing │\n│ 3   │ 3     │ missing │ c       │\n│ 4   │ 4     │ 2       │ d       │\n│ 5   │ 5     │ 1       │ e       │\n\njulia> dropmissing!(copy(df))\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\njulia> dropmissing!(copy(df), disallowmissing=false)\n2×3 DataFrame\n│ Row │ i     │ x      │ y       │\n│     │ Int64 │ Int64? │ String? │\n├─────┼───────┼────────┼─────────┤\n│ 1   │ 4     │ 2      │ d       │\n│ 2   │ 5     │ 1      │ e       │\n\njulia> dropmissing!(copy(df), :x)\n3×3 DataFrame\n│ Row │ i     │ x     │ y       │\n│     │ Int64 │ Int64 │ String? │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 2     │ 4     │ missing │\n│ 2   │ 4     │ 2     │ d       │\n│ 3   │ 5     │ 1     │ e       │\n\njulia> dropmissing!(df3, [:x, :y])\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Compat.eachcol","page":"Functions","title":"Compat.eachcol","text":"eachcol(df::AbstractDataFrame)\n\nReturn a DataFrameColumns that is an AbstractVector that allows iterating an AbstractDataFrame column by column. Additionally it is allowed to index DataFrameColumns using column names.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 11    │\n│ 2   │ 2     │ 12    │\n│ 3   │ 3     │ 13    │\n│ 4   │ 4     │ 14    │\n\njulia> collect(eachcol(df))\n2-element Array{AbstractArray{T,1} where T,1}:\n [1, 2, 3, 4]\n [11, 12, 13, 14]\n\njulia> map(eachcol(df)) do col\n           maximum(col) - minimum(col)\n       end\n2-element Array{Int64,1}:\n 3\n 3\n\njulia> sum.(eachcol(df))\n2-element Array{Int64,1}:\n 10\n 50\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Compat.eachrow","page":"Functions","title":"Compat.eachrow","text":"eachrow(df::AbstractDataFrame)\n\nReturn a DataFrameRows that iterates a data frame row by row, with each row represented as a DataFrameRow.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 11    │\n│ 2   │ 2     │ 12    │\n│ 3   │ 3     │ 13    │\n│ 4   │ 4     │ 14    │\n\njulia> eachrow(df)\n4-element DataFrameRows:\n DataFrameRow (row 1)\nx  1\ny  11\n DataFrameRow (row 2)\nx  2\ny  12\n DataFrameRow (row 3)\nx  3\ny  13\n DataFrameRow (row 4)\nx  4\ny  14\n\njulia> copy.(eachrow(df))\n4-element Array{NamedTuple{(:x, :y),Tuple{Int64,Int64}},1}:\n (x = 1, y = 11)\n (x = 2, y = 12)\n (x = 3, y = 13)\n (x = 4, y = 14)\n\njulia> eachrow(view(df, [4,3], [2,1]))\n2-element DataFrameRows:\n DataFrameRow (row 4)\ny  14\nx  4\n DataFrameRow (row 3)\ny  13\nx  3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter","page":"Functions","title":"Base.filter","text":"filter(function, df::AbstractDataFrame)\nfilter(cols => function, df::AbstractDataFrame)\n\nReturn a copy of data frame df containing only rows for which function returns true.\n\nIf cols is not specified then the function is passed DataFrameRows.\n\nIf cols is specified then the function is passed elements of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nPassing cols leads to a more efficient execution of the operation for large data frames.\n\nSee also: filter!\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> filter(row -> row.x > 1, df)\n2×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n\njulia> filter(:x => x -> x > 1, df)\n2×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n\njulia> filter([:x, :y] => (x, y) -> x == 1 || y == \"b\", df)\n3×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 1     │ b      │\n\njulia> filter(AsTable(:) => nt -> nt.x == 1 || nt.y == \"b\", df)\n3×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 1     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter!","page":"Functions","title":"Base.filter!","text":"filter!(function, df::AbstractDataFrame)\nfilter!(cols => function, df::AbstractDataFrame)\n\nRemove rows from data frame df for which function returns false.\n\nIf cols is not specified then the function is passed DataFrameRows. If cols is specified then the function is passed elements of the corresponding columns as separate positional arguments, unless cols is an AsTable selector, in which case a NamedTuple of these arguments is passed. cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers), and column duplicates are allowed if a vector of Symbols, strings, or integers is passed.\n\nPassing cols leads to a more efficient execution of the operation for large data frames.\n\nSee also: filter\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> filter!(row -> row.x > 1, df);\n\njulia> df\n2×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n\njulia> filter!(:x => x -> x == 3, df);\n\njulia> df\n1×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"]);\n\njulia> filter!([:x, :y] => (x, y) -> x == 1 || y == \"b\", df);\n\njulia> df\n3×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 1     │ b      │\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"]);\n\njulia> filter!(AsTable(:) => nt -> nt.x == 1 || nt.y == \"b\", df)\n3×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 1     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.flatten","page":"Functions","title":"DataFrames.flatten","text":"flatten(df::AbstractDataFrame, cols)\n\nWhen columns cols of data frame df have iterable elements that define length (for example a Vector of Vectors), return a DataFrame where each element of each col in cols is flattened, meaning the column corresponding to col becomes a longer vector where the original entries are concatenated. Elements of row i of df in columns other than cols will be repeated according to the length of df[i, col]. These lengths must therefore be the same for each col in cols, or else an error is raised. Note that these elements are not copied, and thus if they are mutable changing them in the returned DataFrame will affect df.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nExamples\n\njulia> df1 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7, 8]])\n2×3 DataFrame\n│ Row │ a     │ b      │ c      │\n│     │ Int64 │ Array… │ Array… │\n├─────┼───────┼────────┼────────┤\n│ 1   │ 1     │ [1, 2] │ [5, 6] │\n│ 2   │ 2     │ [3, 4] │ [7, 8] │\n\njulia> flatten(df1, :b)\n4×3 DataFrame\n│ Row │ a     │ b     │ c      │\n│     │ Int64 │ Int64 │ Array… │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 1     │ 1     │ [5, 6] │\n│ 2   │ 1     │ 2     │ [5, 6] │\n│ 3   │ 2     │ 3     │ [7, 8] │\n│ 4   │ 2     │ 4     │ [7, 8] │\n\njulia> flatten(df1, [:b, :c])\n4×3 DataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 5     │\n│ 2   │ 1     │ 2     │ 6     │\n│ 3   │ 2     │ 3     │ 7     │\n│ 4   │ 2     │ 4     │ 8     │\n\njulia> df2 = DataFrame(a = [1, 2], b = [(\"p\", \"q\"), (\"r\", \"s\")])\n2×2 DataFrame\n│ Row │ a     │ b          │\n│     │ Int64 │ Tuple…     │\n├─────┼───────┼────────────┤\n│ 1   │ 1     │ (\"p\", \"q\") │\n│ 2   │ 2     │ (\"r\", \"s\") │\n\njulia> flatten(df2, :b)\n4×2 DataFrame\n│ Row │ a     │ b      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ p      │\n│ 2   │ 1     │ q      │\n│ 3   │ 2     │ r      │\n│ 4   │ 2     │ s      │\n\njulia> df3 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]], c = [[5, 6], [7]])\n2×3 DataFrame\n│ Row │ a     │ b      │ c      │\n│     │ Int64 │ Array… │ Array… │\n├─────┼───────┼────────┼────────┤\n│ 1   │ 1     │ [1, 2] │ [5, 6] │\n│ 2   │ 2     │ [3, 4] │ [7]    │\n\njulia> flatten(df3, [:b, :c])\nERROR: ArgumentError: Lengths of iterables stored in columns :b and :c\nare not the same in row 2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.hcat","page":"Functions","title":"Base.hcat","text":"hcat(df::AbstractDataFrame...;\n     makeunique::Bool=false, copycols::Bool=true)\nhcat(df::AbstractDataFrame..., vs::AbstractVector;\n     makeunique::Bool=false, copycols::Bool=true)\nhcat(vs::AbstractVector, df::AbstractDataFrame;\n     makeunique::Bool=false, copycols::Bool=true)\n\nHorizontally concatenate AbstractDataFrames and optionally AbstractVectors.\n\nIf AbstractVector is passed then a column name for it is automatically generated as :x1 by default.\n\nIf makeunique=false (the default) column names of passed objects must be unique. If makeunique=true then duplicate column names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf copycols=true (the default) then the DataFrame returned by hcat will contain copied columns from the source data frames. If copycols=false then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned DataFrame might lead to the corruption of the other object.\n\nExample\n\njulia [DataFrame(A=1:3) DataFrame(B=1:3)]\n3×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n\njulia> df1 = DataFrame(A=1:3, B=1:3);\n\njulia> df2 = DataFrame(A=4:6, B=4:6);\n\njulia> df3 = hcat(df1, df2, makeunique=true)\n3×4 DataFrame\n│ Row │ A     │ B     │ A_1   │ B_1   │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 4     │ 4     │\n│ 2   │ 2     │ 2     │ 5     │ 5     │\n│ 3   │ 3     │ 3     │ 6     │ 6     │\n\njulia> df3.A === df1.A\nfalse\n\njulia> df3 = hcat(df1, df2, makeunique=true, copycols=false);\n\njulia> df3.A === df1.A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.insertcols!","page":"Functions","title":"DataFrames.insertcols!","text":"insertcols!(df::DataFrame, [ind::Int], (name=>col)::Pair...;\n            makeunique::Bool=false, copycols::Bool=true)\n\nInsert a column into a data frame in place. Return the updated DataFrame. If ind is omitted it is set to ncol(df)+1 (the column is inserted as the last column).\n\nArguments\n\ndf : the DataFrame to which we want to add columns\nind : a position at which we want to insert a column\nname : the name of the new column\ncol : an AbstractVector giving the contents of the new column or a value of any type other than AbstractArray which will be repeated to fill a new vector; As a particular rule a values stored in a Ref or a 0-dimensional AbstractArray are unwrapped and treated in the same way.\nmakeunique : Defines what to do if name already exists in df; if it is false an error will be thrown; if it is true a new unique name will be generated by adding a suffix\ncopycols : whether vectors passed as columns should be copied\n\nIf col is an AbstractRange then the result of collect(col) is inserted.\n\nExamples\n\njulia> d = DataFrame(a=1:3)\n3×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> insertcols!(d, 1, :b => 'a':'c')\n3×2 DataFrame\n│ Row │ b    │ a     │\n│     │ Char │ Int64 │\n├─────┼──────┼───────┤\n│ 1   │ 'a'  │ 1     │\n│ 2   │ 'b'  │ 2     │\n│ 3   │ 'c'  │ 3     │\n\njulia> insertcols!(d, 2, :c => 2:4, :c => 3:5, makeunique=true)\n3×4 DataFrame\n│ Row │ b    │ c     │ c_1   │ a     │\n│     │ Char │ Int64 │ Int64 │ Int64 │\n├─────┼──────┼───────┼───────┼───────┤\n│ 1   │ 'a'  │ 2     │ 3     │ 1     │\n│ 2   │ 'b'  │ 3     │ 4     │ 2     │\n│ 3   │ 'c'  │ 4     │ 5     │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.length","page":"Functions","title":"Base.length","text":"length(dfr::DataFrameRow)\n\nReturn the number of elements of dfr.\n\nSee also: size\n\nExamples\n\njulia> dfr = DataFrame(a=1:3, b='a':'c')[1, :];\n\njulia> length(dfr)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.mapcols","page":"Functions","title":"DataFrames.mapcols","text":"mapcols(f::Union{Function,Type}, df::AbstractDataFrame)\n\nReturn a DataFrame where each column of df is transformed using function f. f must return AbstractVector objects all with the same length or scalars.\n\nNote that mapcols guarantees not to reuse the columns from df in the returned DataFrame. If f returns its argument then it gets copied before being stored.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 11    │\n│ 2   │ 2     │ 12    │\n│ 3   │ 3     │ 13    │\n│ 4   │ 4     │ 14    │\n\njulia> mapcols(x -> x.^2, df)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 121   │\n│ 2   │ 4     │ 144   │\n│ 3   │ 9     │ 169   │\n│ 4   │ 16    │ 196   │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.names","page":"Functions","title":"Base.names","text":"names(df::AbstractDataFrame)\nnames(df::AbstractDataFrame, cols)\n\nReturn a freshly allocated Vector{String} of names of columns contained in df.\n\nIf cols is passed then restrict returned column names to those matching the selector (this is useful in particular with regular expressions, Not, and Between). cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nSee also propertynames which returns a Vector{Symbol}.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.ncol","page":"Functions","title":"DataFrames.ncol","text":"nrow(df::AbstractDataFrame)\nncol(df::AbstractDataFrame)\n\nReturn the number of rows or columns in an AbstractDataFrame df.\n\nSee also size.\n\nExamples\n\njulia> df = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10));\n\njulia> size(df)\n(10, 3)\n\njulia> nrow(df)\n10\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.ndims","page":"Functions","title":"Base.ndims","text":"ndims(::AbstractDataFrame)\nndims(::Type{<:AbstractDataFrame})\n\nReturn the number of dimensions of a data frame, which is always 2.\n\n\n\n\n\nndims(::DataFrameRow)\nndims(::Type{<:DataFrameRow})\n\nReturn the number of dimensions of a data frame row, which is always 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nonunique","page":"Functions","title":"DataFrames.nonunique","text":"nonunique(df::AbstractDataFrame)\nnonunique(df::AbstractDataFrame, cols)\n\nReturn a Vector{Bool} in which true entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to isequal).\n\nSee also unique and unique!.\n\nArguments\n\ndf : AbstractDataFrame\ncols : a selector specifying the column(s) to compare. Can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nExamples\n\ndf = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10))\ndf = vcat(df, df)\nnonunique(df)\nnonunique(df, 1)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nrow","page":"Functions","title":"DataFrames.nrow","text":"nrow(df::AbstractDataFrame)\nncol(df::AbstractDataFrame)\n\nReturn the number of rows or columns in an AbstractDataFrame df.\n\nSee also size.\n\nExamples\n\njulia> df = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10));\n\njulia> size(df)\n(10, 3)\n\njulia> nrow(df)\n10\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.order","page":"Functions","title":"DataFrames.order","text":"order(col::ColumnIndex; kwargs...)\n\nSpecify sorting order for a column col in a data frame. kwargs can be lt, by, rev, and order with values following the rules defined in sort!.\n\nSee also: sort!, sort\n\nExamples\n\njulia> df = DataFrame(x = [-3, -1, 0, 2, 4], y = 1:5)\n5×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ -3    │ 1     │\n│ 2   │ -1    │ 2     │\n│ 3   │ 0     │ 3     │\n│ 4   │ 2     │ 4     │\n│ 5   │ 4     │ 5     │\n\njulia> sort(df, order(:x, rev=true))\n5×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 5     │\n│ 2   │ 2     │ 4     │\n│ 3   │ 0     │ 3     │\n│ 4   │ -1    │ 2     │\n│ 5   │ -3    │ 1     │\n\njulia> sort(df, order(:x, by=abs))\n5×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 0     │ 3     │\n│ 2   │ -1    │ 2     │\n│ 3   │ 2     │ 4     │\n│ 4   │ -3    │ 1     │\n│ 5   │ 4     │ 5     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.push!","page":"Functions","title":"Base.push!","text":"push!(df::DataFrame, row::Union{Tuple, AbstractArray}; promote::Bool=false)\npush!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};\n      cols::Symbol=:setequal, promote::Bool=(cols in [:union, :subset]))\n\nAdd in-place one row at the end of df taking the values from row.\n\nColumn types of df are preserved, and new values are converted if necessary. An error is thrown if conversion fails.\n\nIf row is neither a DataFrameRow, NamedTuple nor AbstractDict then it must be a Tuple or an AbstractArray and columns are matched by order of appearance. In this case row must contain the same number of elements as the number of columns in df.\n\nIf row is a DataFrameRow, NamedTuple or AbstractDict then values in row are matched to columns in df based on names. The exact behavior depends on the cols argument value in the following way:\n\nIf cols == :setequal (this is the default) then row must contain exactly the same columns as df (but possibly in a different order).\nIf cols == :orderequal then row must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches propertynames(df) to allow for support of ordered dicts; however, if row is a Dict an error is thrown as it is an unordered collection).\nIf cols == :intersect then row may contain more columns than df, but all column names that are present in df must be present in row and only they are used to populate a new row in df.\nIf cols == :subset then push! behaves like for :intersect but if some column is missing in row then a missing value is pushed to df.\nIf cols == :union then columns missing in df that are present in row are added to df (using missing for existing rows) and a missing value is pushed to columns missing in row that are present in df.\n\nIf promote=true and element type of a column present in df does not allow the type of a pushed argument then a new column with a promoted element type allowing it is freshly allocated and stored in df. If promote=false an error is thrown.\n\nAs a special case, if df has no columns and row is a NamedTuple or DataFrameRow, columns are created for all values in row, using their names and order.\n\nPlease note that push! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nExamples\n\njulia> df = DataFrame(A=1:3, B=1:3);\n\njulia> push!(df, (true, false))\n4×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n\njulia> push!(df, df[1, :])\n5×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n│ 5   │ 1     │ 1     │\n\njulia> push!(df, (C=\"something\", A=true, B=false), cols=:intersect)\n6×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n│ 5   │ 1     │ 1     │\n│ 6   │ 1     │ 0     │\n\njulia> push!(df, Dict(:A=>1.0, :C=>1.0), cols=:union)\n7×3 DataFrame\n│ Row │ A       │ B       │ C        │\n│     │ Float64 │ Int64?  │ Float64? │\n├─────┼─────────┼─────────┼──────────┤\n│ 1   │ 1.0     │ 1       │ missing  │\n│ 2   │ 2.0     │ 2       │ missing  │\n│ 3   │ 3.0     │ 3       │ missing  │\n│ 4   │ 1.0     │ 0       │ missing  │\n│ 5   │ 1.0     │ 1       │ missing  │\n│ 6   │ 1.0     │ 0       │ missing  │\n│ 7   │ 1.0     │ missing │ 1.0      │\n\njulia> push!(df, NamedTuple(), cols=:subset)\n8×3 DataFrame\n│ Row │ A        │ B       │ C        │\n│     │ Float64? │ Int64?  │ Float64? │\n├─────┼──────────┼─────────┼──────────┤\n│ 1   │ 1.0      │ 1       │ missing  │\n│ 2   │ 2.0      │ 2       │ missing  │\n│ 3   │ 3.0      │ 3       │ missing  │\n│ 4   │ 1.0      │ 0       │ missing  │\n│ 5   │ 1.0      │ 1       │ missing  │\n│ 6   │ 1.0      │ 0       │ missing  │\n│ 7   │ 1.0      │ missing │ 1.0      │\n│ 8   │ missing  │ missing │ missing  │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename","page":"Functions","title":"DataFrames.rename","text":"rename(df::AbstractDataFrame, vals::AbstractVector{Symbol};\n       makeunique::Bool=false)\nrename(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString};\n       makeunique::Bool=false)\nrename(df::AbstractDataFrame, (from => to)::Pair...)\nrename(df::AbstractDataFrame, d::AbstractDict)\nrename(df::AbstractDataFrame, d::AbstractVector{<:Pair})\nrename(f::Function, df::AbstractDataFrame)\n\nCreate a new data frame that is a copy of df with changed column names. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column takes the old name as a String and returns the new name that gets converted to a Symbol\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nSee also: rename!\n\nExamples\n\njulia> df = DataFrame(i = 1, x = 2, y = 3)\n1×3 DataFrame\n│ Row │ i     │ x     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, :i => :A, :x => :X)\n1×3 DataFrame\n│ Row │ A     │ X     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, :x => :y, :y => :x)\n1×3 DataFrame\n│ Row │ i     │ y     │ x     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, [1 => :A, 2 => :X])\n1×3 DataFrame\n│ Row │ A     │ X     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, Dict(\"i\" => \"A\", \"x\" => \"X\"))\n1×3 DataFrame\n│ Row │ A     │ X     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(uppercase, df)\n1×3 DataFrame\n│ Row │ I     │ X     │ Y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename!","page":"Functions","title":"DataFrames.rename!","text":"rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol};\n        makeunique::Bool=false)\nrename!(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString};\n        makeunique::Bool=false)\nrename!(df::AbstractDataFrame, (from => to)::Pair...)\nrename!(df::AbstractDataFrame, d::AbstractDict)\nrename!(df::AbstractDataFrame, d::AbstractVector{<:Pair})\nrename!(f::Function, df::AbstractDataFrame)\n\nRename columns of df in-place. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column takes the old name as a String and returns the new name that gets converted to a Symbol\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename! (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nSee also: rename\n\nExamples\n\njulia> df = DataFrame(i = 1, x = 2, y = 3)\n1×3 DataFrame\n│ Row │ i     │ x     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df, Dict(:i => \"A\", :x => \"X\"))\n1×3 DataFrame\n│ Row │ A     │ X     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df, [:a, :b, :c])\n1×3 DataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df, [:a, :b, :a])\nERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make\nthem unique using a suffix automatically.\n\njulia> rename!(df, [:a, :b, :a], makeunique=true)\n1×3 DataFrame\n│ Row │ a     │ b     │ a_1   │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(uppercase, df)\n1×3 DataFrame\n│ Row │ A     │ B     │ A_1   │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.repeat","page":"Functions","title":"Base.repeat","text":"repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)\n\nConstruct a data frame by repeating rows in df. inner specifies how many times each row is repeated, and outer specifies how many times the full set of rows is repeated.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 4     │\n\njulia> repeat(df, inner = 2, outer = 3)\n12×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 1     │ 3     │\n│ 3   │ 2     │ 4     │\n│ 4   │ 2     │ 4     │\n│ 5   │ 1     │ 3     │\n│ 6   │ 1     │ 3     │\n│ 7   │ 2     │ 4     │\n│ 8   │ 2     │ 4     │\n│ 9   │ 1     │ 3     │\n│ 10  │ 1     │ 3     │\n│ 11  │ 2     │ 4     │\n│ 12  │ 2     │ 4     │\n\n\n\n\n\nrepeat(df::AbstractDataFrame, count::Integer)\n\nConstruct a data frame by repeating each row in df the number of times specified by count.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 4     │\n\njulia> repeat(df, 2)\n4×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 4     │\n│ 3   │ 1     │ 3     │\n│ 4   │ 2     │ 4     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select","page":"Functions","title":"DataFrames.select","text":"select(df::AbstractDataFrame, args...; copycols::Bool=true)\n\nCreate a new data frame that contains columns from df specified by args and return it.\n\nIf df is a DataFrame or copycols=true then column renaming and transformations are supported.\n\nArguments passed as args... can be:\n\nAny index that is allowed for column indexing (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\nColumn transformation operations using the Pair notation that is described below and vectors of such pairs.\n\nColumns can be renamed using the old_column => new_column_name syntax, and transformed using the old_column => fun => new_column_name syntax. new_column_name must be a Symbol or a string, and fun a function or a type. If old_column is a Symbol, a string, or an integer then fun is applied to the corresponding column vector. Otherwise old_column can be any column indexing syntax, in which case fun will be passed the column vectors specified by old_column as separate arguments. The only exception is when old_column is an AsTable type wrapping a selector, in which case fun is passed a NamedTuple containing the selected columns.\n\nIf fun returns a value of type other than AbstractVector then it will be broadcasted into a vector matching the target number of rows in the data frame, unless its type is one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix, in which case an error is thrown as currently these return types are not allowed. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then broadcasted.\n\nTo apply fun to each row instead of whole columns, it can be wrapped in a ByRow struct. In this case if old_column is a Symbol, a string, or an integer then fun is applied to each element (row) of old_column using broadcasting. Otherwise old_column can be any column indexing syntax, in which case fun will be passed one argument for each of the columns specified by old_column. If ByRow is used it is not allowed for old_column to select an empty set of columns nor for fun to return a NamedTuple or a DataFrameRow.\n\nColumn transformation can also be specified using the short old_column => fun form. In this case, new_column_name is automatically generated as $(old_column)_$(fun). Up to three column names are used for multiple input columns and they are joined using _; if more than three columns are passed then the name consists of the first two names and etc suffix then, e.g. [:a,:b,:c,:d] => fun produces the new column name :a_b_etc_fun.\n\nColumn renaming and transformation operations can be passed wrapped in vectors (this is useful when combined with broadcasting).\n\nAs a special rule passing nrow without specifying old_column creates a column named :nrow containing a number of rows in a source data frame, and passing nrow => new_column_name stores the number of rows in source data frame in new_column_name column.\n\nIf a collection of column names is passed to select! or select then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nIf df is a DataFrame a new DataFrame is returned. If copycols=false, then the returned DataFrame shares column vectors with df where possible. If copycols=true (the default), then the returned DataFrame will not share columns with df. The only exception for this rule is the old_column => fun => new_column transformation when fun returns a vector that is not allocated by fun but is neither a SubArray nor one of the input vectors. In such a case a new DataFrame might contain aliases. Such a situation can only happen with transformations which returns vectors other than their inputs, e.g. with select(df, :a => (x -> c) => :c1, :b => (x -> c) => :c2)  when c is a vector object or with select(df, :a => (x -> df.c) => :c2).\n\nIf df is a SubDataFrame and copycols=true then a DataFrame is returned and the same copying rules apply as for a DataFrame input: this means in particular that selected columns will be copied. If copycols=false, a SubDataFrame is returned without copying columns.\n\nNote that including the same column several times in the data frame via renaming or transformations that return the same object when copycols=false will create column aliases. An example of such a situation is select(df, :a, :a => :b, :a => identity => :c, copycols=false).\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> select(df, :b)\n3×1 DataFrame\n│ Row │ b     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 4     │\n│ 2   │ 5     │\n│ 3   │ 6     │\n\njulia> select(df, Not(:b)) # drop column :b from df\n3×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> select(df, :a => :c, :b)\n3×2 DataFrame\n│ Row │ c     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> select(df, :a => ByRow(sin) => :c, :b)\n3×2 DataFrame\n│ Row │ c        │ b     │\n│     │ Float64  │ Int64 │\n├─────┼──────────┼───────┤\n│ 1   │ 0.841471 │ 4     │\n│ 2   │ 0.909297 │ 5     │\n│ 3   │ 0.14112  │ 6     │\n\njulia> select(df, :, [:a, :b] => (a,b) -> a .+ b .- sum(b)/length(b))\n3×3 DataFrame\n│ Row │ a     │ b     │ a_b_function │\n│     │ Int64 │ Int64 │ Float64      │\n├─────┼───────┼───────┼──────────────┤\n│ 1   │ 1     │ 4     │ 0.0          │\n│ 2   │ 2     │ 5     │ 2.0          │\n│ 3   │ 3     │ 6     │ 4.0          │\n\njulia> select(df, names(df) .=> sum)\n1×2 DataFrame\n│ Row │ a_sum │ b_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 6     │ 15    │\n\njulia> select(df, names(df) .=> sum .=> [:A, :B])\n1×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 6     │ 15    │\n\njulia> select(df, AsTable(:) => ByRow(mean))\n3×1 DataFrame\n│ Row │ a_b_mean │\n│     │ Float64  │\n├─────┼──────────┤\n│ 1   │ 2.5      │\n│ 2   │ 3.5      │\n│ 3   │ 4.5      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select!","page":"Functions","title":"DataFrames.select!","text":"select!(df::DataFrame, args...)\n\nMutate df in place to retain only columns specified by args... and return it.\n\nArguments passed as args... can be:\n\nAny index that is allowed for column indexing (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\nColumn transformation operations using the Pair notation that is described below and vectors of such pairs.\n\nColumns can be renamed using the old_column => new_column_name syntax, and transformed using the old_column => fun => new_column_name syntax. new_column_name must be a Symbol or a string, and fun a function or a type. If old_column is a Symbol, a string, or an integer then fun is applied to the corresponding column vector. Otherwise old_column can be any column indexing syntax, in which case fun will be passed the column vectors specified by old_column as separate arguments. The only exception is when old_column is an AsTable type wrapping a selector, in which case fun is passed a NamedTuple containing the selected columns.\n\nIf fun returns a value of type other than AbstractVector then it will be broadcasted into a vector matching the target number of rows in the data frame, unless its type is one of AbstractDataFrame, NamedTuple, DataFrameRow, AbstractMatrix, in which case an error is thrown as currently these return types are not allowed. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then broadcasted.\n\nTo apply fun to each row instead of whole columns, it can be wrapped in a ByRow struct. In this case if old_column is a Symbol, a string, or an integer then fun is applied to each element (row) of old_column using broadcasting. Otherwise old_column can be any column indexing syntax, in which case fun will be passed one argument for each of the columns specified by old_column. If ByRow is used it is not allowed for old_column to select an empty set of columns nor for fun to return a NamedTuple or a DataFrameRow.\n\nColumn transformation can also be specified using the short old_column => fun form. In this case, new_column_name is automatically generated as $(old_column)_$(fun). Up to three column names are used for multiple input columns and they are joined using _; if more than three columns are passed then the name consists of the first two names and etc suffix then, e.g. [:a,:b,:c,:d] => fun produces the new column name :a_b_etc_fun.\n\nColumn renaming and transformation operations can be passed wrapped in vectors (this is useful when combined with broadcasting).\n\nAs a special rule passing nrow without specifying old_column creates a column named :nrow containing a number of rows in a source data frame, and passing nrow => new_column_name stores the number of rows in source data frame in new_column_name column.\n\nIf a collection of column names is passed to select! or select then requesting duplicate column names in target data frame are accepted (e.g. select!(df, [:a], :, r\"a\") is allowed) and only the first occurrence is used. In particular a syntax to move column :col to the first position in the data frame is select!(df, :col, :). On the contrary, output column names of renaming, transformation and single column selection operations must be unique, so e.g. select!(df, :a, :a => :a) or select!(df, :a, :a => ByRow(sin) => :a) are not allowed.\n\nNote that including the same column several times in the data frame via renaming or transformations that return the same object without copying will create column aliases. An example of such a situation is select!(df, :a, :a => :b, :a => identity => :c).\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> select!(df, 2)\n3×1 DataFrame\n│ Row │ b     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 4     │\n│ 2   │ 5     │\n│ 3   │ 6     │\n\njulia> df = DataFrame(a=1:3, b=4:6);\n\njulia> select!(df, :a => ByRow(sin) => :c, :b)\n3×2 DataFrame\n│ Row │ c        │ b     │\n│     │ Float64  │ Int64 │\n├─────┼──────────┼───────┤\n│ 1   │ 0.841471 │ 4     │\n│ 2   │ 0.909297 │ 5     │\n│ 3   │ 0.14112  │ 6     │\n\njulia> select!(df, :, [:c, :b] => (c,b) -> c .+ b .- sum(b)/length(b))\n3×3 DataFrame\n│ Row │ c        │ b     │ c_b_function │\n│     │ Float64  │ Int64 │ Float64      │\n├─────┼──────────┼───────┼──────────────┤\n│ 1   │ 0.841471 │ 4     │ -0.158529    │\n│ 2   │ 0.909297 │ 5     │ 0.909297     │\n│ 3   │ 0.14112  │ 6     │ 1.14112      │\n\njulia> df = DataFrame(a=1:3, b=4:6);\n\njulia> select!(df, names(df) .=> sum);\n\njulia> df\n1×2 DataFrame\n│ Row │ a_sum │ b_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 6     │ 15    │\n\njulia> df = DataFrame(a=1:3, b=4:6);\n\njulia> using Statistics\n\njulia> select!(df, AsTable(:) => ByRow(mean))\n3×1 DataFrame\n│ Row │ a_b_mean │\n│     │ Float64  │\n├─────┼──────────┤\n│ 1   │ 2.5      │\n│ 2   │ 3.5      │\n│ 3   │ 4.5      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.show","page":"Functions","title":"Base.show","text":"show([io::IO,] df::AbstractDataFrame;\n     allrows::Bool = !get(io, :limit, false),\n     allcols::Bool = !get(io, :limit, false),\n     allgroups::Bool = !get(io, :limit, false),\n     splitcols::Bool = get(io, :limit, false),\n     rowlabel::Symbol = :Row,\n     summary::Bool = true)\n\nRender a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.\n\nIf io is omitted, the result is printed to stdout, and allrows, allcols and allgroups default to false while splitcols defaults to true.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\ndf::AbstractDataFrame: The data frame to print.\nallrows::Bool: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if io does not have the IOContext property limit set.\nallcols::Bool: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if io does not have the IOContext property limit set.\nallgroups::Bool: Whether to print all groups rather than the first and last, when df is a GroupedDataFrame. By default this is the case only if io does not have the IOContext property limit set.\nsplitcols::Bool: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if allcols is true. By default this is the case only if io has the IOContext property limit set.\nrowlabel::Symbol = :Row: The label to use for the column containing row numbers.\nsummary::Bool = true: Whether to print a brief string summary of the data frame.\neltypes::Bool = true: Whether to print the column types under column names.\n\nExamples\n\njulia> using DataFrames\n\njulia> df = DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]);\n\njulia> show(df, allcols=true)\n3×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ x      │\n│ 2   │ 2     │ y      │\n│ 3   │ 3     │ z      │\n\n\n\n\n\nshow(io::IO, mime::MIME, df::AbstractDataFrame)\n\nRender a data frame to an I/O stream in MIME type mime.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\nmime::MIME: supported MIME types are: \"text/plain\", \"text/html\", \"text/latex\", \"text/csv\", \"text/tab-separated-values\" (the last two MIME types do not support  showing #undef values)\ndf::AbstractDataFrame: The data frame to print.\n\nAdditionally selected MIME types support passing the following keyword arguments:\n\nMIME type \"text/plain\" accepts all listed keyword arguments and therir behavior is identical as for show(::IO, ::AbstractDataFrame)\nMIME type \"text/html\" accepts summary keyword argument which allows to choose whether to print a brief string summary of the data frame.\n\nExamples\n\njulia> show(stdout, MIME(\"text/latex\"), DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]))\n\\begin{tabular}{r|cc}\n        & A & B\\\\\n        \\hline\n        & Int64 & String\\\\\n        \\hline\n        1 & 1 & x \\\\\n        2 & 2 & y \\\\\n        3 & 3 & z \\\\\n\\end{tabular}\n14\n\njulia> show(stdout, MIME(\"text/csv\"), DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]))\n\"A\",\"B\"\n1,\"x\"\n2,\"y\"\n3,\"z\"\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.size","page":"Functions","title":"Base.size","text":"size(df::AbstractDataFrame, [dim])\n\nReturn a tuple containing the number of rows and columns of df. Optionally a dimension dim can be specified, where 1 corresponds to rows and 2 corresponds to columns.\n\nSee also: nrow, ncol\n\nExamples\n\njulia> df = DataFrame(a=1:3, b='a':'c');\n\njulia> size(df)\n(3, 2)\n\njulia> size(df, 1)\n3\n\n\n\n\n\nsize(dfr::DataFrameRow, [dim])\n\nReturn a 1-tuple containing the number of elements of dfr. If an optional dimension dim is specified, it must be 1, and the number of elements is returned directly as a number.\n\nSee also: length\n\nExamples\n\njulia> dfr = DataFrame(a=1:3, b='a':'c')[1, :];\n\njulia> size(dfr)\n(2,)\n\njulia> size(dfr, 1)\n2\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort","page":"Functions","title":"Base.sort","text":"sort(df::AbstractDataFrame, cols;\n     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n     rev::Bool=false, order::Ordering=Forward)\n\nReturn a copy of data frame df sorted by column(s) cols.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See sort! for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> sort(df, :x)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort(df, [:x, :y])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort(df, [:x, :y], rev=true)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n│ 3   │ 1     │ c      │\n│ 4   │ 1     │ b      │\n\njulia> sort(df, [:x, order(:y, rev=true)])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort!","page":"Functions","title":"Base.sort!","text":"sort!(df::AbstractDataFrame, cols;\n      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n      rev::Bool=false, order::Ordering=Forward)\n\nSort data frame df by column(s) cols.\n\ncols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See other methods for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> sort!(df, :x)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort!(df, [:x, :y])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort!(df, [:x, :y], rev=true)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n│ 3   │ 1     │ c      │\n│ 4   │ 1     │ b      │\n\njulia> sort!(df, (:x, order(:y, rev=true)))\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.transform","page":"Functions","title":"DataFrames.transform","text":"transform(df::AbstractDataFrame, args...; copycols::Bool=true)\n\nCreate a new data frame that contains columns from df and adds columns specified by args and return it. Equivalent to select(df, :, args..., copycols=copycols).\n\nSee select for detailed rules regarding accepted values for args.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.transform!","page":"Functions","title":"DataFrames.transform!","text":"transform!(df::DataFrame, args...)\n\nMutate df in place to add columns specified by args... and return it. Equivalent to select!(df, :, args...).\n\nSee select! for detailed rules regarding accepted values for args.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.unique!","page":"Functions","title":"Base.unique!","text":"unique(df::AbstractDataFrame)\nunique(df::AbstractDataFrame, cols)\nunique!(df::AbstractDataFrame)\nunique!(df::AbstractDataFrame, cols)\n\nDelete duplicate rows of data frame df, keeping only the first occurrence of unique rows. When cols is specified, the returned DataFrame contains complete rows, retaining in each case the first instance for which df[cols] is unique. cols can be any column selector (Symbol, string or integer; :, All, Between, Not, a regular expression, or a vector of Symbols, strings or integers).\n\nWhen unique is called a new data frame is returned; unique! updates df in-place.\n\nSee also nonunique.\n\nArguments\n\ndf : the AbstractDataFrame\ncols :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)\n\nspecifying the column(s) to compare.\n\nExamples\n\ndf = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10))\ndf = vcat(df, df)\nunique(df)   # doesn't modify df\nunique(df, 1)\nunique!(df)  # modifies df\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.vcat","page":"Functions","title":"Base.vcat","text":"vcat(dfs::AbstractDataFrame...;\n     cols::Union{Symbol, AbstractVector{Symbol},\n                 AbstractVector{<:AbstractString}}=:setequal)\n\nVertically concatenate AbstractDataFrames.\n\nThe cols keyword argument determines the columns of the returned data frame:\n\n:setequal: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.\n:orderequal: require all data frames to have the same column names and in the same order.\n:intersect: only the columns present in all provided data frames are kept. If the intersection is empty, an empty data frame is returned.\n:union: columns present in at least one of the provided data frames are kept. Columns not present in some data frames are filled with missing where necessary.\nA vector of Symbols or strings: only listed columns are kept. Columns not present in some data frames are filled with missing where necessary.\n\nThe order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.\n\nThe element types of columns are determined using promote_type, as with vcat for AbstractVectors.\n\nvcat ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and vcat onto it.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3);\n\njulia> df2 = DataFrame(A=4:6, B=4:6);\n\njulia> df3 = DataFrame(A=7:9, C=7:9);\n\njulia> d4 = DataFrame();\n\njulia> vcat(df1, df2)\n6×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 4     │ 4     │\n│ 5   │ 5     │ 5     │\n│ 6   │ 6     │ 6     │\n\njulia> vcat(df1, df3, cols=:union)\n6×3 DataFrame\n│ Row │ A     │ B       │ C       │\n│     │ Int64 │ Int64?  │ Int64?  │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ 1       │ missing │\n│ 2   │ 2     │ 2       │ missing │\n│ 3   │ 3     │ 3       │ missing │\n│ 4   │ 7     │ missing │ 7       │\n│ 5   │ 8     │ missing │ 8       │\n│ 6   │ 9     │ missing │ 9       │\n\njulia> vcat(df1, df3, cols=:intersect)\n6×1 DataFrame\n│ Row │ A     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n│ 4   │ 7     │\n│ 5   │ 8     │\n│ 6   │ 9     │\n\njulia> vcat(d4, df1)\n3×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"man/split_apply_combine/#The-Split-Apply-Combine-Strategy-1","page":"Split-apply-combine","title":"The Split-Apply-Combine Strategy","text":"","category":"section"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"Many data analysis tasks involve splitting a data set into groups, applying some functions to each of the groups and then combining the results. A standardized framework for handling this sort of computation is described in the paper \"The Split-Apply-Combine Strategy for Data Analysis\", written by Hadley Wickham.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The DataFrames package supports the split-apply-combine strategy through the by function, which is a shorthand for groupby followed by map and/or combine. by takes in three arguments: (1) a DataFrame, (2) one or more columns to split the DataFrame on, and (3) a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"standard column selectors (integers, symbols, vectors of integers, vectors of symbols, All, :, Between, Not and regular expressions)\na cols => function pair indicating that function should be called with positional arguments holding columns cols, which can be a any valid column selector\na cols => function => target_col form additionally specifying the name of the target column (this assumes that function returns a single value or a vector)\na col => target_col pair, which renames the column col to target_col\na nrow or nrow => target_col form which efficiently computes the number of rows in a group (without target_col the new column is called :nrow)\nseveral arguments of the forms given above, or vectors thereof\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance unless a very large number of columns are processed (in which case SubDataFrame avoids excessive compilation)","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"All forms except 1 and 6 can be also passed as the first argument to map.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"As a special rule that applies to cols => function syntax, if cols is wrapped in an AsTable object then a NamedTuple containing columns selected by cols is passed to function.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"In all of these cases, function can return either a single row or multiple rows. function can always generate a single column by returning a single value or a vector. Additionally, if by is passed exactly one function and target_col is not specified, function can return multiple columns in the form of an AbstractDataFrame, AbstractMatrix, NamedTuple or DataFrameRow.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"Here are the rules specifying the shape of the resulting DataFrame:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"a single value produces a single row and column per group\na named tuple or DataFrameRow produces a single row and one column per field\na vector produces a single column with one row per entry\na named tuple of vectors produces one column per field with one row per entry in the vectors\na DataFrame or a matrix produces as many rows and columns as it contains; note that this option should be avoided due to its poor performance when the number of groups is large","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The kind of return value and the number and names of columns must be the same for all groups.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"It is allowed to mix single values and vectors if multiple transformations are requested. In this case single value will be broadcasted to match the length of columns specified by returned vectors. As a particular rule, values wrapped in a Ref or a 0-dimensional AbstractArray are unwrapped and then broadcasted.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"If a single value or a vector is returned by the function and target_col is not provided, it is generated automatically, by concatenating source column name and function name where possible (see examples below).","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"We show several examples of the by function applied to the iris dataset below:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> using DataFrames, CSV, Statistics\n\njulia> iris = DataFrame(CSV.File(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\")))\n150×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64     │ Float64    │ Float64     │ Float64    │ String         │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ Iris-setosa    │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa    │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa    │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ Iris-setosa    │\n│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ Iris-setosa    │\n│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa    │\n│ 7   │ 4.6         │ 3.4        │ 1.4         │ 0.3        │ Iris-setosa    │\n⋮\n│ 143 │ 5.8         │ 2.7        │ 5.1         │ 1.9        │ Iris-virginica │\n│ 144 │ 6.8         │ 3.2        │ 5.9         │ 2.3        │ Iris-virginica │\n│ 145 │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ Iris-virginica │\n│ 146 │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ Iris-virginica │\n│ 147 │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ Iris-virginica │\n│ 148 │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ Iris-virginica │\n│ 149 │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 150 │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ Iris-virginica │\n\njulia> by(iris, :Species, :PetalLength => mean)\n3×2 DataFrame\n│ Row │ Species         │ PetalLength_mean │\n│     │ String          │ Float64          │\n├─────┼─────────────────┼──────────────────┤\n│ 1   │ Iris-setosa     │ 1.464            │\n│ 2   │ Iris-versicolor │ 4.26             │\n│ 3   │ Iris-virginica  │ 5.552            │\n\njulia> by(iris, :Species, nrow)\n3×2 DataFrame\n│ Row │ Species         │ nrow  │\n│     │ String          │ Int64 │\n├─────┼─────────────────┼───────┤\n│ 1   │ Iris-setosa     │ 50    │\n│ 2   │ Iris-versicolor │ 50    │\n│ 3   │ Iris-virginica  │ 50    │\n\njulia> by(iris, :Species, nrow, :PetalLength => mean => :mean)\n3×3 DataFrame\n│ Row │ Species         │ nrow  │ mean    │\n│     │ String          │ Int64 │ Float64 │\n├─────┼─────────────────┼───────┼─────────┤\n│ 1   │ Iris-setosa     │ 50    │ 1.464   │\n│ 2   │ Iris-versicolor │ 50    │ 4.26    │\n│ 3   │ Iris-virginica  │ 50    │ 5.552   │\n\njulia> by(iris, :Species,\n          [:PetalLength, :SepalLength] =>\n          (p, s) -> (a=mean(p)/mean(s), b=sum(p))) # multiple columns are passed as arguments\n3×3 DataFrame\n│ Row │ Species         │ a        │ b       │\n│     │ String          │ Float64  │ Float64 │\n├─────┼─────────────────┼──────────┼─────────┤\n│ 1   │ Iris-setosa     │ 0.292449 │ 73.2    │\n│ 2   │ Iris-versicolor │ 0.717655 │ 213.0   │\n│ 3   │ Iris-virginica  │ 0.842744 │ 277.6   │\n\njulia> by(iris, :Species,\n          AsTable([:PetalLength, :SepalLength]) =>\n          x -> std(x.PetalLength) / std(x.SepalLength)) # passing a NamedTuple\n3×2 DataFrame\n│ Row │ Species         │ PetalLength_SepalLength_function │\n│     │ String          │ Float64                          │\n├─────┼─────────────────┼──────────────────────────────────┤\n│ 1   │ Iris-setosa     │ 0.492245                         │\n│ 2   │ Iris-versicolor │ 0.910378                         │\n│ 3   │ Iris-virginica  │ 0.867923                         │\n\njulia> by(iris, :Species, 1:2 => cor, nrow)\n3×3 DataFrame\n│ Row │ Species         │ SepalLength_SepalWidth_cor │ nrow  │\n│     │ String          │ Float64                    │ Int64 │\n├─────┼─────────────────┼────────────────────────────┼───────┤\n│ 1   │ Iris-setosa     │ 0.74678                    │ 50    │\n│ 2   │ Iris-versicolor │ 0.525911                   │ 50    │\n│ 3   │ Iris-virginica  │ 0.457228                   │ 50    │\n","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The by function also supports the do block form. However, as noted above, this form is slow and should therefore be avoided when performance matters.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> by(iris, :Species) do df\n           (m = mean(df.PetalLength), s² = var(df.PetalLength))\n       end\n3×3 DataFrame\n│ Row │ Species         │ m       │ s²        │\n│     │ String          │ Float64 │ Float64   │\n├─────┼─────────────────┼─────────┼───────────┤\n│ 1   │ Iris-setosa     │ 1.464   │ 0.0301061 │\n│ 2   │ Iris-versicolor │ 4.26    │ 0.220816  │\n│ 3   │ Iris-virginica  │ 5.552   │ 0.304588  │","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"If you only want to split the data set into subsets, use the groupby function:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for subdf in groupby(iris, :Species)\n           println(size(subdf, 1))\n       end\n50\n50\n50","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"To also get the values of the grouping columns along with each group, use the pairs function:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for (key, subdf) in pairs(groupby(iris, :Species))\n           println(\"Number of data points for $(key.Species): $(nrow(subdf))\")\n       end\nNumber of data points for Iris-setosa: 50\nNumber of data points for Iris-versicolor: 50\nNumber of data points for Iris-virginica: 50","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The value of key in the previous example is a DataFrames.GroupKey object, which can be used in a similar fashion to a NamedTuple.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"Grouping a data frame using the groupby function can be seen as adding a lookup key to it. Such lookups can be performed efficiently by indexing the resulting GroupedDataFrame with a Tuple or NamedTuple:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> df = DataFrame(g = repeat(1:1000, inner=5), x = 1:5000);\n\njulia> gdf = groupby(df, :g)\nGroupedDataFrame with 1000 groups based on key: g\nFirst Group (5 rows): g = 1\n│ Row │ g     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 1     │ 2     │\n│ 3   │ 1     │ 3     │\n│ 4   │ 1     │ 4     │\n│ 5   │ 1     │ 5     │\n⋮\nLast Group (5 rows): g = 1000\n│ Row │ g     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1000  │ 4996  │\n│ 2   │ 1000  │ 4997  │\n│ 3   │ 1000  │ 4998  │\n│ 4   │ 1000  │ 4999  │\n│ 5   │ 1000  │ 5000  │\n\njulia> gdf[(g=500,)]\n5×2 SubDataFrame\n│ Row │ g     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 500   │ 2496  │\n│ 2   │ 500   │ 2497  │\n│ 3   │ 500   │ 2498  │\n│ 4   │ 500   │ 2499  │\n│ 5   │ 500   │ 2500  │\n\njulia> gdf[[(500,), (501,)]]\nGroupedDataFrame with 2 groups based on key: g\nFirst Group (5 rows): g = 500\n│ Row │ g     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 500   │ 2496  │\n│ 2   │ 500   │ 2497  │\n│ 3   │ 500   │ 2498  │\n│ 4   │ 500   │ 2499  │\n│ 5   │ 500   │ 2500  │\n⋮\nLast Group (5 rows): g = 501\n│ Row │ g     │ x     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 501   │ 2501  │\n│ 2   │ 501   │ 2502  │\n│ 3   │ 501   │ 2503  │\n│ 4   │ 501   │ 2504  │\n│ 5   │ 501   │ 2505  │","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"In order to apply a function to each non-grouping column of a GroupedDataFrame you can write:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> gd = groupby(iris, :Species);\n\njulia> combine(gd, valuecols(gd) .=> mean)\n3×5 DataFrame\n│ Row │ Species         │ SepalLength_mean │ SepalWidth_mean │ PetalLength_mean │ PetalWidth_mean │\n│     │ String          │ Float64          │ Float64         │ Float64          │ Float64         │\n├─────┼─────────────────┼──────────────────┼─────────────────┼──────────────────┼─────────────────┤\n│ 1   │ Iris-setosa     │ 5.006            │ 3.418           │ 1.464            │ 0.244           │\n│ 2   │ Iris-versicolor │ 5.936            │ 2.77            │ 4.26             │ 1.326           │\n│ 3   │ Iris-virginica  │ 6.588            │ 2.974           │ 5.552            │ 2.026           │\n\njulia> combine(gd, valuecols(gd) .=> (x -> (x .- mean(x)) ./ std(x)) .=> valuecols(gd))\n150×5 DataFrame\n│ Row │ Species        │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │\n│     │ String         │ Float64     │ Float64    │ Float64     │ Float64    │\n├─────┼────────────────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ Iris-setosa    │ 0.266674    │ 0.215209   │ -0.368852   │ -0.410411  │\n│ 2   │ Iris-setosa    │ -0.300718   │ -1.09704   │ -0.368852   │ -0.410411  │\n│ 3   │ Iris-setosa    │ -0.868111   │ -0.572142  │ -0.945184   │ -0.410411  │\n│ 4   │ Iris-setosa    │ -1.15181    │ -0.834592  │ 0.207479    │ -0.410411  │\n│ 5   │ Iris-setosa    │ -0.0170218  │ 0.47766    │ -0.368852   │ -0.410411  │\n│ 6   │ Iris-setosa    │ 1.11776     │ 1.26501    │ 1.36014     │ 1.45509    │\n│ 7   │ Iris-setosa    │ -1.15181    │ -0.0472411 │ -0.368852   │ 0.522342   │\n⋮\n│ 143 │ Iris-virginica │ -1.23923    │ -0.849621  │ -0.818997   │ -0.458766  │\n│ 144 │ Iris-virginica │ 0.333396    │ 0.700782   │ 0.630555    │ 0.997633   │\n│ 145 │ Iris-virginica │ 0.176134    │ 1.01086    │ 0.268167    │ 1.72583    │\n│ 146 │ Iris-virginica │ 0.176134    │ 0.080621   │ -0.637803   │ 0.997633   │\n│ 147 │ Iris-virginica │ -0.452916   │ -1.46978   │ -1.00019    │ -0.458766  │\n│ 148 │ Iris-virginica │ -0.138391   │ 0.080621   │ -0.637803   │ -0.0946659 │\n│ 149 │ Iris-virginica │ -0.610178   │ 1.32094    │ -0.275415   │ 0.997633   │\n│ 150 │ Iris-virginica │ -1.08197    │ 0.080621   │ -0.818997   │ -0.822865  │","category":"page"},{"location":"man/getting_started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The DataFrames package is available through the Julia package system and can be installed using the following commands:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Throughout the rest of this tutorial, we will assume that you have installed the DataFrames package and have already typed using DataFrames to bring all of the relevant variables into your current namespace.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nBy default Jupyter Notebook will limit the number of rows and columns when displaying a data frame to roughly fit the screen size (like in the REPL).You can override this behavior by changing the values of the ENV[\"COLUMNS\"] and ENV[\"LINES\"] variables to hold the maximum width and height of output in characters respectively.Alternatively, you may want to set the maximum number of data frame rows to print to 100 and the maximum output width in characters to 1000 for every Julia session using some Jupyter kernel file (numbers 100 and 1000 are only examples and can be adjusted). In such case add a \"COLUMNS\": \"1000\", \"LINES\": \"100\" entry to the \"env\" variable in this Jupyter kernel file. See here for information about location and specification of Jupyter kernels.","category":"page"},{"location":"man/getting_started/#The-DataFrame-Type-1","page":"Getting Started","title":"The DataFrame Type","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Objects of the DataFrame type represent a data table as a series of vectors, each corresponding to a column or variable. The simplest way of constructing a DataFrame is to pass column vectors using keyword arguments or pairs:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ F      │\n│ 3   │ 3     │ F      │\n│ 4   │ 4     │ M      │\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Columns can be directly (i.e. without copying) accessed via df.col, df.\"col\", df[!, :col] or df[!, \"col\"]. The two latter syntaxes are more flexible as they allow passing a variable holding the name of the column, and not only a literal name. Note that column names can be either symbols (written as :col, :var\"col\" or Symbol(\"col\")) or strings (written as \"col\"). Note that in the forms df.\"col\" and :var\"col\" variable interpolation into a string using $ does not work. Columns can also be accessed using an integer index specifying their position.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Since df[!, :col] does not make a copy, changing the elements of the column vector returned by this syntax will affect the values stored in the original df. To get a copy of the column use df[:, :col]: changing the vector returned by this syntax does not change df.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df.A\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> df.\"A\"\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> df.A === df[!, :A]\ntrue\n\njulia> df.A === df[:, :A]\nfalse\n\njulia> df.A == df[:, :A]\ntrue\n\njulia> df.A === df[!, \"A\"]\ntrue\n\njulia> df.A === df[:, \"A\"]\nfalse\n\njulia> df.A == df[:, \"A\"]\ntrue\n\njulia> df.A === df[!, 1]\ntrue\n\njulia> df.A === df[:, 1]\nfalse\n\njulia> df.A == df[:, 1]\ntrue\n\njulia> firstcolumn = :A\n:A\n\njulia> df[!, firstcolumn] === df.A\ntrue\n\njulia> df[:, firstcolumn] === df.A\nfalse\n\njulia> df[:, firstcolumn] == df.A\ntrue","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Column names can be obtained as strings using the names function:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> names(df)\n2-element Array{String,1}:\n \"A\"\n \"B\"\n ```\n\nTo get column names as `Symbol`s use the `propertynames` function:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> propertynames(df) 2-element Array{Symbol,1}:  :A  :B","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\n!!! note\n\n    DataFrames.jl allows to use `Symbol`s (like `:A`) and strings (like `\"A\"`)\n    for all column indexing operations for convenience.\n    However, using `Symbol`s is slightly faster and should generally be preferred, if not generating them via string manipulation.\n\n\n### Constructing Column by Column\n\nIt is also possible to start with an empty `DataFrame` and add columns to it one by one:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame() 0×0 DataFrame","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df.A = 1:8 1:8","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df.B = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"] 8-element Array{String,1}:  \"M\"  \"F\"  \"F\"  \"M\"  \"F\"  \"M\"  \"M\"  \"F\"","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df 8×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │ │ 2   │ 2     │ F      │ │ 3   │ 3     │ F      │ │ 4   │ 4     │ M      │ │ 5   │ 5     │ F      │ │ 6   │ 6     │ M      │ │ 7   │ 7     │ M      │ │ 8   │ 8     │ F      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nThe `DataFrame` we build in this way has 8 rows and 2 columns.\nThis can be checked using the `size` function:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> size(df, 1) 8","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> size(df, 2) 2","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> size(df) (8, 2)","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\n### Constructing Row by Row\n\nIt is also possible to fill a `DataFrame` row by row. Let us construct an empty data frame with two columns (note that the first column can only contain integers and the second one can only contain strings):\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(A = Int[], B = String[]) 0×2 DataFrame","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nRows can then be added as tuples or vectors, where the order of elements matches that of columns:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> push!(df, (1, \"M\")) 1×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, [2, \"N\"]) 2×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │ │ 2   │ 2     │ N      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nRows can also be added as `Dict`s, where the dictionary keys match the column names:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> push!(df, Dict(:B => \"F\", :A => 3)) 3×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │ │ 2   │ 2     │ N      │ │ 3   │ 3     │ F      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nNote that constructing a `DataFrame` row by row is significantly less performant than\nconstructing it all at once, or column by column. For many use-cases this will not matter,\nbut for very large `DataFrame`s  this may be a consideration.\n\n### Constructing from another table type\n\nDataFrames supports the [Tables.jl](https://github.com/JuliaData/Tables.jl) interface for\ninteracting with tabular data. This means that a `DataFrame` can be used as a \"source\"\nto any package that expects a Tables.jl interface input, (file format packages,\ndata manipulation packages, etc.). A `DataFrame` can also be a sink for any Tables.jl\ninterface input. Some example uses are:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])","category":"page"},{"location":"man/getting_started/#write-DataFrame-out-to-CSV-file-1","page":"Getting Started","title":"write DataFrame out to CSV file","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"CSV.write(\"dataframe.csv\", df)","category":"page"},{"location":"man/getting_started/#store-DataFrame-in-an-SQLite-database-table-1","page":"Getting Started","title":"store DataFrame in an SQLite database table","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"SQLite.load!(df, db, \"dataframe_table\")","category":"page"},{"location":"man/getting_started/#transform-a-DataFrame-through-Query.jl-package-1","page":"Getting Started","title":"transform a DataFrame through Query.jl package","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"df = df |> @map({a=_.a + 1, _.b}) |> DataFrame","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nA particular common case of a collection that supports the\n[Tables.jl](https://github.com/JuliaData/Tables.jl) interface is\na vector of `NamedTuple`s:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> v = [(a=1,b=2), (a=3,b=4)] 2-element Array{NamedTuple{(:a, :b),Tuple{Int64,Int64}},1}:  (a = 1, b = 2)  (a = 3, b = 4)","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(v) 2×2 DataFrame │ Row │ a     │ b     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 2     │ │ 2   │ 3     │ 4     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"You can also easily convert a data frame back to a vector of `NamedTuple`s:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using Tables","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> Tables.rowtable(df) 2-element Array{NamedTuple{(:a, :b),Tuple{Int64,Int64}},1}:  (a = 1, b = 2)  (a = 3, b = 4)","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\n## Working with Data Frames\n\n### Examining the Data\n\nThe default printing of `DataFrame` objects only includes a sample of rows and columns that fits on screen:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500) 500×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 3     │ 1     │ 2     │ │ 3   │ 5     │ 1     │ 3     │ │ 4   │ 7     │ 1     │ 4     │ ⋮ │ 496 │ 991   │ 10    │ 496   │ │ 497 │ 993   │ 10    │ 497   │ │ 498 │ 995   │ 10    │ 498   │ │ 499 │ 997   │ 10    │ 499   │ │ 500 │ 999   │ 10    │ 500   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nPrinting options can be adjusted by calling the `show` function manually: `show(df, allrows=true)` prints all rows even if they do not fit on screen and `show(df, allcols=true)` does the same for columns.\n\nThe `first` and `last` functions can be used to look at the first and last rows of a data frame (respectively):\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> first(df, 6) 6×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 3     │ 1     │ 2     │ │ 3   │ 5     │ 1     │ 3     │ │ 4   │ 7     │ 1     │ 4     │ │ 5   │ 9     │ 1     │ 5     │ │ 6   │ 11    │ 1     │ 6     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> last(df, 6) 6×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 989   │ 10    │ 495   │ │ 2   │ 991   │ 10    │ 496   │ │ 3   │ 993   │ 10    │ 497   │ │ 4   │ 995   │ 10    │ 498   │ │ 5   │ 997   │ 10    │ 499   │ │ 6   │ 999   │ 10    │ 500   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nAlso notice that when `DataFrame` is printed to the console or rendered in HTML (e.g. in Jupyter Notebook) you get an information about type of elements held in its columns. For example in this case:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> DataFrame(a = 1:2, b = [1.0, missing],                  c = categorical('a':'b'), d = [1//2, missing]) 2×4 DataFrame │ Row │ a     │ b        │ c    │ d         │ │     │ Int64 │ Float64? │ Cat… │ Rationa…? │ ├─────┼───────┼──────────┼──────┼───────────┤ │ 1   │ 1     │ 1.0      │ 'a'  │ 1//2      │ │ 2   │ 2     │ missing  │ 'b'  │ missing   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nwe can observe that:\n\n* the first column `:a` can hold elements of type `Int64`;\n* the second column `:b` can hold `Float64` or `Missing`, which is indicated by `?` printed after the name of type;\n* the third column `:c` can hold categorical data; here we notice `…`, which indicates that the actual name of the type was long and got truncated;\n* the type information in fourth column `:d` presents a situation where the name is both truncated and the type allows `Missing`.\n\n### Taking a Subset\n\n#### Indexing syntax\n\nSpecific subsets of a data frame can be extracted using the indexing syntax, similar to matrices. The colon `:` indicates that all items (rows or columns depending on its position) should be retained:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df[1:3, :] 3×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 3     │ 1     │ 2     │ │ 3   │ 5     │ 1     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[[1, 5, 10], :] 3×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 9     │ 1     │ 5     │ │ 3   │ 19    │ 1     │ 10    │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[:, [:A, :B]] 500×2 DataFrame │ Row │ A     │ B     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 1     │ │ 2   │ 3     │ 1     │ │ 3   │ 5     │ 1     │ │ 4   │ 7     │ 1     │ ⋮ │ 496 │ 991   │ 10    │ │ 497 │ 993   │ 10    │ │ 498 │ 995   │ 10    │ │ 499 │ 997   │ 10    │ │ 500 │ 999   │ 10    │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[1:3, [:B, :A]] 3×2 DataFrame │ Row │ B     │ A     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 1     │ │ 2   │ 1     │ 3     │ │ 3   │ 1     │ 5     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[[3, 1], [:C]] 2×1 DataFrame │ Row │ C     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 3     │ │ 2   │ 1     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nDo note that `df[!, [:A]]` and `df[:, [:A]]` return a `DataFrame` object, while `df[!, :A]` and `df[:, :A]` return a vector:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df[!, [:A]] 500×1 DataFrame │ Row │ A     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │ │ 2   │ 3     │ │ 3   │ 5     │ │ 4   │ 7     │ ⋮ │ 496 │ 991   │ │ 497 │ 993   │ │ 498 │ 995   │ │ 499 │ 997   │ │ 500 │ 999   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[!, [:A]] == df[:, [:A]] true","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[!, :A] 500-element Array{Int64,1}:    1    3    5    7    9   11    ⋮  991  993  995  997  999","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[!, :A] == df[:, :A] true","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nIn the first case, `[:A]` is a vector, indicating that the resulting object should be a `DataFrame`. On the other hand, `:A` is a single symbol, indicating that a single column vector should be extracted. Note that in the first case a vector is required to be passed (not just any iterable), so e.g. `df[:, (:x1, :x2)]` is not allowed, but `df[:, [:x1, :x2]]` is valid.\n\nIt is also possible to use a regular expression as a selector of columns matching it:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(x1=1, x2=2, y=3) 1×3 DataFrame │ Row │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[!, r\"x\"] 1×2 DataFrame │ Row │ x1    │ x2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 2     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nA `Not` selector (from the [InvertedIndices](https://github.com/mbauman/InvertedIndices.jl) package) can be used to select all columns excluding a specific subset:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df[!, Not(:x1)] 1×2 DataFrame │ Row │ x2    │ y     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nFinally, you can use `Not` and `All` selectors in more complex column selection scenarios.\nThe following examples move all columns whose names match `r\"x\"` regular expression respectively to the front and to the end of a data frame:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(r=1, x1=2, x2=3, y=4) 1×4 DataFrame │ Row │ r     │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │ 4     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[:, All(r\"x\", :)] 1×4 DataFrame │ Row │ x1    │ x2    │ r     │ y     │ │     │ Int64 │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┼───────┤ │ 1   │ 2     │ 3     │ 1     │ 4     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[:, All(Not(r\"x\"), :)] 1×4 DataFrame │ Row │ r     │ y     │ x1    │ x2    │ │     │ Int64 │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┼───────┤ │ 1   │ 1     │ 4     │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nThe indexing syntax can also be used to select rows based on conditions on variables:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df[df.A .> 500, :] 250×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 501   │ 6     │ 251   │ │ 2   │ 503   │ 6     │ 252   │ │ 3   │ 505   │ 6     │ 253   │ │ 4   │ 507   │ 6     │ 254   │ ⋮ │ 246 │ 991   │ 10    │ 496   │ │ 247 │ 993   │ 10    │ 497   │ │ 248 │ 995   │ 10    │ 498   │ │ 249 │ 997   │ 10    │ 499   │ │ 250 │ 999   │ 10    │ 500   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[(df.A .> 500) .& (300 .< df.C .< 400), :] 99×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 601   │ 7     │ 301   │ │ 2   │ 603   │ 7     │ 302   │ │ 3   │ 605   │ 7     │ 303   │ │ 4   │ 607   │ 7     │ 304   │ ⋮ │ 95  │ 789   │ 8     │ 395   │ │ 96  │ 791   │ 8     │ 396   │ │ 97  │ 793   │ 8     │ 397   │ │ 98  │ 795   │ 8     │ 398   │ │ 99  │ 797   │ 8     │ 399   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Where a specific subset of values needs to be matched, the `in()` function can be applied:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df[in.(df.A, Ref([1, 5, 601])), :] 3×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 5     │ 1     │ 3     │ │ 3   │ 601   │ 7     │ 301   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nEquivalently, the `in` function can be called with a single argument to create\na function object that tests whether each value belongs to the subset\n(partial application of `in`): `df[in([1, 5, 601]).(df.A), :]`.\n\n#### Column selection using `select` and `select!`, `transform` and `transform!`\n\nYou can also use the [`select`](@ref) and [`select!`](@ref) functions to select,\nrename and transform columns in a data frame.\n\nThe `select` function creates a new data frame:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6]) 2×3 DataFrame │ Row │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 3     │ 5     │ │ 2   │ 2     │ 4     │ 6     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, Not(:x1)) # drop column :x1 in a new data frame 2×2 DataFrame │ Row │ x2    │ y     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 3     │ 5     │ │ 2   │ 4     │ 6     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, r\"x\") # select columns containing 'x' character 2×2 DataFrame │ Row │ x1    │ x2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 3     │ │ 2   │ 2     │ 4     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, :x1 => :a1, :x2 => :a2) # rename columns 2×2 DataFrame │ Row │ a1    │ a2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 3     │ │ 2   │ 2     │ 4     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, :x1, :x2 => (x -> x .- minimum(x)) => :x2) # transform columns 2×2 DataFrame │ Row │ x1    │ x2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 0     │ │ 2   │ 2     │ 1     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, :x2, :x2 => ByRow(sqrt)) # transform columns by row 2×2 DataFrame │ Row │ x2    │ x2_sqrt │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 3     │ 1.73205 │ │ 2   │ 4     │ 2.0     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nIt is important to note that `select` always returns a data frame,\neven if a single column is selected (as opposed to indexing syntax).","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> select(df, :x1) 1×1 DataFrame │ Row │ x1    │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[:, :x1] 1-element Array{Int64,1}:  1","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nBy default `select` copies columns of a passed source data frame.\nIn order to avoid copying, pass `copycols=false`:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2 = select(df, :x1) 1×1 DataFrame │ Row │ x1    │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2.x1 === df.x1 false","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2 = select(df, :x1, copycols=false) 1×1 DataFrame │ Row │ x1    │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2.x1 === df.x1 true","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nTo perform the selection operation in-place use `select!`:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> select!(df, Not(:x1));","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df 1×2 DataFrame │ Row │ x2    │ y     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\n`transform` and `transform!` functions work identically to `select` and `select!` with the only difference that\nthey retain all columns that are present in the source data frame. Here are some more advanced examples.\n\nFirst we show how to generate a column that is a sum of all other columns in the data frame\nusing the `All()` selector:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6]) 2×3 DataFrame │ Row │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 3     │ 5     │ │ 2   │ 2     │ 4     │ 6     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> transform(df, All() => +) 2×4 DataFrame │ Row │ x1    │ x2    │ y     │ x1x2y_+ │ │     │ Int64 │ Int64 │ Int64 │ Int64     │ ├─────┼───────┼───────┼───────┼───────────┤ │ 1   │ 1     │ 3     │ 5     │ 9         │ │ 2   │ 2     │ 4     │ 6     │ 12        │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Using the `ByRow` wrapper, we can easily compute for each row the name of column with the highest score:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using Random","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> Random.seed!(1);","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(rand(10, 3), [:a, :b, :c]) 10×3 DataFrame │ Row │ a          │ b         │ c         │ │     │ Float64    │ Float64   │ Float64   │ ├─────┼────────────┼───────────┼───────────┤ │ 1   │ 0.236033   │ 0.555751  │ 0.0769509 │ │ 2   │ 0.346517   │ 0.437108  │ 0.640396  │ │ 3   │ 0.312707   │ 0.424718  │ 0.873544  │ │ 4   │ 0.00790928 │ 0.773223  │ 0.278582  │ │ 5   │ 0.488613   │ 0.28119   │ 0.751313  │ │ 6   │ 0.210968   │ 0.209472  │ 0.644883  │ │ 7   │ 0.951916   │ 0.251379  │ 0.0778264 │ │ 8   │ 0.999905   │ 0.0203749 │ 0.848185  │ │ 9   │ 0.251662   │ 0.287702  │ 0.0856352 │ │ 10  │ 0.986666   │ 0.859512  │ 0.553206  │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> transform(df, AsTable(:) => ByRow(argmax) => :prediction) 10×4 DataFrame │ Row │ a          │ b         │ c         │ prediction │ │     │ Float64    │ Float64   │ Float64   │ Symbol     │ ├─────┼────────────┼───────────┼───────────┼────────────┤ │ 1   │ 0.236033   │ 0.555751  │ 0.0769509 │ b          │ │ 2   │ 0.346517   │ 0.437108  │ 0.640396  │ c          │ │ 3   │ 0.312707   │ 0.424718  │ 0.873544  │ c          │ │ 4   │ 0.00790928 │ 0.773223  │ 0.278582  │ b          │ │ 5   │ 0.488613   │ 0.28119   │ 0.751313  │ c          │ │ 6   │ 0.210968   │ 0.209472  │ 0.644883  │ c          │ │ 7   │ 0.951916   │ 0.251379  │ 0.0778264 │ a          │ │ 8   │ 0.999905   │ 0.0203749 │ 0.848185  │ a          │ │ 9   │ 0.251662   │ 0.287702  │ 0.0856352 │ b          │ │ 10  │ 0.986666   │ 0.859512  │ 0.553206  │ a          │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"In the following, most complex, example below we compute row-wise sum, number of elements, and mean,\nwhile ignoring missing values.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using Statistics","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(x=[1, 2, missing], y=[1, missing, missing]);","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> transform(df, AsTable(:) .=>                      ByRow.([sum∘skipmissing,                              x -> count(!ismissing, x),                              mean∘skipmissing]) .=>                      [:sum, :n, :mean]) 3×5 DataFrame │ Row │ x       │ y       │ sum   │ n     │ mean    │ │     │ Int64?  │ Int64?  │ Int64 │ Int64 │ Float64 │ ├─────┼─────────┼─────────┼───────┼───────┼─────────┤ │ 1   │ 1       │ 1       │ 2     │ 2     │ 1.0     │ │ 2   │ 2       │ missing │ 2     │ 1     │ 2.0     │ │ 3   │ missing │ missing │ 0     │ 0     │ NaN     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nWhile the DataFrames.jl package provides basic data manipulation capabilities,\nusers are encouraged to use querying frameworks for more convenient and powerful operations:\n- the [Query.jl](https://github.com/davidanthoff/Query.jl) package provides a\n[LINQ](https://msdn.microsoft.com/en-us/library/bb397926.aspx)-like interface to a large number of data sources\n- the [DataFramesMeta.jl](https://github.com/JuliaStats/DataFramesMeta.jl)\npackage provides interfaces similar to LINQ and [dplyr](https://dplyr.tidyverse.org)\n\nSee the [Data manipulation frameworks](@ref) section for more information.\n\n### Summarizing Data\n\nThe `describe` function returns a data frame summarizing the elementary statistics and information about each column:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> describe(df) 2×8 DataFrame │ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │ │     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │ ├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤ │ 1   │ A        │ 2.5    │ 1   │ 2.5    │ 4   │         │          │ Int64    │ │ 2   │ B        │        │ F   │        │ M   │ 2       │          │ String   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nIf you are interested in describing only a subset of columns then the easiest way to do it is to\npass a subset of an original data frame to `describe` like this:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> describe(df[!, [:A])) 1×8 DataFrame │ Row │ variable │ mean    │ min   │ median  │ max   │ nunique │ nmissing │ eltype   │ │     │ Symbol   │ Float64 │ Int64 │ Float64 │ Int64 │ Nothing │ Nothing  │ DataType │ ├─────┼──────────┼─────────┼───────┼─────────┼───────┼─────────┼──────────┼──────────┤ │ 1   │ A        │ 2.5     │ 1     │ 2.5     │ 4     │         │          │ Int64    │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nOf course, one can also compute descriptive statistics directly on individual columns:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> using Statistics","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> mean(df.A) 2.5","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nWe can also apply a function to each column of a `DataFrame` using `select`. For example:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0) 4×2 DataFrame │ Row │ A     │ B       │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 1     │ 4.0     │ │ 2   │ 2     │ 3.0     │ │ 3   │ 3     │ 2.0     │ │ 4   │ 4     │ 1.0     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, names(df) .=> sum) 1×2 DataFrame │ Row │ Asum │ Bsum   │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 10    │ 10.0    │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, names(df) .=> sum, names(df) .=> prod) 1×4 DataFrame │ Row │ Asum │ Bsum   │ Aprod │ Bprod  │ │     │ Int64 │ Float64 │ Int64  │ Float64 │ ├─────┼───────┼─────────┼────────┼─────────┤ │ 1   │ 10    │ 10.0    │ 24     │ 24.0    │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\n### Handling of Columns Stored in a `DataFrame`\n\nFunctions that transform a `DataFrame` to produce a\nnew `DataFrame` always perform a copy of the columns by default, for example:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0) 4×2 DataFrame │ Row │ A     │ B       │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 1     │ 4.0     │ │ 2   │ 2     │ 3.0     │ │ 3   │ 3     │ 2.0     │ │ 4   │ 4     │ 1.0     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2 = copy(df);","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2.A === df.A false","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nOn the other hand, in-place functions, whose names end with `!`, may mutate the column vectors of the\n`DataFrame` they take as an argument, for example:\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> x = [3, 1, 2];","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(x=x) 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 3     │ │ 2   │ 1     │ │ 3   │ 2     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> sort!(df) 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │ │ 2   │ 2     │ │ 3   │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> x 3-element Array{Int64,1}:  1  2  3","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df.x[1] = 100 100","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 100   │ │ 2   │ 2     │ │ 3   │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> x 3-element Array{Int64,1}:  100    2    3","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nIn-place functions are safe to call, except when a view of the `DataFrame`\n(created via a `view`, `@view` or [`groupby`](@ref))\nor when a `DataFrame` created with `copycols=false` (or with the `DataFrame!` function)\nare in use.\n\nIt is possible to have a direct access to a column `col` of a `DataFrame` `df`\nusing the syntaxes `df.col`, `df[!, :col]`, via the [`eachcol`](@ref) function,\nby accessing a `parent` of a `view` of a column of a `DataFrame`,\nor simply by storing the reference to the column vector before the `DataFrame`\nwas created with `copycols=false` (or with the `DataFrame!` function).\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest dataframe julia> x = [3, 1, 2];","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(x=x) 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 3     │ │ 2   │ 1     │ │ 3   │ 2     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df.x == x true","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[1] !== x true","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> eachcol(df)[1] === df.x true","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nNote that a column obtained from a `DataFrame` using one of these methods should\nnot be mutated without caution.\n\nThe exact rules of handling columns of a `DataFrame` are explained in\n[The design of handling of columns of a `DataFrame`](@ref man-columnhandling) section of the manual.\n\n## Replacing Data\n\nSeveral approaches can be used to replace some values with others in a data frame. Some apply the replacement to all values in a data frame, and others to individual columns or subset of columns.\n\nDo note that in-place replacement requires that the replacement value can be converted to the column's element type. In particular, this implies that replacing a value with `missing` requires a call to `allowmissing!` if the column did not allow for missing values.\n\nReplacement operations affecting a single column can be performed using `replace!`:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest replace julia> df = DataFrame(a = [\"a\", \"None\", \"b\", \"None\"], b = 1:4, c = [\"None\", \"j\", \"k\", \"h\"], d = [\"x\", \"y\", \"None\", \"z\"]) 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ None   │ x      │ │ 2   │ None   │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ None   │ │ 4   │ None   │ 4     │ h      │ z      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> replace!(df.a, \"None\" => \"c\") 4-element Array{String,1}:  \"a\"  \"c\"  \"b\"  \"c\"","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ None   │ x      │ │ 2   │ c      │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ None   │ │ 4   │ c      │ 4     │ h      │ z      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"This is equivalent to `df.a = replace(df.a, \"None\" => \"c\")`, but operates in-place, without allocating a new column vector.\n\nReplacement operations on multiple columns or on the whole data frame can be performed in-place using the broadcasting syntax:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest replace","category":"page"},{"location":"man/getting_started/#replacement-on-a-subset-of-columns-[:c,-:d]-1","page":"Getting Started","title":"replacement on a subset of columns [:c, :d]","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[:, [:c, :d]] .= ifelse.(df[!, [:c, :d]] .== \"None\", \"c\", df[!, [:c, :d]]) 4×2 DataFrame │ Row │ c      │ d      │ │     │ String │ String │ ├─────┼────────┼────────┤ │ 1   │ c      │ x      │ │ 2   │ j      │ y      │ │ 3   │ k      │ c      │ │ 4   │ h      │ z      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ c      │ x      │ │ 2   │ c      │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ c      │ │ 4   │ c      │ 4     │ h      │ z      │","category":"page"},{"location":"man/getting_started/#replacement-on-entire-data-frame-1","page":"Getting Started","title":"replacement on entire data frame","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df .= ifelse.(df .== \"c\", \"None\", df) 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ None   │ x      │ │ 2   │ None   │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ None   │ │ 4   │ None   │ 4     │ h      │ z      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Do note that in the above examples, changing `.=` to just `=` will allocate new column vectors instead of applying the operation in-place.\n\nWhen replacing values with `missing`, if the columns do not already allow for missing values, one has to either avoid in-place operation and use `=` instead of `.=`, or call `allowmissing!` beforehand:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"jldoctest replace","category":"page"},{"location":"man/getting_started/#do-not-operate-in-place-(df-would-also-work)-1","page":"Getting Started","title":"do not operate in-place (df = would also work)","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2 = ifelse.(df .== \"None\", missing, df) 4×4 DataFrame │ Row │ a       │ b     │ c       │ d       │ │     │ String? │ Int64 │ String? │ String? │ ├─────┼─────────┼───────┼─────────┼─────────┤ │ 1   │ a       │ 1     │ missing │ x       │ │ 2   │ missing │ 2     │ j       │ y       │ │ 3   │ b       │ 3     │ k       │ missing │ │ 4   │ missing │ 4     │ h       │ z       │","category":"page"},{"location":"man/getting_started/#operate-in-place-after-allowing-for-missing-1","page":"Getting Started","title":"operate in-place after allowing for missing","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> allowmissing!(df) 4×4 DataFrame │ Row │ a       │ b      │ c       │ d       │ │     │ String? │ Int64? │ String? │ String? │ ├─────┼─────────┼────────┼─────────┼─────────┤ │ 1   │ a       │ 1      │ None    │ x       │ │ 2   │ None    │ 2      │ j       │ y       │ │ 3   │ b       │ 3      │ k       │ None    │ │ 4   │ None    │ 4      │ h       │ z       │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df .= ifelse.(df .== \"None\", missing, df) 4×4 DataFrame │ Row │ a       │ b     │ c       │ d       │ │     │ String? │ Int64 │ String? │ String? │ ├─────┼─────────┼───────┼─────────┼─────────┤ │ 1   │ a       │ 1     │ missing │ x       │ │ 2   │ missing │ 2     │ j       │ y       │ │ 3   │ b       │ 3     │ k       │ missing │ │ 4   │ missing │ 4     │ h       │ z       │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\n\n## Importing and Exporting Data (I/O)\n\nFor reading and writing tabular data from CSV and other delimited text files, use the [CSV.jl](https://github.com/JuliaData/CSV.jl) package.\n\nIf you have not used the CSV.jl package before then you may need to install it first:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia using Pkg Pkg.add(\"CSV\")","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nThe CSV.jl functions are not loaded automatically and must be imported into the session.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia using CSV","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nA dataset can now be read from a CSV file at path `input` using","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia DataFrame(CSV.File(input))","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"\nA `DataFrame` can be written to a CSV file at path `output` using","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia df = DataFrame(x = 1, y = 2) CSV.write(output, df) ```","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The behavior of CSV functions can be adapted via keyword arguments. For more information, see ?CSV.File, ?CSV.read and ?CSV.write, or checkout the online CSV.jl documentation.","category":"page"},{"location":"man/missing/#Missing-Data-1","page":"Missing Data","title":"Missing Data","text":"","category":"section"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"In Julia, missing values in data are represented using the special object missing, which is the single instance of the type Missing.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> missing\r\nmissing\r\n\r\njulia> typeof(missing)\r\nMissing\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The Missing type lets users create Vectors and DataFrame columns with missing values. Here we create a vector with a missing value and the element-type of the returned vector is Union{Missing, Int64}.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> x = [1, 2, missing]\r\n3-element Array{Union{Missing, Int64},1}:\r\n 1\r\n 2\r\n  missing\r\n\r\njulia> eltype(x)\r\nUnion{Missing, Int64}\r\n\r\njulia> Union{Missing, Int}\r\nUnion{Missing, Int64}\r\n\r\njulia> eltype(x) == Union{Missing, Int}\r\ntrue\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"missing values can be excluded when performing operations by using skipmissing, which returns a memory-efficient iterator.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> skipmissing(x)\r\nBase.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, 2, missing])\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The output of skipmissing can be passed directly into functions as an argument. For example, we can find the sum of all non-missing values or collect the non-missing values into a new missing-free vector.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> sum(skipmissing(x))\r\n3\r\n\r\njulia> collect(skipmissing(x))\r\n2-element Array{Int64,1}:\r\n 1\r\n 2\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The function coalesce can be used to replace missing values with another value (note the dot, indicating that the replacement should be applied to all entries in x):","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> coalesce.(x, 0)\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 0\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The functions dropmissing and dropmissing! can be used to remove the rows containing missing values from a DataFrame and either create a new DataFrame or mutate the original in-place respectively.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> df = DataFrame(i = 1:5,\r\n                      x = [missing, 4, missing, 2, 1],\r\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\r\n\r\njulia> dropmissing(df)\r\n2×3 DataFrame\r\n│ Row │ i     │ x      │ y       │\r\n│     │ Int64 │ Int64? │ String? │\r\n├─────┼───────┼────────┼─────────┤\r\n│ 1   │ 4     │ 2      │ d       │\r\n│ 2   │ 5     │ 1      │ e       │","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"One can specify the column(s) in which to search for rows containing missing values to be removed.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, :x)\r\n3×3 DataFrame\r\n│ Row │ i     │ x      │ y       │\r\n│     │ Int64 │ Int64? │ String? │\r\n├─────┼───────┼────────┼─────────┤\r\n│ 1   │ 2     │ 4      │ missing │\r\n│ 2   │ 4     │ 2      │ d       │\r\n│ 3   │ 5     │ 1      │ e       │","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"By default the dropmissing and dropmissing! functions keep the Union{T,Missing} element type in columns selected for row removal. To remove the Missing part, if present, set the disallowmissing option to true (it will become the default behavior in the future).","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, disallowmissing=true)\r\n2×3 DataFrame\r\n│ Row │ i     │ x     │ y      │\r\n│     │ Int64 │ Int64 │ String │\r\n├─────┼───────┼───────┼────────┤\r\n│ 1   │ 4     │ 2     │ d      │\r\n│ 2   │ 5     │ 1     │ e      │","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The Missings.jl package provides a few convenience functions to work with missing values.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The function Missings.replace returns an iterator which replaces missing elements with another value:","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> using Missings\r\n\r\njulia> Missings.replace(x, 1)\r\nMissings.EachReplaceMissing{Array{Union{Missing, Int64},1},Int64}(Union{Missing, Int64}[1, 2, missing], 1)\r\n\r\njulia> collect(Missings.replace(x, 1))\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 1\r\n\r\njulia> collect(Missings.replace(x, 1)) == coalesce.(x, 1)\r\ntrue\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The function nonmissingtype returns the element-type T in Union{T, Missing}.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> eltype(x)\r\nUnion{Int64, Missing}\r\n\r\njulia> nonmissingtype(eltype(x))\r\nInt64\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The missings function constructs Vectors and Arrays supporting missing values, using the optional first argument to specify the element-type.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> missings(1)\r\n1-element Array{Missing,1}:\r\n missing\r\n\r\njulia> missings(3)\r\n3-element Array{Missing,1}:\r\n missing\r\n missing\r\n missing\r\n\r\njulia> missings(1, 3)\r\n1×3 Array{Missing,2}:\r\n missing  missing  missing\r\n\r\njulia> missings(Int, 1, 3)\r\n1×3 Array{Union{Missing, Int64},2}:\r\n missing  missing  missing\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"See the Julia manual for more information about missing values.","category":"page"},{"location":"#DataFrames.jl-1","page":"Introduction","title":"DataFrames.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to the DataFrames documentation!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with tabular data manipulation using the DataFrames.jl package. For more illustrations of its usage in conjunction with other packages, the DataFrames Tutorial using Jupyter Notebooks is a good complementary resource.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If there is something you expect DataFrames to be capable of, but cannot figure out how to do, please reach out with questions in Domains/Data on Discourse.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please report bugs by opening an issue.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can follow the source links throughout the documentation to jump right to the source files on GitHub to make pull requests for improving the documentation and function capabilities.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please review DataFrames contributing guidelines before submitting your first PR!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Information on specific versions can be found on the Release page.","category":"page"},{"location":"#Package-Manual-1","page":"Introduction","title":"Package Manual","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"man/getting_started.md\",\n         \"man/joins.md\",\n         \"man/split_apply_combine.md\",\n         \"man/reshaping_and_pivoting.md\",\n         \"man/sorting.md\",\n         \"man/categorical.md\",\n         \"man/missing.md\",\n         \"man/querying_frameworks.md\"]\nDepth = 2","category":"page"},{"location":"#API-1","page":"Introduction","title":"API","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without DataFrames. qualifier after loading the DataFrames.jl package with using DataFrames) types and functions are considered a part of the public API of the DataFrames.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"All types and functions that are part of public API are guaranteed to go through a deprecation period before being changed or removed.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please be warned that while Julia allows you to access internal functions or types of DataFrames.jl these can change without warning between versions of DataFrames.jl. In particular it is not safe to directly access fields of types that are a part of public API of the DataFrames.jl package using e.g. the getfield function. Whenever some operation on fields of defined types is considered allowed an appropriate exported function should be used instead.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\", \"lib/indexing.md\"]\nDepth = 2","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\"]","category":"page"}]
}
