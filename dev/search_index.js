var documenterSearchIndex = {"docs":
[{"location":"man/querying_frameworks/#Data-manipulation-frameworks-1","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"","category":"section"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Two popular frameworks provide convenience methods to manipulate DataFrames: DataFramesMeta.jl and Query.jl. They implement a functionality similar to dplyr or LINQ.","category":"page"},{"location":"man/querying_frameworks/#DataFramesMeta.jl-1","page":"Data manipulation frameworks","title":"DataFramesMeta.jl","text":"","category":"section"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The DataFramesMeta.jl package provides a convenient yet fast macro-based interface to work with DataFrames.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"First install the DataFramesMeta.jl package:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"DataFramesMeta\")","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The major benefit of the package is that it allows you to refer to columns of a DataFrame as Symbols. Therefore instead of writing verylongdataframename.variable you can simply write :variable in expressions. Additionally you can chain a sequence of transformations of a DataFrame using the @linq macro.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Here is a minimal example of usage of the package. Observe that we refer to names of columns using only their names and that chaining is performed using the @linq macro and the |> operator:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, DataFramesMeta\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54., 34., 79.],\n                      children=[0, 2, 4])\n3×3 DataFrame\n│ Row │ name   │ age     │ children │\n│     │ String │ Float64 │ Int64    │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ John   │ 54.0    │ 0        │\n│ 2   │ Sally  │ 34.0    │ 2        │\n│ 3   │ Roger  │ 79.0    │ 4        │\n\njulia> @linq df |>\n           where(:age .> 40) |>\n           select(number_of_children=:children, :name)\n2×2 DataFrame\n│ Row │ number_of_children │ name   │\n│     │ Int64              │ String │\n├─────┼────────────────────┼────────┤\n│ 1   │ 0                  │ John   │\n│ 2   │ 4                  │ Roger  │","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"In the following examples we show that DataFramesMeta.jl also supports the split-apply-combine pattern:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> df = DataFrame(key=repeat(1:3, 4), value=1:12)\n12×2 DataFrame\n│ Row │ key   │ value │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 4     │\n│ 5   │ 2     │ 5     │\n│ 6   │ 3     │ 6     │\n│ 7   │ 1     │ 7     │\n│ 8   │ 2     │ 8     │\n│ 9   │ 3     │ 9     │\n│ 10  │ 1     │ 10    │\n│ 11  │ 2     │ 11    │\n│ 12  │ 3     │ 12    │\n\njulia> @linq df |>\n           where(:value .> 3) |>\n           by(:key, min=minimum(:value), max=maximum(:value)) |>\n           select(:key, range=:max - :min)\n3×2 DataFrame\n│ Row │ key   │ range │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 6     │\n│ 3   │ 3     │ 6     │\n\njulia> @linq df |>\n           groupby(:key) |>\n           transform(value0 = :value .- minimum(:value))\n12×3 DataFrame\n│ Row │ key   │ value │ value0 │\n│     │ Int64 │ Int64 │ Int64  │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 1     │ 1     │ 0      │\n│ 2   │ 1     │ 4     │ 3      │\n│ 3   │ 1     │ 7     │ 6      │\n│ 4   │ 1     │ 10    │ 9      │\n│ 5   │ 2     │ 2     │ 0      │\n│ 6   │ 2     │ 5     │ 3      │\n│ 7   │ 2     │ 8     │ 6      │\n│ 8   │ 2     │ 11    │ 9      │\n│ 9   │ 3     │ 3     │ 0      │\n│ 10  │ 3     │ 6     │ 3      │\n│ 11  │ 3     │ 9     │ 6      │\n│ 12  │ 3     │ 12    │ 9      │","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"You can find more details about how this package can be used on the DataFramesMeta.jl GitHub page.","category":"page"},{"location":"man/querying_frameworks/#Query.jl-1","page":"Data manipulation frameworks","title":"Query.jl","text":"","category":"section"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The Query.jl package provides advanced data manipulation capabilities for DataFrames (and many other data structures). This section provides a short introduction to the package, the Query.jl documentation has a more comprehensive documentation of the package.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"To get started, install the Query.jl package:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"using Pkg\nPkg.add(\"Query\")","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query is started with the @from macro and consists of a series of query commands. Query.jl provides commands that can filter, project, join, flatten and group data from a DataFrame. A query can return an iterator, or one can materialize the results of a query into a variety of data structures, including a new DataFrame.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A simple example of a query looks like this:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> using DataFrames, Query\n\njulia> df = DataFrame(name=[\"John\", \"Sally\", \"Roger\"],\n                      age=[54., 34., 79.],\n                      children=[0, 2, 4])\n3×3 DataFrame\n│ Row │ name   │ age     │ children │\n│     │ String │ Float64 │ Int64    │\n├─────┼────────┼─────────┼──────────┤\n│ 1   │ John   │ 54.0    │ 0        │\n│ 2   │ Sally  │ 34.0    │ 2        │\n│ 3   │ Roger  │ 79.0    │ 4        │\n\njulia> q1 = @from i in df begin\n            @where i.age > 40\n            @select {number_of_children=i.children, i.name}\n            @collect DataFrame\n       end\n2×2 DataFrame\n│ Row │ number_of_children │ name   │\n│     │ Int64              │ String │\n├─────┼────────────────────┼────────┤\n│ 1   │ 0                  │ John   │\n│ 2   │ 4                  │ Roger  │","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The query starts with the @from macro. The first argument i is the name of the range variable that will be used to refer to an individual row in later query commands. The next argument df is the data source that one wants to query. The @where command in this query will filter the source data by applying the filter condition i.age > 40. This filters out any rows in which the age column is not larger than 40. The @select command then projects the columns of the source data onto a new column structure. The example here applies three specific modifications: 1) it only keeps a subset of the columns in the source DataFrame, i.e. the age column will not be part of the transformed data; 2) it changes the order of the two columns that are selected; and 3) it renames one of the columns that is selected from children to number_of_children. The example query uses the {} syntax to achieve this. A {} in a Query.jl expression instantiates a new NamedTuple, i.e. it is a shortcut for writing @NT(number_of_children=>i.children, name=>i.name). The @collect statement determines the data structure that the query returns. In this example the results are returned as a DataFrame.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query without a @collect statement returns a standard julia iterator that can be used with any normal julia language construct that can deal with iterators. The following code returns a julia iterator for the query results:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q2 = @from i in df begin\n                   @where i.age > 40\n                   @select {number_of_children=i.children, i.name}\n              end; # suppress printing the iterator type\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"One can loop over the results using a standard julia for statement:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> total_children = 0\n0\n\njulia> for i in q2\n           global total_children += i.number_of_children\n       end\n\njulia> total_children\n4\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"Or one can use a comprehension to extract the name of a subset of rows:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> y = [i.name for i in q2 if i.number_of_children > 0]\n1-element Array{String,1}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"The last example (extracting only the name and applying a second filter) could of course be completely expressed as a query expression:","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"julia> q3 = @from i in df begin\n            @where i.age > 40 && i.children > 0\n            @select i.name\n            @collect\n       end\n1-element Array{String,1}:\n \"Roger\"\n","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"A query that ends with a @collect statement without a specific type will materialize the query results into an array. Note also the difference in the @select statement: The previous queries all used the {} syntax in the @select statement to project results into a tabular format. The last query instead just selects a single value from each row in the @select statement.","category":"page"},{"location":"man/querying_frameworks/#","page":"Data manipulation frameworks","title":"Data manipulation frameworks","text":"These examples only scratch the surface of what one can do with Query.jl, and the interested reader is referred to the Query.jl documentation for more information.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/indexing/#Indexing-1","page":"Indexing","title":"Indexing","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Pages = [\"indexing.md\"]","category":"page"},{"location":"lib/indexing/#General-rules-1","page":"Indexing","title":"General rules","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following rules explain target functionality of how getindex, setindex!, view, and broadcasting are intended to work with DataFrame, SubDataFrame and DataFrameRow objects.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The rules for a valid type of index into a column are the following:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"a value, later denoted as col:\na Symbol;\nan Integer that is not Bool;\na vector, later denoted as cols:\na vector of Symbol (does not have to be a subtype of AbstractVector{Symbol});\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na regular expression, which gets expanded to a vector of matching column names;\na Not expression (see InvertedIndices.jl);\nan All or Between expression (see DataAPI.jl);\na colon literal :.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The rules for a valid type of index into a row are the following:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"a value, later denoted as row:\nan Integer that is not Bool;\na vector, later denoted as rows:\na vector of Integer other than Bool (does not have to be a subtype of AbstractVector{<:Integer});\na vector of Bool that has to be a subtype of AbstractVector{Bool};\na Not expression;\na colon literal :;\nan exclamation mark !.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Additionally it is allowed to index into an AbstractDataFrame using a two-dimensional CartesianIndex.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"In the descriptions below df represents a DataFrame, sdf is a SubDataFrame and dfr is a DataFrameRow.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":": always expands to axes(df, 1) or axes(sdf, 1).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"df.col works like df[!, col] and sdf.col works like sdf[!, col] in all cases except that df.col .= v and sdf.col .= v perform in-place broadcasting if col is present in df/sdf and is a valid identifier.","category":"page"},{"location":"lib/indexing/#getindex-and-view-1","page":"Indexing","title":"getindex and view","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of getindex and view operations depending on argument types.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions that the data is copied or reused without copying.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"For performance reasons, accessing, via getindex or view, a single row and multiple cols of a DataFrame, a SubDataFrame or a DataFrameRow always returns a DataFrameRow (which is a view type).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"getindex on DataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"df[row, col] -> the value contained in row row of column col, the same as df[!, col][row];\ndf[CartesianIndex(row, col)] -> the same as df[row,col];\ndf[row, cols] -> a DataFrameRow with parent df;\ndf[rows, col] -> a copy of the vector df[!, col] with only the entries corresponding to rows selected,                    the same as df[!, col][rows];\ndf[rows, cols] -> a DataFrame containing copies of columns cols with only the entries corresponding to rows selected;\ndf[!, col] -> the vector contained in column col returned without copying; the same as df.col if col is a valid identifier.\ndf[!, cols] -> create a new DataFrame with columns cols without copying of columns;                  the same as select(df, cols, copycols=false).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"view on DataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"@view df[row, col] -> a 0-dimensional view into df[!, col] in row row, the same as view(df[!, col], row);\n@view df[CartesianIndex(row, col)] -> the same as @view df[row, col];\n@view df[row, cols] -> the same as df[row, cols];\n@view df[rows, col] -> a view into df[!, col] with rows selected, the same as view(df[!, col], rows);\n@view df[rows, cols] -> a SubDataFrame with rows selected with parent df;\n@view df[!, col] -> a view into df[!, col]  with all rows.\n@view df[!, cols] -> the same as @view df[:, cols].","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"getindex on SubDataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"sdf[row, col] -> a value contained in row row of column col;\nsdf[CartesianIndex(row, col)] -> the same as sdf[row,col];\nsdf[row, cols] -> a DataFrameRow with parent parent(sdf);\nsdf[rows, col] -> a copy of sdf[!, col] with only rows rows selected, the same as sdf[!, col][rows];\nsdf[rows, cols] -> a DataFrame containing columns cols and sdf[rows, col] as a vector for each col in cols;\nsdf[!, col] -> a view of entries corresponding to sdf in the vector parent(sdf)[!, col];                  the same as sdf.col if col is a valid identifier.\nsdf[!, cols] -> create a new SubDataFrame with columns cols, the same parent as sdf, and the same rows selected;                   the same as select(sdf, cols, copycols=false).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"view on SubDataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"@view sdf[row, col] -> a 0-dimensional view into df[!, col] at row row, the same as view(sdf[!, col], row);\n@view sdf[CartesianIndex(row, col)] -> the same as @view sdf[row, col];\n@view sdf[row, cols] -> a DataFrameRow with parent parent(sdf);\n@view sdf[rows, col] -> a view into sdf[!, col] vector with rows selected, the same as view(sdf[!, col], rows);\n@view sdf[rows, cols] -> a SubDataFrame with parent parent(sdf);\n@view sdf[!, col] -> a view into sdf[!, col] vector with all rows.\n@view sdf[!, cols] -> the same as @view sdf[:, cols].","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"getindex on DataFrameRow:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"dfr[col] -> the value contained in column col of dfr; the same as dfr.col if col is a valid identifier;\ndfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"view on DataFrameRow:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"@view dfr[col] -> a 0-dimensional view into parent(dfr)[DataFrames.row(dfr), col];\n@view dfr[cols] -> a DataFrameRow with parent parent(dfr);","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that views created with columns selector set to : change their columns' count if columns are added/removed/renamed in the parent; if column selector is other than : then view points to selected columns by their number at the moment of creation of the view.","category":"page"},{"location":"lib/indexing/#setindex!-1","page":"Indexing","title":"setindex!","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following list specifies the behavior of setindex! operations depending on argument types.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"In particular a description explicitly mentions if the assignment is in-place.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that if a setindex! operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"setindex! on DataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"df[row, col] = v -> set value of col in row row to v in-place;\ndf[CartesianIndex(row, col)] = v -> the same as df[row, col] = v;\ndf[row, cols] = v -> set row row of columns cols in-place; the same as dfr = df[row, cols]; dfr[:] = v;\ndf[rows, col] = v -> set rows rows of column col in-place; v must be an AbstractVector;                        if rows is : and col is a Symbol that is not present in df then a new column                        in df is created and holds a copy of v; equivalent to df.col = copy(v) if col is a valid identifier;\ndf[rows, cols] = v -> set rows rows of columns cols in-place; v must be an AbstractMatrix or an AbstractDataFrame                     (in this case column names must match);\ndf[!, col] = v -> replaces col with v without copying                     (with the exception that if v is an AbstractRange it gets converted to a Vector);                     also if col is a Symbol that is not present in df then a new column in df is created and holds v;                     equivalent to df.col = v if col is a valid identifier;                     this is allowed if ncol(df) == 0 || length(v) == nrow(df);\ndf[!, cols] = v -> replaces existing columns cols in data frame df with copying;                      v must be an AbstractMatrix or an AbstractDataFrame                      (in the latter case column names must match);","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"setindex! on SubDataFrame:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"sdf[row, col] = v -> set value of col in row row to v in-place;\nsdf[CartesianIndex(row, col)] = v -> the same as sdf[row, col] = v;\nsdf[row, cols] = v -> the same as dfr = df[row, cols]; dfr[:] = v in-place;\nsdf[rows, col] = v -> set rows rows of column col, in-place; v must be an abstract vector;\nsdf[rows, cols] = v -> set rows rows of columns cols in-place;                          v can be an AbstractMatrix or v can be AbstractDataFrame when column names must match;","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] = v, sdf[!, cols] = v and sdf.col = v are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"setindex! on DataFrameRow:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"dfr[col] = v -> set value of col in row row to v in-place;                   equivalent to dfr.col = v if col is a valid identifier;\ndfr[cols] = v -> set values of entries in columns cols in dfr by elements of v in place;                    v can be:                    1) a Tuple or an AbstractArray,                       in which cases it must have a number of elements equal to length(dfr),                    2) an AbstractDict, in which case column names must match,                    3) a NamedTuple or DataFrameRow, in which case column names and order must match;","category":"page"},{"location":"lib/indexing/#Broadcasting-1","page":"Indexing","title":"Broadcasting","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The following broadcasting rules apply to AbstractDataFrame objects:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"AbstractDataFrame behaves in broadcasting like a two-dimensional collection compatible with matrices.\nIf an AbstractDataFrame takes part in broadcasting then a DataFrame is always produced as a result. In this case the requested broadcasting operation produces an object with exactly two dimensions. An exception is when an AbstractDataFrame is used only as a source of broadcast assignment into an object of dimensionality higher than two.\nIf multiple AbstractDataFrame objects take part in broadcasting then they have to have identical column names.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that if broadcasting assignment operation throws an error the target data frame may be partially changed so it is unsafe to use it afterwards (the column length correctness will be preserved).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Broadcasting DataFrameRow is currently not allowed (which is consistent with NamedTuple).","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"It is possible to assign a value to AbstractDataFrame and DataFrameRow objects using the .= operator. In such an operation AbstractDataFrame is considered as two-dimensional and DataFrameRow as single-dimensional.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"note: Note\nThe rule above means that, similar to single-dimensional objects in Base (e.g. vectors), DataFrameRow is considered to be column-oriented.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Additional rules:","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"in the df[CartesianIndex(row, col)] .= v, df[row, col] .= v syntaxes v is broadcasted into the contents of df[row, col] (this is consistent with Julia Base);\nin the df[row, cols] .= v syntaxes the assignment to df is performed in-place;\nin the df[rows, col] .= v and df[rows, cols] .= v syntaxes the assignment to df is performed in-place; if rows is : and col is Symbol and it is missing from df then a new column is allocated and added; the length of the column is always the value of nrow(df) before the assignment takes place;\nin the df[!, col] .= v syntax column col is replaced by a freshly allocated vector; if col is Symbol and it is missing from df then a new column is allocated added; the length of the column is always the value of nrow(df) before the assignment takes place;\nthe df[!, cols] .= v syntax replaces existing columns cols in data frame df with freshly allocated vectors;\ndf.col .= v syntax is allowed and performs in-place assignment to an existing vector df.col.\nin the sdf[CartesianIndex(row, col)] .= v, sdf[row, col] .= v and sdf[row, cols] .= v syntaxes the assignment to sdf is performed in-place;\nin the sdf[rows, col] .= v and sdf[rows, cols] .= v syntaxes the assignment to sdf is performed in-place;\nsdf.col .= v syntax is allowed and performs in-place assignment to an existing vector sdf.col.\ndfr.col .= v syntax is allowed and performs in-place assignment to a value extracted by dfr.col.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"Note that sdf[!, col] .= v and sdf[!, cols] .= v syntaxes are not allowed as sdf can be only modified in-place.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"If column indexing using Symbol names in cols is performed, the order of columns in the operation is specified by the order of names.","category":"page"},{"location":"lib/indexing/#Indexing-GroupedDataFrames-1","page":"Indexing","title":"Indexing GroupedDataFrames","text":"","category":"section"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"A GroupedDataFrame can behave as either an AbstractVector or AbstractDict depending on the type of index used. Integers (or arrays of them) trigger vector-like indexing while Tupless and NamedTuples trigger dictionary-like indexing. An intermediate between the two is the GroupKey type returned by keys(::GroupedDataFrame), which behaves similarly to a NamedTuple but has performance on par with integer indexing.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"The elements of a GroupedDataFrame are SubDataFrames of its parent.","category":"page"},{"location":"lib/indexing/#","page":"Indexing","title":"Indexing","text":"gd[i::Integer] -> Get the ith group.\ngd[a::AbstractArray{<:Integer}] -> Get a reduced GroupedDataFrame containing only the groups with indices in a.\ngd[key::NamedTuple] -> Get the group corresponding to the given values of the grouping columns. The fields of the NamedTuple must match the grouping columns columns passed to groupby (including order).\ngd[key::Tuple] -> Same as previous, but omitting the names on key.\nget(gd, key::Union{Tuple, NamedTuple}, default) -> Get group for key key, returning default if it does not exist.\ngd[key::GroupKey] -> Get the group corresponding to the GroupKey key (one of the elements of the vector returned by keys(::GroupedDataFrame)). This should be nearly as fast as integer indexing.","category":"page"},{"location":"man/reshaping_and_pivoting/#Reshaping-and-Pivoting-Data-1","page":"Reshaping","title":"Reshaping and Pivoting Data","text":"","category":"section"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Reshape data from wide to long format using the stack function:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> using DataFrames, CSV\n\njulia> iris = DataFrame(CSV.File(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\")));\n\njulia> first(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa        │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa        │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa        │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa        │\n│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa        │\n│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa        │\n\njulia> last(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ virginica     │\n│ 2   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ virginica     │\n│ 3   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ virginica     │\n│ 4   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ virginica     │\n│ 5   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ virginica     │\n│ 6   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ virginica     │\n\njulia> d = stack(iris, 1:4);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"The second optional argument to stack indicates the columns to be stacked. These are normally referred to as the measured variables. Column names can also be given:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, [:SepalLength, :SepalWidth, :PetalLength, :PetalWidth]);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │\n","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Note that all columns can be of different types. Type promotion follows the rules of vcat.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"The stacked DataFrame that results includes all of the columns not specified to be stacked. These are repeated for each stacked column. These are normally refered to as identifier (id) columns. In addition to the id columns, two additional columns labeled :variable and :values contain the column identifier and the stacked columns.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"A third optional argument to stack represents the id columns that are repeated. This makes it easier to specify which variables you want included in the long format:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, [:SepalLength, :SepalWidth], :Species);\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ SepalWidth │ 3.3      │ virginica     │\n│ 2   │ SepalWidth │ 3.0      │ virginica     │\n│ 3   │ SepalWidth │ 2.5      │ virginica     │\n│ 4   │ SepalWidth │ 3.0      │ virginica     │\n│ 5   │ SepalWidth │ 3.4      │ virginica     │\n│ 6   │ SepalWidth │ 3.0      │ virginica     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"If you prefer to specify the id columns then use Not with stack like this:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, Not(:Species));\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> last(d, 6)\n6×3 DataFrame\n│ Row │ variable   │ value    │ Species       │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │\n├─────┼────────────┼──────────┼───────────────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"unstack converts from a long format to a wide format. The default is requires specifying which columns are an id variable, column variable names, and column values:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> iris.id = 1:size(iris, 1)\n1:150\n\njulia> longdf = stack(iris, Not([:Species, :id]));\n\njulia> first(longdf, 6)\n6×4 DataFrame\n│ Row │ variable    │ value    │ Species       │ id    │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼─────────────┼──────────┼───────────────┼───────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │ 1     │\n│ 2   │ SepalLength │ 4.9      │ setosa        │ 2     │\n│ 3   │ SepalLength │ 4.7      │ setosa        │ 3     │\n│ 4   │ SepalLength │ 4.6      │ setosa        │ 4     │\n│ 5   │ SepalLength │ 5.0      │ setosa        │ 5     │\n│ 6   │ SepalLength │ 5.4      │ setosa        │ 6     │\n\njulia> last(longdf, 6)\n6×4 DataFrame\n│ Row │ variable   │ value    │ Species       │ id    │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼────────────┼──────────┼───────────────┼───────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │ 145   │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │ 146   │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │ 147   │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │ 148   │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │ 149   │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │ 150   │\n\njulia> widedf = unstack(longdf, :id, :variable, :value);\n\njulia> first(widedf, 6)\n6×5 DataFrame\n│ Row │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ 1     │ 1.4         │ 0.2        │ 5.1         │ 3.5        │\n│ 2   │ 2     │ 1.4         │ 0.2        │ 4.9         │ 3.0        │\n│ 3   │ 3     │ 1.3         │ 0.2        │ 4.7         │ 3.2        │\n│ 4   │ 4     │ 1.5         │ 0.2        │ 4.6         │ 3.1        │\n│ 5   │ 5     │ 1.4         │ 0.2        │ 5.0         │ 3.6        │\n│ 6   │ 6     │ 1.7         │ 0.4        │ 5.4         │ 3.9        │\n\njulia> last(widedf, 6)\n6×5 DataFrame\n│ Row │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ 145   │ 5.7         │ 2.5        │ 6.7         │ 3.3        │\n│ 2   │ 146   │ 5.2         │ 2.3        │ 6.7         │ 3.0        │\n│ 3   │ 147   │ 5.0         │ 1.9        │ 6.3         │ 2.5        │\n│ 4   │ 148   │ 5.2         │ 2.0        │ 6.5         │ 3.0        │\n│ 5   │ 149   │ 5.4         │ 2.3        │ 6.2         │ 3.4        │\n│ 6   │ 150   │ 5.1         │ 1.8        │ 5.9         │ 3.0        │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"If the remaining columns are unique, you can skip the id variable and use:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> longdf = stack(iris, Not([:Species, :id]));\n\njulia> first(longdf, 6)\n6×4 DataFrame\n│ Row │ variable    │ value    │ Species       │ id    │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼─────────────┼──────────┼───────────────┼───────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │ 1     │\n│ 2   │ SepalLength │ 4.9      │ setosa        │ 2     │\n│ 3   │ SepalLength │ 4.7      │ setosa        │ 3     │\n│ 4   │ SepalLength │ 4.6      │ setosa        │ 4     │\n│ 5   │ SepalLength │ 5.0      │ setosa        │ 5     │\n│ 6   │ SepalLength │ 5.4      │ setosa        │ 6     │\n\njulia> widedf = unstack(longdf, :variable, :value);\n\njulia> first(widedf, 6)\n6×6 DataFrame\n│ Row │ Species       │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Categorical…⍰ │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ setosa        │ 1     │ 1.4         │ 0.2        │ 5.1         │ 3.5        │\n│ 2   │ setosa        │ 2     │ 1.4         │ 0.2        │ 4.9         │ 3.0        │\n│ 3   │ setosa        │ 3     │ 1.3         │ 0.2        │ 4.7         │ 3.2        │\n│ 4   │ setosa        │ 4     │ 1.5         │ 0.2        │ 4.6         │ 3.1        │\n│ 5   │ setosa        │ 5     │ 1.4         │ 0.2        │ 5.0         │ 3.6        │\n│ 6   │ setosa        │ 6     │ 1.7         │ 0.4        │ 5.4         │ 3.9        │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"You can even skip passing the :variable and :value values as positional arguments, as they will be used by default, and write:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> widedf = unstack(longdf);\n\njulia> first(widedf, 6)\n6×6 DataFrame\n│ Row │ Species       │ id    │ PetalLength │ PetalWidth │ SepalLength │ SepalWidth │\n│     │ Categorical…⍰ │ Int64 │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │\n├─────┼───────────────┼───────┼─────────────┼────────────┼─────────────┼────────────┤\n│ 1   │ setosa        │ 1     │ 1.4         │ 0.2        │ 5.1         │ 3.5        │\n│ 2   │ setosa        │ 2     │ 1.4         │ 0.2        │ 4.9         │ 3.0        │\n│ 3   │ setosa        │ 3     │ 1.3         │ 0.2        │ 4.7         │ 3.2        │\n│ 4   │ setosa        │ 4     │ 1.5         │ 0.2        │ 4.6         │ 3.1        │\n│ 5   │ setosa        │ 5     │ 1.4         │ 0.2        │ 5.0         │ 3.6        │\n│ 6   │ setosa        │ 6     │ 1.7         │ 0.4        │ 5.4         │ 3.9        │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Passing view=true to stack returns a data frame whose columns are views into the original wide data frame. Here is an example:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> d = stack(iris, view=true);\n\njulia> first(d, 6)\n6×4 DataFrame\n│ Row │ variable    │ value    │ Species       │ id    │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼─────────────┼──────────┼───────────────┼───────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │ 1     │\n│ 2   │ SepalLength │ 4.9      │ setosa        │ 2     │\n│ 3   │ SepalLength │ 4.7      │ setosa        │ 3     │\n│ 4   │ SepalLength │ 4.6      │ setosa        │ 4     │\n│ 5   │ SepalLength │ 5.0      │ setosa        │ 5     │\n│ 6   │ SepalLength │ 5.4      │ setosa        │ 6     │\n\njulia> last(d, 6)\n6×4 DataFrame\n│ Row │ variable   │ value    │ Species       │ id    │\n│     │ Symbol     │ Float64⍰ │ Categorical…⍰ │ Int64 │\n├─────┼────────────┼──────────┼───────────────┼───────┤\n│ 1   │ PetalWidth │ 2.5      │ virginica     │ 145   │\n│ 2   │ PetalWidth │ 2.3      │ virginica     │ 146   │\n│ 3   │ PetalWidth │ 1.9      │ virginica     │ 147   │\n│ 4   │ PetalWidth │ 2.0      │ virginica     │ 148   │\n│ 5   │ PetalWidth │ 2.3      │ virginica     │ 149   │\n│ 6   │ PetalWidth │ 1.8      │ virginica     │ 150   │","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"This saves memory. To create the view, several AbstractVectors are defined:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":":variable column – EachRepeatedVector This repeats the variables N times where N is the number of rows of the original AbstractDataFrame.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":":value column – StackedVector This is provides a view of the original columns stacked together.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"Id columns – RepeatedVector This repeats the original columns N times where N is the number of columns stacked.","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"None of these reshaping functions perform any aggregation. To do aggregation, use the split-apply-combine functions in combination with reshaping. Here is an example:","category":"page"},{"location":"man/reshaping_and_pivoting/#","page":"Reshaping","title":"Reshaping","text":"julia> using Statistics\n\njulia> d = stack(iris, Not(:Species));\n\njulia> first(d, 6)\n6×3 DataFrame\n│ Row │ variable    │ value    │ Species       │\n│     │ Symbol      │ Float64⍰ │ Categorical…⍰ │\n├─────┼─────────────┼──────────┼───────────────┤\n│ 1   │ SepalLength │ 5.1      │ setosa        │\n│ 2   │ SepalLength │ 4.9      │ setosa        │\n│ 3   │ SepalLength │ 4.7      │ setosa        │\n│ 4   │ SepalLength │ 4.6      │ setosa        │\n│ 5   │ SepalLength │ 5.0      │ setosa        │\n│ 6   │ SepalLength │ 5.4      │ setosa        │\n\njulia> x = by(d, [:variable, :Species], df -> DataFrame(vsum = mean(df.value)));\n\njulia> first(x, 6)\n\n6×3 DataFrame\n│ Row │ variable    │ Species       │ vsum    │\n│     │ Symbol      │ Categorical…⍰ │ Float64 │\n├─────┼─────────────┼───────────────┼─────────┤\n│ 1   │ SepalLength │ setosa        │ 5.006   │\n│ 2   │ SepalLength │ versicolor    │ 5.936   │\n│ 3   │ SepalLength │ virginica     │ 6.588   │\n│ 4   │ SepalWidth  │ setosa        │ 3.428   │\n│ 5   │ SepalWidth  │ versicolor    │ 2.77    │\n│ 6   │ SepalWidth  │ virginica     │ 2.974   │\n\njulia> first(unstack(x, :Species, :vsum), 6)\n5×4 DataFrame\n│ Row │ variable    │ setosa   │ versicolor │ virginica │\n│     │ Symbol      │ Float64⍰ │ Float64⍰   │ Float64⍰  │\n├─────┼─────────────┼──────────┼────────────┼───────────┤\n│ 1   │ PetalLength │ 1.462    │ 4.26       │ 5.552     │\n│ 2   │ PetalWidth  │ 0.246    │ 1.326      │ 2.026     │\n│ 3   │ SepalLength │ 5.006    │ 5.936      │ 6.588     │\n│ 4   │ SepalWidth  │ 3.428    │ 2.77       │ 2.974     │\n│ 5   │ id          │ 25.5     │ 75.5       │ 125.5     │","category":"page"},{"location":"man/categorical/#Categorical-Data-1","page":"Categorical Data","title":"Categorical Data","text":"","category":"section"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Often, we have to deal with factors that take on a small number of levels:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> v = [\"Group A\", \"Group A\", \"Group A\", \"Group B\", \"Group B\", \"Group B\"]\n6-element Array{String,1}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"The naive encoding used in an Array represents every entry of this vector as a full string. In contrast, we can represent the data more efficiently by replacing the strings with indices into a small pool of levels. This is what the CategoricalArray type does:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> using CategoricalArrays\n\njulia> cv = CategoricalArray(v)\n6-element CategoricalArray{String,1,UInt32}:\n \"Group A\"\n \"Group A\"\n \"Group A\"\n \"Group B\"\n \"Group B\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"CategoricalArrays support missing values.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = CategoricalArray([\"Group A\", missing, \"Group A\",\n                              \"Group B\", \"Group B\", missing])\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"In addition to representing repeated data efficiently, the CategoricalArray type allows us to determine efficiently the allowed levels of the variable at any time using the levels function (note that levels may or may not be actually used in the data):","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> levels(cv)\n2-element Array{String,1}:\n \"Group A\"\n \"Group B\"\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"The levels! function also allows changing the order of appearance of the levels, which can be useful for display purposes or when working with ordered variables.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> levels!(cv, [\"Group B\", \"Group A\"]);\n\njulia> levels(cv)\n2-element Array{String,1}:\n \"Group B\"\n \"Group A\"\n\njulia> sort(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt32}:\n \"Group B\"\n \"Group B\"\n \"Group A\"\n \"Group A\"\n missing\n missing\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"By default, a CategoricalArray is able to represent 2<sup>32</sup> different levels. You can use less memory by calling the compress function:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv = compress(cv)\n6-element CategoricalArray{Union{Missing, String},1,UInt8}:\n \"Group A\"\n missing\n \"Group A\"\n \"Group B\"\n \"Group B\"\n missing\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Instead of using the CategoricalArray constructor directly you can use categorical function. It additionally accepts one positional argument compress which when set to true is equivalent to calling compress on the new vector:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv1 = categorical([\"A\", \"B\"], true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"If the ordered keyword argument is set to true, the resulting CategoricalArray will be ordered, which means that its levels can be tested for order (rather than throwing an error):","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> cv2 = categorical([\"A\", \"B\"], true, ordered=true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> cv1[1] < cv1[2]\nERROR: ArgumentError: Unordered CategoricalValue objects cannot be tested for order using <. Use isless instead, or call the ordered! function on the parent array to change this\n\njulia> cv2[1] < cv2[2]\ntrue","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"You can check if a CategoricalArray is ordered using the isordered function and change between ordered and unordered using ordered! function.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> isordered(cv1)\nfalse\n\njulia> ordered!(cv1, true)\n2-element CategoricalArray{String,1,UInt8}:\n \"A\"\n \"B\"\n\njulia> isordered(cv1)\ntrue\n\njulia> cv1[1] < cv1[2]\ntrue","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Often, you will have factors encoded inside a DataFrame with Vector columns instead of CategoricalVector columns. You can convert one or more columns of the DataFrame using the categorical! function, which modifies the input DataFrame in-place. Compression can be applied by setting the compress keyword argument to true.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = [\"A\", \"B\", \"C\", \"D\", \"D\", \"A\"],\n                      B = [\"X\", \"X\", \"X\", \"Y\", \"Y\", \"Y\"])\n6×2 DataFrame\n│ Row │ A      │ B      │\n│     │ String │ String │\n├─────┼────────┼────────┤\n│ 1   │ A      │ X      │\n│ 2   │ B      │ X      │\n│ 3   │ C      │ X      │\n│ 4   │ D      │ Y      │\n│ 5   │ D      │ Y      │\n│ 6   │ A      │ Y      │\n\njulia> categorical!(df, :A) # change the column `:A` to be categorical\n6×2 DataFrame\n│ Row │ A            │ B      │\n│     │ Categorical… │ String │\n├─────┼──────────────┼────────┤\n│ 1   │ A            │ X      │\n│ 2   │ B            │ X      │\n│ 3   │ C            │ X      │\n│ 4   │ D            │ Y      │\n│ 5   │ D            │ Y      │\n│ 6   │ A            │ Y      │","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"If columns are not specified, all columns with an AbstractString element type are converted to be categorical. In the example below we also enable compression:","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"julia> categorical!(df, compress=true)\n6×2 DataFrame\n│ Row │ A            │ B            │\n│     │ Categorical… │ Categorical… │\n├─────┼──────────────┼──────────────┤\n│ 1   │ A            │ X            │\n│ 2   │ B            │ X            │\n│ 3   │ C            │ X            │\n│ 4   │ D            │ Y            │\n│ 5   │ D            │ Y            │\n│ 6   │ A            │ Y            │\n\njulia> eltype.(eachcol(df))\n2-element Array{DataType,1}:\n CategoricalString{UInt8}\n CategoricalString{UInt8}\n","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"Using categorical arrays is important for working with the GLM package. When fitting regression models, CategoricalVector columns in the input are translated into 0/1 indicator columns in the ModelMatrix with one column for each of the levels of the CategoricalVector. This allows one to analyze categorical data efficiently.","category":"page"},{"location":"man/categorical/#","page":"Categorical Data","title":"Categorical Data","text":"See the CategoricalArrays package for more information regarding categorical arrays.","category":"page"},{"location":"man/sorting/#Sorting-1","page":"Sorting","title":"Sorting","text":"","category":"section"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"Sorting is a fundamental component of data analysis. Basic sorting is trivial: just calling sort! will sort all columns, in place:","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"julia> using DataFrames, CSV\n\njulia> iris = DataFrame(CSV.File(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\")));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ Iris-virginica │\n│ 2   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ Iris-virginica │\n│ 3   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 4   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ Iris-virginica │\n\njulia> sort!(iris);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.3         │ 3.0        │ 1.1         │ 0.1        │ Iris-setosa │\n│ 2   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.4         │ 3.0        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.4         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 7.7         │ 2.8        │ 6.7         │ 2.0        │ Iris-virginica │\n│ 2   │ 7.7         │ 3.0        │ 6.1         │ 2.3        │ Iris-virginica │\n│ 3   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n│ 4   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"Observe that all columns are taken into account lexicographically when sorting the DataFrame.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"You can also call the sort function to create a new DataFrame with freshly allocated sorted vectors.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"In sorting DataFrames, you may want to sort different columns with different options. Here are some examples showing most of the possible options:","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, rev = true);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │\n│ 2   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n│ 3   │ 7.7         │ 3.0        │ 6.1         │ 2.3        │ Iris-virginica │\n│ 4   │ 7.7         │ 2.8        │ 6.7         │ 2.0        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.4         │ 3.2        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 2   │ 4.4         │ 3.0        │ 1.3         │ 0.2        │ Iris-setosa │\n│ 3   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.3         │ 3.0        │ 1.1         │ 0.1        │ Iris-setosa │\n\njulia> sort!(iris, [:Species, :SepalWidth]);\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 4.5         │ 2.3        │ 1.3         │ 0.3        │ Iris-setosa │\n│ 2   │ 4.4         │ 2.9        │ 1.4         │ 0.2        │ Iris-setosa │\n│ 3   │ 5.0         │ 3.0        │ 1.6         │ 0.2        │ Iris-setosa │\n│ 4   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ Iris-virginica │\n│ 2   │ 7.2         │ 3.6        │ 6.1         │ 2.5        │ Iris-virginica │\n│ 3   │ 7.9         │ 3.8        │ 6.4         │ 2.0        │ Iris-virginica │\n│ 4   │ 7.7         │ 3.8        │ 6.7         │ 2.2        │ Iris-virginica │\n\njulia> sort!(iris, (order(:Species, by=length), order(:SepalLength, rev=true)));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.8         │ 4.0        │ 1.2         │ 0.2        │ Iris-setosa │\n│ 2   │ 5.7         │ 3.8        │ 1.7         │ 0.3        │ Iris-setosa │\n│ 3   │ 5.7         │ 4.4        │ 1.5         │ 0.4        │ Iris-setosa │\n│ 4   │ 5.5         │ 3.5        │ 1.3         │ 0.2        │ Iris-setosa │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species         │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰         │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────────┤\n│ 1   │ 5.1         │ 2.5        │ 3.0         │ 1.1        │ Iris-versicolor │\n│ 2   │ 5.0         │ 2.0        │ 3.5         │ 1.0        │ Iris-versicolor │\n│ 3   │ 5.0         │ 2.3        │ 3.3         │ 1.0        │ Iris-versicolor │\n│ 4   │ 4.9         │ 2.4        │ 3.3         │ 1.0        │ Iris-versicolor │","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"Keywords used above include rev (to sort in reverse), and by (to apply a function to values before comparing them). Each keyword can either be a single value, or can be a tuple or a vector, with values corresponding to individual columns.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"As an alternative to using a vector or tuple values you can use order to specify an ordering for a particular column within a set of columns.","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"The following two examples show two ways to sort the iris dataset with the same result: :Species will be ordered in reverse order, and within groups, rows will be sorted by increasing :PetalLength:","category":"page"},{"location":"man/sorting/#","page":"Sorting","title":"Sorting","text":"julia> sort!(iris, (:Species, :PetalLength), rev=(true, false));\n\njulia> julia> sort!(iris, (:Species, :PetalLength), rev=(true, false));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 4.9         │ 2.5        │ 4.5         │ 1.7        │ Iris-virginica │\n│ 2   │ 6.2         │ 2.8        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 3   │ 6.0         │ 3.0        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 4   │ 6.3         │ 2.7        │ 4.9         │ 1.8        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n│ 2   │ 5.1         │ 3.3        │ 1.7         │ 0.5        │ Iris-setosa │\n│ 3   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ Iris-setosa │\n│ 4   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ Iris-setosa │\n\njulia> sort!(iris, (order(:Species, rev=true), :PetalLength));\n\njulia> first(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species        │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰        │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼────────────────┤\n│ 1   │ 4.9         │ 2.5        │ 4.5         │ 1.7        │ Iris-virginica │\n│ 2   │ 6.2         │ 2.8        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 3   │ 6.0         │ 3.0        │ 4.8         │ 1.8        │ Iris-virginica │\n│ 4   │ 6.3         │ 2.7        │ 4.9         │ 1.8        │ Iris-virginica │\n\njulia> last(iris, 4)\n4×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species     │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ String⍰     │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼─────────────┤\n│ 1   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ Iris-setosa │\n│ 2   │ 5.1         │ 3.3        │ 1.7         │ 0.5        │ Iris-setosa │\n│ 3   │ 5.1         │ 3.8        │ 1.9         │ 0.4        │ Iris-setosa │\n│ 4   │ 4.8         │ 3.4        │ 1.9         │ 0.2        │ Iris-setosa │","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Pages = [\"types.md\"]","category":"page"},{"location":"lib/types/#Type-hierarchy-design-1","page":"Types","title":"Type hierarchy design","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractDataFrame is an abstract type that provides an interface for data frame types. It is not intended as a fully generic interface for working with tabular data, which is the role of interfaces defined by Tables.jl instead.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"DataFrame is the most fundamental subtype of AbstractDataFrame, which stores a set of columns as AbstractVector objects.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"SubDataFrame is an AbstractDataFrame subtype representing a view into a DataFrame. It stores only a reference to the parent DataFrame and information about which rows and columns from the parent are selected (both as integer indices referring to the parent). Typically it is created using the view function or is returned by indexing into a GroupedDataFrame object.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"GroupedDataFrame is a type that stores the result of a  grouping operation performed on an AbstractDataFrame. It is intended to be created as a result of a call to the groupby function.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"DataFrameRow is a view into a single row of an AbstractDataFrame. It stores only a reference to a parent DataFrame and information about which row and columns from the parent are selected (both as integer indices referring to the parent) The DataFrameRow type supports iteration over columns of the row and is similar in functionality to the NamedTuple type, but allows for modification of data stored in the parent DataFrame and reflects changes done to the parent after the creation of the view. Typically objects of the DataFrameRow type are encountered when returned by the eachrow function, or when accessing a single row of a DataFrame or SubDataFrame via getindex or view.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The eachrow function returns a value of the DataFrameRows type, which serves as an iterator over rows of an AbstractDataFrame, returning DataFrameRow objects.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Similarly, the eachcol function returns a value of the DataFrameColumns type, which serves as an iterator over columns of an AbstractDataFrame. The return value can have two concrete types:","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"If the eachcol function is called with the names argument set to true then it returns a value of the DataFrameColumns{<:AbstractDataFrame, Pair{Symbol, AbstractVector}} type, which is an iterator returning a pair containing the column name and the column vector.\nIf the eachcol function is called with names argument set to false (the default) then it returns a value of the DataFrameColumns{<:AbstractDataFrame, AbstractVector} type, which is an iterator returning the column vector only.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The DataFrameRows and DataFrameColumns types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but using the eachrow and eachcol functions.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"The RepeatedVector and StackedVector types are subtypes of AbstractVector and support its interface with the exception that they are read only. Note that they are not exported and should not be constructed directly, but they are columns of a DataFrame returned by stack with view=true.","category":"page"},{"location":"lib/types/#man-columnhandling-1","page":"Types","title":"The design of handling of columns of a DataFrame","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"When a DataFrame is constructed columns are copied by default. You can disable this behavior by setting copycols keyword argument to false or by using the DataFrame! function. The exception is if an AbstractRange is passed as a column, then it is always collected to a Vector.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Also functions that transform a DataFrame to produce a new DataFrame perform a copy of the columns, unless they are passed copycols=false (available only for functions that could perform a transformation without copying the columns). Examples of such functions are vcat, hcat, filter, dropmissing, join, getindex, copy or the DataFrame constructor mentioned above.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"On the contrary, functions that create a view of a DataFrame do not by definition make copies of the columns, and therefore require particular caution. This includes view, which returns a SubDataFrame or a DataFrameRow, and groupby, which returns a GroupedDataFrame.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"A partial exception to this rule is the stack function with view=true which creates a DataFrame that contains views of the columns from the source DataFrame.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"In-place functions whose names end with ! (like sort! or dropmissing!, setindex!, push!, append!) may mutate the column vectors of the DataFrame they take as an argument. These functions are safe to call due to the rules described above, except when a view of the DataFrame is in use (via a SubDataFrame, a DataFrameRow or a GroupedDataFrame). In the latter case, calling such a function on the parent might corrupt the view, which make trigger errors, silently return invalid data or even cause Julia to crash. The same caution applies when DataFrame was created using columns of another DataFrame without copying (for instance when copycols=false in functions such as DataFrame or hcat).","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"It is possible to have a direct access to a column col of a DataFrame df (e.g. this can be useful in performance critical code to avoid copying), using one of the following methods:","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"via the getproperty function using the syntax df.col;\nvia the getindex function using the syntax df[!, :col] (note this is in contrast to df[:, :col] which copies);\nby creating a DataFrameColumns object using the eachcol function;\nby calling the parent function on a view of a column of the DataFrame, e.g. parent(@view df[:, :col]);\nby storing the reference to the column before creating a DataFrame with copycols=false;","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"A column obtained from a DataFrame using one of the above methods should not be mutated without caution because:","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"resizing a column vector will corrupt its parent DataFrame and any associated views as methods only check the length of the column when it is added to the DataFrame and later assume that all columns have the same length;\nreordering values in a column vector (e.g. using sort!) will break the consistency of rows with other columns, which will also affect views (if any);\nchanging values contained in a column vector is acceptable as long as it is not used as a grouping column in a GroupedDataFrame created based on the DataFrame.","category":"page"},{"location":"lib/types/#Types-specification-1","page":"Types","title":"Types specification","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractDataFrame\nDataFrame\nDataFrameRow\nGroupedDataFrame\nGroupKey\nSubDataFrame\nDataFrameRows\nDataFrameColumns\nRepeatedVector\nStackedVector","category":"page"},{"location":"lib/types/#DataFrames.AbstractDataFrame","page":"Types","title":"DataFrames.AbstractDataFrame","text":"AbstractDataFrame\n\nAn abstract type for which all concrete types expose an interface for working with tabular data.\n\nCommon methods\n\nAn AbstractDataFrame is a two-dimensional table with Symbols for column names. An AbstractDataFrame is also similar to an Associative type in that it allows indexing by a key (the columns).\n\nThe following are normally implemented for AbstractDataFrames:\n\ndescribe : summarize columns\nsummary : show number of rows and columns\nhcat : horizontal concatenation\nvcat : vertical concatenation\nrepeat : repeat rows\nnames : columns names\nrename! : rename columns names based on keyword arguments\nlength : number of columns\nsize : (nrows, ncols)\nfirst : first n rows\nlast : last n rows\nconvert : convert to an array\ncompletecases : boolean vector of complete cases (rows with no missings)\ndropmissing : remove rows with missing values\ndropmissing! : remove rows with missing values in-place\nnonunique : indexes of duplicate rows\nunique! : remove duplicate rows\ndisallowmissing : drop support for missing values in columns\nallowmissing : add support for missing values in columns\ncategorical : change column types to categorical\nsimilar : a DataFrame with similar columns as d\nfilter : remove rows\nfilter! : remove rows in-place\n\nIndexing and broadcasting\n\nAbstractDataFrame can be indexed by passing two indices specifying row and column selectors. The allowed indices are a superset of indices that can be used for standard arrays. You can also access a single column of an AbstractDataFrame using getproperty and setproperty! functions. In broadcasting AbstractDataFrame behavior is similar to a Matrix.\n\nA detailed description of getindex, setindex!, getproperty, setproperty!, broadcasting and broadcasting assignment for data frames is given in the \"Indexing\" section of the manual.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrame","page":"Types","title":"DataFrames.DataFrame","text":"DataFrame <: AbstractDataFrame\n\nAn AbstractDataFrame that stores a set of named columns\n\nThe columns are normally AbstractVectors stored in memory, particularly a Vector or CategoricalVector.\n\nConstructors\n\nDataFrame(columns::Vector, names::Vector{Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::NTuple{N,AbstractVector}, names::NTuple{N,Symbol};\n          makeunique::Bool=false, copycols::Bool=true)\nDataFrame(columns::Matrix, names::Vector{Symbol}; makeunique::Bool=false)\nDataFrame(kwargs...)\nDataFrame(pairs::NTuple{N, Pair{Symbol, AbstractVector}}; copycols::Bool=true)\nDataFrame() # an empty DataFrame\nDataFrame(column_eltypes::Vector, names::AbstractVector{Symbol}, nrows::Integer=0;\n          makeunique::Bool=false)\nDataFrame(ds::AbstractDict; copycols::Bool=true)\nDataFrame(table; makeunique::Bool=false, copycols::Bool=true)\nDataFrame(::Union{DataFrame, SubDataFrame}; copycols::Bool=true)\nDataFrame(::GroupedDataFrame)\n\nArguments\n\ncolumns : a Vector with each column as contents or a Matrix\nnames : the column names\nmakeunique : if false (the default), an error will be raised if duplicates in names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nkwargs : the key gives the column names, and the value is the column contents; note that the copycols keyword argument indicates if if vectors passed as columns should be copied so it is not possible to create a column whose name is :copycols using this constructor\nt : elemental type of all columns\nnrows, ncols : number of rows and columns\ncolumn_eltypes : element type of each column\ncategorical : a vector of Bool indicating which columns should be converted to                 CategoricalVector\nds : AbstractDict of columns\ntable : any type that implements the Tables.jl interface; in particular a tuple or vector of Pair{Symbol, <:AbstractVector}} objects is a table.\ncopycols : whether vectors passed as columns should be copied; if set to false then the constructor will still copy the passed columns if it is not possible to construct a DataFrame without materializing new columns.\n\nAll columns in columns should have the same length.\n\nNotes\n\nThe DataFrame constructor by default copies all columns vectors passed to it. Pass copycols=false to reuse vectors without copying them\n\nIf a column is passed to a DataFrame constructor or is assigned as a whole using setindex! then its reference is stored in the DataFrame. An exception to this rule is assignment of an AbstractRange as a column, in which case the range is collected to a Vector.\n\nBecause column types can vary, a DataFrame is not type stable. For performance-critical code, do not index into a DataFrame inside of loops.\n\nExamples\n\ndf = DataFrame()\nv = [\"x\",\"y\",\"z\"][rand(1:3, 10)]\ndf1 = DataFrame(Any[collect(1:10), v, rand(10)], [:A, :B, :C])\ndf2 = DataFrame(A = 1:10, B = v, C = rand(10))\nsummary(df1)\ndescribe(df2)\nfirst(df1, 10)\ndf1.B\ndf2[!, :C]\ndf1[:, :A]\ndf1[1:4, 1:2]\ndf1[Not(1:4), Not(1:2)]\ndf1[1:2, [:A,:C]]\ndf1[1:2, r\"[AC]\"]\ndf1[:, [:A,:C]]\ndf1[:, [1,3]]\ndf1[1:4, :]\ndf1[1:4, :C]\ndf1[1:4, :C] = 40. * df1[1:4, :C]\n[df1; df2]  # vcat\n[df1 df2]  # hcat\nsize(df1)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRow","page":"Types","title":"DataFrames.DataFrameRow","text":"DataFrameRow{<:AbstractDataFrame,<:AbstractIndex}\n\nA view of one row of an AbstractDataFrame.\n\nA DataFrameRow is returned by getindex or view functions when one row and a selection of columns are requested, or when iterating the result of the call to the eachrow function.\n\nThe DataFrameRow constructor can also be called directly:\n\nDataFrameRow(parent::AbstractDataFrame, row::Integer, cols=:)\n\nA DataFrameRow supports the iteration interface and can therefore be passed to functions that expect a collection as an argument.\n\nIndexing is one-dimensional like specifying a column of a DataFrame. You can also access the data in a DataFrameRow using the getproperty and setproperty! functions and convert it to a NamedTuple using the copy function.\n\nIt is possible to create a DataFrameRow with duplicate columns. All such columns will have a reference to the same entry in the parent DataFrame.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then DataFrameRow will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\ndf = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n               b = repeat([2, 1], outer=[4]),\n               c = randn(8))\nsdf1 = view(df, 2, :)\nsdf2 = @view df[end, [:a]]\nsdf3 = eachrow(df)[1]\nsdf4 = DataFrameRow(df, 2, 1:2)\nsdf5 = DataFrameRow(df, 1)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupedDataFrame","page":"Types","title":"DataFrames.GroupedDataFrame","text":"GroupedDataFrame\n\nThe result of a groupby operation on an AbstractDataFrame; a view into the AbstractDataFrame grouped by rows.\n\nNot meant to be constructed directly, see groupby.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.GroupKey","page":"Types","title":"DataFrames.GroupKey","text":"GroupKey{T<:GroupedDataFrame}\n\nKey for one of the groups of a GroupedDataFrame. Contains the values of the corresponding grouping columns and behaves similarly to a NamedTuple, but using it to index its GroupedDataFrame is much more effecient than using the equivalent Tuple or NamedTuple.\n\nInstances of this type are returned by keys(::GroupedDataFrame) and are not meant to be constructed directly.\n\nSee keys(::GroupedDataFrame) for more information.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.SubDataFrame","page":"Types","title":"DataFrames.SubDataFrame","text":"SubDataFrame{<:AbstractDataFrame,<:AbstractIndex,<:AbstractVector{Int}} <: AbstractDataFrame\n\nA view of an AbstractDataFrame. It is returned by a call to the view function on an AbstractDataFrame if a collections of rows and columns are specified.\n\nA SubDataFrame is an AbstractDataFrame, so expect that most DataFrame functions should work. Such methods include describe, summary, nrow, size, by, stack, and join.\n\nIndexing is just like a DataFrame except that it is possible to create a SubDataFrame with duplicate columns. All such columns will have a reference to the same entry in the parent DataFrame.\n\nIf the selection of columns in a parent data frame is passed as : (a colon) then SubDataFrame will always have all columns from the parent, even if they are added or removed after its creation.\n\nExamples\n\ndf = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n               b = repeat([2, 1], outer=[4]),\n               c = randn(8))\nsdf1 = view(df, 2:3) # column subsetting\nsdf2 = @view df[end:-1:1, [1,3]]  # row and column subsetting\nsdf3 = groupby(df, :a)[1]  # indexing a GroupedDataFrame returns a SubDataFrame\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameRows","page":"Types","title":"DataFrames.DataFrameRows","text":"DataFrameRows{D<:AbstractDataFrame} <: AbstractVector{DataFrameRow{D,S}}\n\nIterator over rows of an AbstractDataFrame, with each row represented as a DataFrameRow.\n\nA value of this type is returned by the eachrow function.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.DataFrameColumns","page":"Types","title":"DataFrames.DataFrameColumns","text":"DataFrameColumns{<:AbstractDataFrame, V} <: AbstractVector{V}\n\nIterator over columns of an AbstractDataFrame constructed using eachcol(df, true) if V is a Pair{Symbol,AbstractVector}. Then each returned value is a pair consisting of column name and column vector. If V is an AbstractVector (a value returned by eachcol(df, false)) then each returned value is a column vector.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.RepeatedVector","page":"Types","title":"DataFrames.RepeatedVector","text":"RepeatedVector{T} <: AbstractVector{T}\n\nAn AbstractVector that is a view into another AbstractVector with repeated elements\n\nNOTE: Not exported.\n\nConstructor\n\nRepeatedVector(parent::AbstractVector, inner::Int, outer::Int)\n\nArguments\n\nparent : the AbstractVector that's repeated\ninner : the numer of times each element is repeated\nouter : the numer of times the whole vector is repeated after expanded by inner\n\ninner and outer have the same meaning as similarly named arguments to repeat.\n\nExamples\n\nRepeatedVector([1,2], 3, 1)   # [1,1,1,2,2,2]\nRepeatedVector([1,2], 1, 3)   # [1,2,1,2,1,2]\nRepeatedVector([1,2], 2, 2)   # [1,2,1,2,1,2,1,2]\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#DataFrames.StackedVector","page":"Types","title":"DataFrames.StackedVector","text":"StackedVector <: AbstractVector{Any}\n\nAn AbstractVector{Any} that is a linear, concatenated view into another set of AbstractVectors\n\nNOTE: Not exported.\n\nConstructor\n\nStackedVector(d::AbstractVector...)\n\nArguments\n\nd... : one or more AbstractVectors\n\nExamples\n\nStackedVector(Any[[1,2], [9,10], [11,12]])  # [1,2,9,10,11,12]\n\n\n\n\n\n","category":"type"},{"location":"man/joins/#Database-Style-Joins-1","page":"Joins","title":"Database-Style Joins","text":"","category":"section"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"We often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> using DataFrames\n\njulia> people = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n│ 2   │ 40    │ Jane Doe │\n\njulia> jobs = DataFrame(ID = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 40    │ Doctor │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"We might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the join function:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> join(people, jobs, on = :ID)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n│ 2   │ 40    │ Jane Doe │ Doctor │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"There are seven kinds of joins supported by the DataFrames package:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Inner: The output contains rows for values of the key that exist in both the first (left) and second (right) arguments to join.\nLeft: The output contains rows for values of the key that exist in the first (left) argument to join, whether or not that value exists in the second (right) argument.\nRight: The output contains rows for values of the key that exist in the second (right) argument to join, whether or not that value exists in the first (left) argument.\nOuter: The output contains rows for values of the key that exist in the first (left) or second (right) argument to join.\nSemi: Like an inner join, but output is restricted to columns from the first (left) argument to join.\nAnti: The output contains rows for values of the key that exist in the first (left) but not the second (right) argument to join. As with semi joins, output is restricted to columns from the first (left) argument.\nCross: The output is the cartesian product of rows from the first (left) and second (right) arguments to join.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"See the Wikipedia page on SQL joins for more information.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"You can control the kind of join that join performs using the kind keyword argument:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> jobs = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Astronaut\"])\n2×2 DataFrame\n│ Row │ ID    │ Job       │\n│     │ Int64 │ String    │\n├─────┼───────┼───────────┤\n│ 1   │ 20    │ Lawyer    │\n│ 2   │ 60    │ Astronaut │\n\njulia> join(people, jobs, on = :ID, kind = :inner)\n1×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n\njulia> join(people, jobs, on = :ID, kind = :left)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job     │\n│     │ Int64 │ String   │ String⍰ │\n├─────┼───────┼──────────┼─────────┤\n│ 1   │ 20    │ John Doe │ Lawyer  │\n│ 2   │ 40    │ Jane Doe │ missing │\n\njulia> join(people, jobs, on = :ID, kind = :right)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job       │\n│     │ Int64 │ String⍰  │ String    │\n├─────┼───────┼──────────┼───────────┤\n│ 1   │ 20    │ John Doe │ Lawyer    │\n│ 2   │ 60    │ missing  │ Astronaut │\n\njulia> join(people, jobs, on = :ID, kind = :outer)\n3×3 DataFrame\n│ Row │ ID    │ Name     │ Job       │\n│     │ Int64 │ String⍰  │ String⍰   │\n├─────┼───────┼──────────┼───────────┤\n│ 1   │ 20    │ John Doe │ Lawyer    │\n│ 2   │ 40    │ Jane Doe │ missing   │\n│ 3   │ 60    │ missing  │ Astronaut │\n\njulia> join(people, jobs, on = :ID, kind = :semi)\n1×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n\njulia> join(people, jobs, on = :ID, kind = :anti)\n1×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 40    │ Jane Doe │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Cross joins are the only kind of join that does not use a key:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> join(people, jobs, kind = :cross, makeunique = true)\n4×4 DataFrame\n│ Row │ ID    │ Name     │ ID_1  │ Job       │\n│     │ Int64 │ String   │ Int64 │ String    │\n├─────┼───────┼──────────┼───────┼───────────┤\n│ 1   │ 20    │ John Doe │ 20    │ Lawyer    │\n│ 2   │ 20    │ John Doe │ 60    │ Astronaut │\n│ 3   │ 40    │ Jane Doe │ 20    │ Lawyer    │\n│ 4   │ 40    │ Jane Doe │ 60    │ Astronaut │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"In order to join data tables on keys which have different names in the left and right tables, you may pass (left, right) tuples or left => right pairs as on argument:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID = [20, 40], Name = [\"John Doe\", \"Jane Doe\"])\n2×2 DataFrame\n│ Row │ ID    │ Name     │\n│     │ Int64 │ String   │\n├─────┼───────┼──────────┤\n│ 1   │ 20    │ John Doe │\n│ 2   │ 40    │ Jane Doe │\n\njulia> b = DataFrame(IDNew = [20, 40], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ IDNew │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 40    │ Doctor │\n\njulia> join(a, b, on = :ID => :IDNew, kind = :inner)\n2×3 DataFrame\n│ Row │ ID    │ Name     │ Job    │\n│     │ Int64 │ String   │ String │\n├─────┼───────┼──────────┼────────┤\n│ 1   │ 20    │ John Doe │ Lawyer │\n│ 2   │ 40    │ Jane Doe │ Doctor │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Here is another example with multiple columns:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> a = DataFrame(City = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Job = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Category = [1, 2, 3, 4, 5])\n5×3 DataFrame\n│ Row │ City      │ Job    │ Category │\n│     │ String    │ String │ Int64    │\n├─────┼───────────┼────────┼──────────┤\n│ 1   │ Amsterdam │ Lawyer │ 1        │\n│ 2   │ London    │ Lawyer │ 2        │\n│ 3   │ London    │ Lawyer │ 3        │\n│ 4   │ New York  │ Doctor │ 4        │\n│ 5   │ New York  │ Doctor │ 5        │\n\njulia> b = DataFrame(Location = [\"Amsterdam\", \"London\", \"London\", \"New York\", \"New York\"],\n                     Work = [\"Lawyer\", \"Lawyer\", \"Lawyer\", \"Doctor\", \"Doctor\"],\n                     Name = [\"a\", \"b\", \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ Location  │ Work   │ Name   │\n│     │ String    │ String │ String │\n├─────┼───────────┼────────┼────────┤\n│ 1   │ Amsterdam │ Lawyer │ a      │\n│ 2   │ London    │ Lawyer │ b      │\n│ 3   │ London    │ Lawyer │ c      │\n│ 4   │ New York  │ Doctor │ d      │\n│ 5   │ New York  │ Doctor │ e      │\n\njulia> join(a, b, on = [(:City, :Location), (:Job, :Work)])\n9×4 DataFrame\n│ Row │ City      │ Job    │ Category │ Name   │\n│     │ String    │ String │ Int64    │ String │\n├─────┼───────────┼────────┼──────────┼────────┤\n│ 1   │ Amsterdam │ Lawyer │ 1        │ a      │\n│ 2   │ London    │ Lawyer │ 2        │ b      │\n│ 3   │ London    │ Lawyer │ 2        │ c      │\n│ 4   │ London    │ Lawyer │ 3        │ b      │\n│ 5   │ London    │ Lawyer │ 3        │ c      │\n│ 6   │ New York  │ Doctor │ 4        │ d      │\n│ 7   │ New York  │ Doctor │ 4        │ e      │\n│ 8   │ New York  │ Doctor │ 5        │ d      │\n│ 9   │ New York  │ Doctor │ 5        │ e      │\n","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Additionally, notice that in the last join rows 2 and 3 had the same values on on variables in both joined DataFrames. In such a situation :inner, :outer, :left and :right joins will produce all combinations of matching rows. In our example rows from 2 to 5 were created as a result. The same behavior can be observed for rows 4 and 5 in both joined DataFrames.","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"In order to check that columns passed as the on argument define unique keys (according to isequal) in each input data frame you can set the validate keyword argument to a two-element tuple or a pair of Bool values, with each element indicating whether to run check for the corresponding data frame. Here is an example for the join operation described above:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> join(a, b, on = [(:City, :Location), (:Job, :Work)], validate=(true, true))\nERROR: ArgumentError: Merge key(s) are not unique in both df1 and df2. First duplicate in df1 at 3. First duplicate in df2 at 3","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Finally, using the indicator keyword argument you can add a column to the resulting data frame indicating whether the given row appeared only in the left, the right or both data frames. Here is an example:","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"julia> a = DataFrame(ID = [20, 40], Name = [\"John\", \"Jane\"])\n2×2 DataFrame\n│ Row │ ID    │ Name   │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ John   │\n│ 2   │ 40    │ Jane   │\n\njulia> b = DataFrame(ID = [20, 60], Job = [\"Lawyer\", \"Doctor\"])\n2×2 DataFrame\n│ Row │ ID    │ Job    │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 20    │ Lawyer │\n│ 2   │ 60    │ Doctor │\n\njulia> join(a, b, on=:ID, validate=(true, true), indicator=:source, kind=:outer)\n3×4 DataFrame\n│ Row │ ID    │ Name    │ Job     │ source       │\n│     │ Int64 │ String⍰ │ String⍰ │ Categorical… │\n├─────┼───────┼─────────┼─────────┼──────────────┤\n│ 1   │ 20    │ John    │ Lawyer  │ both         │\n│ 2   │ 40    │ Jane    │ missing │ left_only    │\n│ 3   │ 60    │ missing │ Doctor  │ right_only   │","category":"page"},{"location":"man/joins/#","page":"Joins","title":"Joins","text":"Note that this time we also used the validate keyword argument and it did not produce errors as the keys defined in both source data frames were unique.","category":"page"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"CurrentModule = DataFrames","category":"page"},{"location":"lib/functions/#Functions-1","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/#Grouping,-Joining,-and-Split-Apply-Combine-1","page":"Functions","title":"Grouping, Joining, and Split-Apply-Combine","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"aggregate\nby\ncombine\ngroupby\ngroupindices\ngroupvars\nkeys\nget\njoin\nmap\nstack\nunstack","category":"page"},{"location":"lib/functions/#DataFrames.aggregate","page":"Functions","title":"DataFrames.aggregate","text":"aggregate(df::AbstractDataFrame, fs)\naggregate(df::AbstractDataFrame, cols, fs; sort=false, skipmissing=false)\naggregate(gd::GroupedDataFrame, fs; sort=false)\n\nSplit-apply-combine that applies a set of functions over columns of an AbstractDataFrame or GroupedDataFrame. Return an aggregated data frame.\n\nArguments\n\ndf : an AbstractDataFrame\ngd : a GroupedDataFrame\ncols : a column indicator (Symbol, Int, Vector{Symbol}, etc.)\nfs : a function or vector of functions to be applied to vectors within groups; expects each argument to be a column vector\nsort : whether to sort rows according to the values of the grouping columns\nskipmissing : whether to skip rows with missing values in one of the grouping columns cols\n\nEach fs should return a value or vector. All returns must be the same length.\n\nExamples\n\njulia> using Statistics\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> aggregate(df, :a, sum)\n4×3 DataFrame\n│ Row │ a     │ b_sum │ c_sum │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 4     │ 6     │\n│ 2   │ 2     │ 2     │ 8     │\n│ 3   │ 3     │ 4     │ 10    │\n│ 4   │ 4     │ 2     │ 12    │\n\njulia> aggregate(df, :a, [sum, x->mean(skipmissing(x))])\n4×5 DataFrame\n│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │\n│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │\n├─────┼───────┼───────┼───────┼────────────┼────────────┤\n│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │\n│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │\n│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │\n│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │\n\njulia> aggregate(groupby(df, :a), [sum, x->mean(skipmissing(x))])\n4×5 DataFrame\n│ Row │ a     │ b_sum │ c_sum │ b_function │ c_function │\n│     │ Int64 │ Int64 │ Int64 │ Float64    │ Float64    │\n├─────┼───────┼───────┼───────┼────────────┼────────────┤\n│ 1   │ 1     │ 4     │ 6     │ 2.0        │ 3.0        │\n│ 2   │ 2     │ 2     │ 8     │ 1.0        │ 4.0        │\n│ 3   │ 3     │ 4     │ 10    │ 2.0        │ 5.0        │\n│ 4   │ 4     │ 2     │ 12    │ 1.0        │ 6.0        │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.by","page":"Functions","title":"DataFrames.by","text":"by(df::AbstractDataFrame, keys, cols=>f...;\n   sort::Bool=false, skipmissing::Bool=false)\nby(df::AbstractDataFrame, keys; (colname = cols => f)...,\n   sort::Bool=false, skipmissing::Bool=false)\nby(df::AbstractDataFrame, keys, f;\n   sort::Bool=false, skipmissing::Bool=false)\nby(f, df::AbstractDataFrame, keys;\n   sort::Bool=false, skipmissing::Bool=false)\n\nSplit-apply-combine in one step: apply f to each grouping in df based on grouping columns keys, and return a DataFrame.\n\nkeys can be either a single column index, or a vector thereof.\n\nIf the last argument(s) consist(s) in one or more cols => f pair(s), or if colname = cols => f keyword arguments are provided, cols must be a column name or index, or a vector or tuple thereof, and f must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If cols is a single column index, f is called with a SubArray view into that column for each group; else, f is called with a named tuple holding SubArray views into these columns.\n\nIf the last argument is a callable f, it is passed a SubDataFrame view for each group, and the returned DataFrame then consists of the returned rows plus the grouping columns. If the returned data frame contains columns with the same names as the grouping columns, they are required to be equal. Note that this second form is much slower than the first one due to type instability. A method is defined with f as the first argument, so do-block notation can be used.\n\nf can return a single value, a row or multiple rows. In all cases, the resulting DataFrame contains all the grouping columns in addition to those generated by the application of f. The type of the returned value determines the shape of the resulting DataFrame, which is determined using the following rules:\n\nA single value gives a DataFrame with a single additional column and one row per group.\nA named tuple of single values or a DataFrameRow gives a DataFrame with one additional column for each field and one row per group.\nA vector gives a data frame with a single additional column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a DataFrame with the same additional columns and as many rows for each group as the rows returned for that group.\n\nf must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.\n\nAs a special case, if multiple pairs are passed as last arguments, each function is required to return a single value or vector, which will produce each a separate column.\n\nColumn names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input colummn name; for other functions, columns are called x1, x2 and so on. The resulting data frame will be sorted on keys if sort=true. Otherwise, ordering of rows is undefined. If skipmissing=true then the resulting data frame will not contain groups with missing values in one of the keys columns.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the pair syntax (e.g.col => sum). When computing thesumormeanover floating point columns, results will be less accurate than the standard [sum](@ref) function (which uses pairwise summation). Usecol => x -> sum(x)` to avoid the optimized method and use the slower, more accurate one.\n\nby(d, cols, f) is equivalent to combine(f, groupby(d, cols)) and to the less efficient combine(map(f, groupby(d, cols))).\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> by(df, :a, :c => sum)\n4×2 DataFrame\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a, d -> sum(d.c)) # Slower variant\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a) do d # do syntax for the slower variant\n           sum(d.c)\n       end\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> by(df, :a, :c => x -> 2 .* x)\n8×2 DataFrame\n│ Row │ a     │ c_function │\n│     │ Int64 │ Int64      │\n├─────┼───────┼────────────┤\n│ 1   │ 1     │ 2          │\n│ 2   │ 1     │ 10         │\n│ 3   │ 2     │ 4          │\n│ 4   │ 2     │ 12         │\n│ 5   │ 3     │ 6          │\n│ 6   │ 3     │ 14         │\n│ 7   │ 4     │ 8          │\n│ 8   │ 4     │ 16         │\n\njulia> by(df, :a, c_sum = :c => sum, c_sum2 = :c => x -> sum(x.^2))\n4×3 DataFrame\n│ Row │ a     │ c_sum │ c_sum2 │\n│     │ Int64 │ Int64 │ Int64  │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 1     │ 6     │ 26     │\n│ 2   │ 2     │ 8     │ 40     │\n│ 3   │ 3     │ 10    │ 58     │\n│ 4   │ 4     │ 12    │ 80     │\n\njulia> by(df, :a, (:b, :c) => x -> (minb = minimum(x.b), sumc = sum(x.c)))\n4×3 DataFrame\n│ Row │ a     │ minb  │ sumc  │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 6     │\n│ 2   │ 2     │ 1     │ 8     │\n│ 3   │ 3     │ 2     │ 10    │\n│ 4   │ 4     │ 1     │ 12    │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.combine","page":"Functions","title":"DataFrames.combine","text":"combine(gd::GroupedDataFrame, cols => f...)\ncombine(gd::GroupedDataFrame; (colname = cols => f)...)\ncombine(gd::GroupedDataFrame, f)\ncombine(f, gd::GroupedDataFrame)\n\nTransform a GroupedDataFrame into a DataFrame.\n\nIf the last argument(s) consist(s) in one or more cols => f pair(s), or if colname = cols => f keyword arguments are provided, cols must be a column name or index, or a vector or tuple thereof, and f must be a callable. A pair or a (named) tuple of pairs can also be provided as the first or last argument. If cols is a single column index, f is called with a SubArray view into that column for each group; else, f is called with a named tuple holding SubArray views into these columns.\n\nIf the last argument is a callable f, it is passed a SubDataFrame view for each group, and the returned DataFrame then consists of the returned rows plus the grouping columns. If the returned data frame contains columns with the same names as the grouping columns, they are required to be equal. Note that this second form is much slower than the first one due to type instability. A method is defined with f as the first argument, so do-block notation can be used.\n\nf can return a single value, a row or multiple rows. In all cases, the resulting DataFrame contains all the grouping columns in addition to those generated by the application of f. The type of the returned value determines the shape of the resulting DataFrame, which is determined using the following rules:\n\nA single value gives a DataFrame with a single additional column and one row per group.\nA named tuple of single values or a DataFrameRow gives a DataFrame with one additional column for each field and one row per group.\nA vector gives a data frame with a single additional column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives a DataFrame with the same additional columns and as many rows for each group as the rows returned for that group.\n\nf must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.\n\nAs a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.\n\nColumn names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called x1, x2 and so on. The resulting data frame will be sorted if sort=true was passed to the groupby call from which gd was constructed. Otherwise, ordering of rows is undefined.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the pair syntax (e.g. col => sum). When computing the sum or mean over floating point columns, results will be less accurate than the standard sum function (which uses pairwise summation). Use col => x -> sum(x) to avoid the optimized method and use the slower, more accurate one.\n\nSee also:\n\nby(f, df, cols) is a shorthand for combine(f, groupby(df, cols)).\nmap: combine(f, groupby(df, cols)) is a more efficient equivalent\n\nof combine(map(f, groupby(df, cols))).\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> combine(gd, :c => sum)\n4×2 DataFrame\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> combine(:c => sum, gd)\n4×2 DataFrame\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\njulia> combine(df -> sum(df.c), gd) # Slower variant\n4×2 DataFrame\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n│ 2   │ 2     │ 8     │\n│ 3   │ 3     │ 10    │\n│ 4   │ 4     │ 12    │\n\nSee by for more examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupby","page":"Functions","title":"DataFrames.groupby","text":"groupby(d::AbstractDataFrame, cols; sort=false, skipmissing=false)\n\nReturn a GroupedDataFrame representing a view of an AbstractDataFrame split into row groups.\n\nArguments\n\ndf : an AbstractDataFrame to split\ncols : data frame columns to group by\nsort : whether to sort rows according to the values of the grouping columns cols\nskipmissing : whether to skip rows with missing values in one of the grouping columns cols\n\nDetails\n\nAn iterator over a GroupedDataFrame returns a SubDataFrame view for each grouping into df. Within each group, the order of rows in df is preserved.\n\ncols can be any valid data frame indexing expression. In particular if it is an empty vector then a single-group GroupedDataFrame is created.\n\nA GroupedDataFrame also supports indexing by groups, map (which applies a function to each group) and combine (which applies a function to each group and combines the result into a data frame).\n\nSee the following for additional split-apply-combine operations:\n\nby : split-apply-combine using functions\naggregate : split-apply-combine; applies functions in the form of a cross product\nmap : apply a function to each group of a GroupedDataFrame (without combining)\ncombine : combine a GroupedDataFrame, optionally applying a function to each group\n\nGroupedDataFrame also supports the dictionary interface. The keys are GroupKey objects returned by keys(::GroupedDataFrame), which can also be used to get the values of the grouping columns for each group. Tuples and NamedTuples containing the values of the grouping columns (in the same order as the cols argument) are also accepted as indices, but this will be slower than using the equivalent GroupKey.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 4 groups based on key: a\nFirst Group (2 rows): a = 1\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n⋮\nLast Group (2 rows): a = 4\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\njulia> gd[1]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n\njulia> last(gd)\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\njulia> gd[(a=3,)]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n\njulia> gd[(3,)]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n\njulia> k = first(keys(gd))\nGroupKey: (a = 3)\n\njulia> gd[k]\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n\njulia> for g in gd\n           println(g)\n       end\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 1     │\n│ 2   │ 1     │ 2     │ 5     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 1     │ 2     │\n│ 2   │ 2     │ 1     │ 6     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 3     │ 2     │ 3     │\n│ 2   │ 3     │ 2     │ 7     │\n2×3 SubDataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 4     │ 1     │ 4     │\n│ 2   │ 4     │ 1     │ 8     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupindices","page":"Functions","title":"DataFrames.groupindices","text":"groupindices(gd::GroupedDataFrame)\n\nReturn a vector of group indices for each row of parent(gd).\n\nRows appearing in group gd[i] are attributed index i. Rows not present in any group are attributed missing (this can happen if skipmissing=true was passed when creating gd, or if gd is a subset from a larger GroupedDataFrame).\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.groupvars","page":"Functions","title":"DataFrames.groupvars","text":"groupvars(gd::GroupedDataFrame)\n\nReturn a vector of column names in parent(gd) used for grouping.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.keys","page":"Functions","title":"Base.keys","text":"keys(gd::GroupedDataFrame)\n\nGet the set of keys for each group of the GroupedDataFrame gd as a GroupKeys object. Each key is a GroupKey, which behaves like a NamedTuple holding the values of the grouping columns for a given group. Unlike the equivalent Tuple and NamedTuple, these keys can be used to index into gd efficiently. The ordering of the keys is identical to the ordering of the groups of gd under iteration and integer indexing.\n\nExamples\n\njulia> df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[4]),\n                      b = repeat([2, 1], outer=[6]),\n                      c = 1:12);\n\njulia> gd = groupby(df, [:a, :b])\nGroupedDataFrame with 6 groups based on keys: a, b\nFirst Group (2 rows): a = :foo, b = 2\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ foo    │ 2     │ 1     │\n│ 2   │ foo    │ 2     │ 7     │\n⋮\nLast Group (2 rows): a = :baz, b = 1\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ baz    │ 1     │ 6     │\n│ 2   │ baz    │ 1     │ 12    │\n\njulia> keys(gd)\n6-element DataFrames.GroupKeys{GroupedDataFrame{DataFrame}}:\n GroupKey: (a = :foo, b = 2)\n GroupKey: (a = :bar, b = 1)\n GroupKey: (a = :baz, b = 2)\n GroupKey: (a = :foo, b = 1)\n GroupKey: (a = :bar, b = 2)\n GroupKey: (a = :baz, b = 1)\n\nGroupKey objects behave similarly to NamedTuples:\n\njulia> k = keys(gd)[1]\nGroupKey: (a = :foo, b = 2)\n\njulia> keys(k)\n(:a, :b)\n\njulia> values(k)  # Same as Tuple(k)\n(:foo, 2)\n\njulia> NamedTuple(k)\n(a = :foo, b = 2)\n\njulia> k.a\n:foo\n\njulia> k[:a]\n:foo\n\njulia> k[1]\n:foo\n\nKeys can be used as indices to retrieve the corresponding group from their GroupedDataFrame:\n\njulia> gd[k]\n2×3 SubDataFrame\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ foo    │ 2     │ 1     │\n│ 2   │ foo    │ 2     │ 7     │\n\njulia> gd[keys(gd)[1]] == gd[1]\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.get","page":"Functions","title":"Base.get","text":"get(gd::GroupedDataFrame, key, default)\n\nGet a group based on the values of the grouping columns.\n\nkey may be a NamedTuple or Tuple of grouping column values (in the same order as the cols argument to groupby).\n\nExamples\n\njulia> df = DataFrame(a = repeat([:foo, :bar, :baz], outer=[2]),\n                      b = repeat([2, 1], outer=[3]),\n                      c = 1:6);\n\njulia> gd = groupby(df, :a)\nGroupedDataFrame with 3 groups based on key: a\nFirst Group (2 rows): a = :foo\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ foo    │ 2     │ 1     │\n│ 2   │ foo    │ 1     │ 4     │\n⋮\nLast Group (2 rows): a = :baz\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ baz    │ 2     │ 3     │\n│ 2   │ baz    │ 1     │ 6     │\n\njulia> get(gd, (a=:bar,), nothing)\n2×3 SubDataFrame\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ bar    │ 1     │ 2     │\n│ 2   │ bar    │ 2     │ 5     │\n\njulia> get(gd, (:baz,), nothing)\n2×3 SubDataFrame\n│ Row │ a      │ b     │ c     │\n│     │ Symbol │ Int64 │ Int64 │\n├─────┼────────┼───────┼───────┤\n│ 1   │ baz    │ 2     │ 3     │\n│ 2   │ baz    │ 1     │ 6     │\n\njulia> get(gd, (:qux,), nothing)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.join","page":"Functions","title":"Base.join","text":"join(df1, df2; on = Symbol[], kind = :inner, makeunique = false,\n     indicator = nothing, validate = (false, false))\njoin(df1, df2, dfs...; on = Symbol[], kind = :inner, makeunique = false,\n     validate = (false, false))\n\nJoin two or more DataFrame objects and return a DataFrame containing the result.\n\nArguments\n\ndf1, df2, dfs... : the AbstractDataFrames to be joined\n\nKeyword Arguments\n\non : A column name to join df1 and df2 on. If the columns on which df1 and df2 will be joined have different names, then a left=>right pair can be passed. It is also allowed to perform a join on multiple columns, in which case a vector of column names or column name pairs can be passed (mixing names and pairs is allowed). If more than two data frames are joined then only a column name or a vector of column names are allowed. on is a required argument for all joins except for kind = :cross.\nkind : the type of join, options include:\n:inner : only include rows with keys that match in both df1 and df2, the default\n:outer : include all rows from df1 and df2\n:left : include all rows from df1\n:right : include all rows from df2\n:semi : return rows of df1 that match with the keys in df2\n:anti : return rows of df1 that do not match with the keys in df2\n:cross : a full Cartesian product of the key combinations; every row of df1 is matched with every row of df2\nWhen joining more than two data frames only :inner, :outer and :cross joins are allowed.\nmakeunique : if false (the default), an error will be raised if duplicate names are found in columns not joined on; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\nindicator : Default: nothing. If a Symbol, adds categorical indicator  column named Symbol for whether a row appeared in only df1 (\"left_only\"),  only df2 (\"right_only\") or in both (\"both\"). If Symbol is already in use,  the column name will be modified if makeunique=true.  This argument is only supported when joining exactly two data frames.\nvalidate : whether to check that columns passed as the on argument  define unique keys in each input data frame (according to isequal).  Can be a tuple or a pair, with the first element indicating whether to  run check for df1 and the second element for df2.  By default no check is performed.\n\nFor the three join operations that may introduce missing values (:outer, :left, and :right), all columns of the returned data table will support missing values.\n\nWhen merging on categorical columns that differ in the ordering of their levels, the ordering of the left DataFrame takes precedence over the ordering of the right DataFrame.\n\nIf more than two data frames are passed, the join is performed recursively with left associativity. In this case the indicator keyword argument is not supported.\n\nExamples\n\nname = DataFrame(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\njob = DataFrame(ID = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\n\njoin(name, job, on = :ID)\njoin(name, job, on = :ID, kind = :outer)\njoin(name, job, on = :ID, kind = :left)\njoin(name, job, on = :ID, kind = :right)\njoin(name, job, on = :ID, kind = :semi)\njoin(name, job, on = :ID, kind = :anti)\njoin(name, job, kind = :cross)\n\njob2 = DataFrame(identifier = [1, 2, 4], Job = [\"Lawyer\", \"Doctor\", \"Farmer\"])\njoin(name, job2, on = :ID => :identifier)\njoin(name, job2, on = [:ID => :identifier])\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.map","page":"Functions","title":"Base.map","text":"map(cols => f, gd::GroupedDataFrame)\nmap(f, gd::GroupedDataFrame)\n\nApply a function to each group of rows and return a GroupedDataFrame.\n\nIf the first argument is a cols => f pair, cols must be a column name or index, or a vector or tuple thereof, and f must be a callable. If cols is a single column index, f is called with a SubArray view into that column for each group; else, f is called with a named tuple holding SubArray views into these columns.\n\nIf the first argument is a vector, tuple or named tuple of such pairs, each pair is handled as described above. If it is a named tuple then field names are used to name each generated column.\n\nIf the first argument is a callable f, it is passed a SubDataFrame view for each group, and the returned GroupedDataFrame then consists of the returned rows plus the grouping columns. If the table object returned  by f contains columns with the same names as the grouping columns, they are required to be equal. Note that this second form is much slower than the first one due to type instability.\n\nf can return a single value, a row or multiple rows. In all cases, the resulting GroupedDataFrame contains all the grouping columns in addition to those generated by the application of f. The type of the returned value determines the shape of the resulting groups in GroupedDataFrame, which is determined using the following rules:\n\nA single value gives a single additional column and one row per group.\nA named tuple of single values or a DataFrameRow gives one additional column for each field and one row per group.\nA vector gives a single additional column and as many rows for each group as the length of the returned vector for that group.\nA data frame, a named tuple of vectors or a matrix gives the same additional columns and as many rows for each group as the rows returned for that group.\n\nf must always return the same kind of object (as defined in the above list) for all groups, and if a named tuple or data frame, with the same fields or columns. Named tuples cannot mix single values and vectors. Due to type instability, returning a single value or a named tuple is dramatically faster than returning a data frame.\n\nAs a special case, if a tuple or vector of pairs is passed as the first argument, each function is required to return a single value or vector, which will produce each a separate column.\n\nColumn names are automatically generated when necessary: for functions operating on a single column and returning a single value or vector, the function name is appended to the input column name; for other functions, columns are called x1, x2 and so on.\n\nOptimized methods are used when standard summary functions (sum, prod, minimum, maximum, mean, var, std, first, last and length) are specified using the pair syntax (e.g. col => sum). When computing the sum or mean over floating point columns, results will be less accurate than the standard sum function (which uses pairwise summation). Use col => x -> sum(x) to avoid the optimized method and use the slower, more accurate one.\n\nSee also combine(f, gd) that returns a DataFrame rather than a GroupedDataFrame.\n\nExamples\n\njulia> df = DataFrame(a = repeat([1, 2, 3, 4], outer=[2]),\n                      b = repeat([2, 1], outer=[4]),\n                      c = 1:8);\n\njulia> gd = groupby(df, :a);\n\njulia> map(:c => sum, gd)\nGroupedDataFrame{DataFrame} with 4 groups based on key: :a\nFirst Group: 1 row\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n⋮\nLast Group: 1 row\n│ Row │ a     │ c_sum │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 12    │\n\njulia> map(df -> sum(df.c), gd) # Slower variant\nGroupedDataFrame{DataFrame} with 4 groups based on key: :a\nFirst Group: 1 row\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 6     │\n⋮\nLast Group: 1 row\n│ Row │ a     │ x1    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 4     │ 12    │\n\nSee by for more examples.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.stack","page":"Functions","title":"DataFrames.stack","text":"stack(df::AbstractDataFrame, [measure_vars], [id_vars];\n      variable_name::Symbol=:variable, value_name::Symbol=:value,\n      view::Bool=false, variable_eltype::Type=CategoricalString)\n\nStack a data frame df, i.e. convert it from wide to long format.\n\nReturn the long-format DataFrame with column variable_name (:value by default) holding the values of the stacked columns (measure_vars), with column variable_name (:variable by default) a vector holding the name of the corresponding measure_vars variable, and with columns for each of the id_vars.\n\nIf view=true then return a stacked view of a data frame (long format). The result is a view because the columns are special AbstractVectors that return views into the original data frame.\n\nArguments\n\ndf : the AbstractDataFrame to be stacked\nmeasure_vars : the columns to be stacked (the measurement variables), a normal column indexing type, like a Symbol, Vector{Symbol}, Int, etc.; If neither measure_vars or id_vars are given, measure_vars defaults to all floating point columns.\nid_vars : the identifier columns that are repeated during stacking, a normal column indexing type; defaults to all variables that are not measure_vars\nvariable_name : the name of the new stacked column that shall hold the names of each of measure_vars\nvalue_name : the name of the new stacked column containing the values from each of measure_vars\nview : whether the stacked data frame should be a view rather than contain  freshly allocated vectors.\nvariable_eltype : determines the element type of column variable_name. By default  a categorical vector of strings is created.  If variable_eltype=Symbol it is a vector of Symbol,  and if variable_eltype=String a vector of String is produced.\n\nExamples\n\nd1 = DataFrame(a = repeat([1:3;], inner = [4]),\n               b = repeat([1:4;], inner = [3]),\n               c = randn(12),\n               d = randn(12),\n               e = map(string, 'a':'l'))\n\nd1s = stack(d1, [:c, :d])\nd1s2 = stack(d1, [:c, :d], [:a])\nd1m = stack(d1, Not([:a, :b, :e]))\nd1s_name = stack(d1, Not([:a, :b, :e]), variable_name=:somemeasure)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.unstack","page":"Functions","title":"DataFrames.unstack","text":"unstack(df::AbstractDataFrame, rowkeys::Union{Integer, Symbol},\n        colkey::Union{Integer, Symbol}, value::Union{Integer, Symbol};\n        renamecols::Function=identity)\nunstack(df::AbstractDataFrame, rowkeys::AbstractVector{<:Union{Integer, Symbol}},\n        colkey::Union{Integer, Symbol}, value::Union{Integer, Symbol};\n        renamecols::Function=identity)\nunstack(df::AbstractDataFrame, colkey::Union{Integer, Symbol},\n        value::Union{Integer, Symbol}; renamecols::Function=identity)\nunstack(df::AbstractDataFrame; renamecols::Function=identity)\n\nUnstack data frame df, i.e. convert it from long to wide format.\n\nIf colkey contains missing values then they will be skipped and a warning will be printed.\n\nIf combination of rowkeys and colkey contains duplicate entries then last value will be retained and a warning will be printed.\n\nArguments\n\ndf : the AbstractDataFrame to be unstacked\nrowkeys : the column(s) with a unique key for each row, if not given, find a key by grouping on anything not a colkey or value\ncolkey : the column holding the column names in wide format, defaults to :variable\nvalue : the value column, defaults to :value\nrenamecols : a function called on each unique value in colkey which must                return the name of the column to be created (typically as a string                or a Symbol). Duplicate names are not allowed.\n\nExamples\n\nwide = DataFrame(id = 1:12,\n                 a  = repeat([1:3;], inner = [4]),\n                 b  = repeat([1:4;], inner = [3]),\n                 c  = randn(12),\n                 d  = randn(12))\n\nlong = stack(wide)\nwide0 = unstack(long)\nwide1 = unstack(long, :variable, :value)\nwide2 = unstack(long, :id, :variable, :value)\nwide3 = unstack(long, [:id, :a], :variable, :value)\nwide4 = unstack(long, :id, :variable, :value, renamecols=x->Symbol(:_, x))\n\nNote that there are some differences between the widened results above.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Basics-1","page":"Functions","title":"Basics","text":"","category":"section"},{"location":"lib/functions/#","page":"Functions","title":"Functions","text":"allowmissing\nallowmissing!\ncategorical\ncategorical!\ncompletecases\ncopy\nDataFrame!\ndeleterows!\ndescribe\ndisallowmissing\ndisallowmissing!\ndropmissing\ndropmissing!\neachrow\neachcol\nfilter\nfilter!\nflatten\nhcat\ninsertcols!\nmapcols\nnames\nnonunique\nnrow\nncol\nrename!\nrename\nrepeat\nselect\nselect!\nshow\nsort\nsort!\nunique!\nvcat\nappend!\npush!","category":"page"},{"location":"lib/functions/#Missings.allowmissing","page":"Functions","title":"Missings.allowmissing","text":"allowmissing(df::AbstractDataFrame,\n             cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon}=:)\n\nReturn a copy of data frame df with columns cols converted to element type Union{T, Missing} from T to allow support for missing values.\n\nIf cols is omitted all columns in the data frame are converted.\n\nExamples\n\njulia> df = DataFrame(a=[1,2])\n2×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n\njulia> allowmissing(df)\n2×1 DataFrame\n│ Row │ a      │\n│     │ Int64⍰ │\n├─────┼────────┤\n│ 1   │ 1      │\n│ 2   │ 2      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.allowmissing!","page":"Functions","title":"DataFrames.allowmissing!","text":"allowmissing!(df::DataFrame, cols::Colon=:)\nallowmissing!(df::DataFrame, cols::Union{Integer, Symbol})\nallowmissing!(df::DataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})\n\nConvert columns cols of data frame df from element type T to Union{T, Missing} to support missing values.\n\nIf cols is omitted all columns in the data frame are converted.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#CategoricalArrays.categorical","page":"Functions","title":"CategoricalArrays.categorical","text":"categorical(df::AbstractDataFrame, cols::Type=Union{AbstractString, Missing};\n            compress::Bool=false)\ncategorical(df::AbstractDataFrame,\n            cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon};\n            compress::Bool=false)\n\nReturn a copy of data frame df with columns cols converted to CategoricalVector. If categorical is called with the cols argument being a Type, then all columns whose element type is a subtype of this type (by default Union{AbstractString, Missing}) will be converted to categorical.\n\nIf the compress keyword argument is set to true then the created CategoricalVectors will be compressed.\n\nAll created CategoricalVectors are unordered.\n\nExamples\n\njulia> df = DataFrame(a=[1,2], b=[\"a\",\"b\"])\n2×2 DataFrame\n│ Row │ a     │ b      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ a      │\n│ 2   │ 2     │ b      │\n\njulia> categorical(df)\n2×2 DataFrame\n│ Row │ a     │ b            │\n│     │ Int64 │ Categorical… │\n├─────┼───────┼──────────────┤\n│ 1   │ 1     │ a            │\n│ 2   │ 2     │ b            │\n\njulia> categorical(df, :)\n2×2 DataFrame\n│ Row │ a            │ b            │\n│     │ Categorical… │ Categorical… │\n├─────┼──────────────┼──────────────┤\n│ 1   │ 1            │ a            │\n│ 2   │ 2            │ b            │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.categorical!","page":"Functions","title":"DataFrames.categorical!","text":"categorical!(df::DataFrame, cols::Type=Union{AbstractString, Missing};\n             compress::Bool=false)\ncategorical!(df::DataFrame, cname::Union{Integer, Symbol};\n             compress::Bool=false)\ncategorical!(df::DataFrame, cnames::Vector{<:Union{Integer, Symbol}};\n             compress::Bool=false)\ncategorical!(df::DataFrame, cnames::Union{Regex, Not, Between, All};\n             compress::Bool=false)\n\nChange columns selected by cname or cnames in data frame df to CategoricalVector.\n\nIf categorical! is called with the cols argument being a Type, then all columns whose element type is a subtype of this type (by default Union{AbstractString, Missing}) will be converted to categorical.\n\nIf the compress keyword argument is set to true then the created CategoricalVectors will be compressed.\n\nAll created CategoricalVectors are unordered.\n\nExamples\n\njulia> df = DataFrame(X=[\"a\", \"b\"], Y=[1, 2], Z=[\"p\", \"q\"])\n2×3 DataFrame\n│ Row │ X      │ Y     │ Z      │\n│     │ String │ Int64 │ String │\n├─────┼────────┼───────┼────────┤\n│ 1   │ a      │ 1     │ p      │\n│ 2   │ b      │ 2     │ q      │\n\njulia> categorical!(df)\n2×3 DataFrame\n│ Row │ X            │ Y     │ Z            │\n│     │ Categorical… │ Int64 │ Categorical… │\n├─────┼──────────────┼───────┼──────────────┤\n│ 1   │ a            │ 1     │ p            │\n│ 2   │ b            │ 2     │ q            │\n\njulia> eltype.(eachcol(df))\n3-element Array{DataType,1}:\n CategoricalString{UInt32}\n Int64\n CategoricalString{UInt32}\n\njulia> df = DataFrame(X=[\"a\", \"b\"], Y=[1, 2], Z=[\"p\", \"q\"])\n2×3 DataFrame\n│ Row │ X      │ Y     │ Z      │\n│     │ String │ Int64 │ String │\n├─────┼────────┼───────┼────────┤\n│ 1   │ a      │ 1     │ p      │\n│ 2   │ b      │ 2     │ q      │\n\njulia> categorical!(df, :Y, compress=true)\n2×3 DataFrame\n│ Row │ X      │ Y            │ Z      │\n│     │ String │ Categorical… │ String │\n├─────┼────────┼──────────────┼────────┤\n│ 1   │ a      │ 1            │ p      │\n│ 2   │ b      │ 2            │ q      │\n\njulia> eltype.(eachcol(df))\n3-element Array{DataType,1}:\n String\n CategoricalValue{Int64,UInt8}\n String\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.completecases","page":"Functions","title":"DataFrames.completecases","text":"completecases(df::AbstractDataFrame, cols::Colon=:)\ncompletecases(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All})\ncompletecases(df::AbstractDataFrame, cols::Union{Integer, Symbol})\n\nReturn a Boolean vector with true entries indicating rows without missing values (complete cases) in data frame df. If cols is provided, only missing values in the corresponding columns are considered.\n\nSee also: dropmissing and dropmissing!. Use findall(completecases(df)) to get the indices of the rows.\n\nExamples\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ i     │ x       │ y       │\n│     │ Int64 │ Int64⍰  │ String⍰ │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ missing │ missing │\n│ 2   │ 2     │ 4       │ missing │\n│ 3   │ 3     │ missing │ c       │\n│ 4   │ 4     │ 2       │ d       │\n│ 5   │ 5     │ 1       │ e       │\n\njulia> completecases(df)\n5-element BitArray{1}:\n false\n false\n false\n  true\n  true\n\njulia> completecases(df, :x)\n5-element BitArray{1}:\n false\n  true\n false\n  true\n  true\n\njulia> completecases(df, [:x, :y])\n5-element BitArray{1}:\n false\n false\n false\n  true\n  true\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.copy","page":"Functions","title":"Base.copy","text":"copy(df::DataFrame; copycols::Bool=true)\n\nCopy data frame df. If copycols=true (the default), return a new  DataFrame holding copies of column vectors in df. If copycols=false, return a new DataFrame sharing column vectors with df.\n\n\n\n\n\ncopy(dfr::DataFrameRow)\n\nConstruct a NamedTuple with the same contents as the DataFrameRow. This method returns a NamedTuple so that the returned object is not affected by changes to the parent data frame of which dfr is a view.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.DataFrame!","page":"Functions","title":"DataFrames.DataFrame!","text":"DataFrame!(args...; kwargs...)\n\nEquivalent to DataFrame(args...; copycols=false, kwargs...).\n\nIf kwargs contains the copycols keyword argument an error is thrown.\n\nExamples\n\njulia> df1 = DataFrame(a=1:3)\n3×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> df2 = DataFrame!(df1)\n\njulia> df1.a === df2.a\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.deleterows!","page":"Functions","title":"DataFrames.deleterows!","text":"deleterows!(df::DataFrame, inds)\n\nDelete rows specified by inds from a DataFrame df in place and return it.\n\nInternally deleteat! is called for all columns so inds must be: a vector of sorted and unique integers, a boolean vector or an integer.\n\nExamples\n\njulia> d = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> deleterows!(d, 2)\n2×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 3     │ 6     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataAPI.describe","page":"Functions","title":"DataAPI.describe","text":"describe(df::AbstractDataFrame; cols=:)\ndescribe(df::AbstractDataFrame, stats::Union{Symbol, Pair{<:Symbol}}...; cols=:)\n\nReturn descriptive statistics for a data frame as a new DataFrame where each row represents a variable and each column a summary statistic.\n\nArguments\n\ndf : the AbstractDataFrame\nstats::Union{Symbol, Pair{<:Symbol}}... : the summary statistics to report. Arguments can be:\nA symbol from the list :mean, :std, :min, :q25, :median, :q75, :max, :eltype, :nunique, :first, :last, and :nmissing. The default statistics used are :mean, :min, :median, :max, :nunique, :nmissing, and :eltype.\n:all as the only Symbol argument to return all statistics.\nA name => function pair where name is a Symbol. This will create a column of summary statistics with the provided name.\ncols : a keyword argument allowing to select only a subset of columns from df to describe; all standard column selection methods are allowed.\n\nDetails\n\nFor Real columns, compute the mean, standard deviation, minimum, first quantile, median, third quantile, and maximum. If a column does not derive from Real, describe will attempt to calculate all statistics, using nothing as a fall-back in the case of an error.\n\nWhen stats contains :nunique, describe will report the number of unique values in a column. If a column's base type derives from Real, :nunique will return nothings.\n\nMissing values are filtered in the calculation of all statistics, however the column :nmissing will report the number of missing values of that variable. If the column does not allow missing values, nothing is returned. Consequently, nmissing = 0 indicates that the column allows missing values, but does not currently contain any.\n\nIf custom functions are provided, they are called repeatedly with the vector corresponding to each column as the only argument. For columns allowing for missing values, the vector is wrapped in a call to skipmissing: custom functions must therefore support such objects (and not only vectors), and cannot access missing values.\n\nExamples\n\njulia> df = DataFrame(i=1:10, x=0.1:0.1:1.0, y='a':'j')\n10×3 DataFrame\n│ Row │ i     │ x       │ y    │\n│     │ Int64 │ Float64 │ Char │\n├─────┼───────┼─────────┼──────┤\n│ 1   │ 1     │ 0.1     │ 'a'  │\n│ 2   │ 2     │ 0.2     │ 'b'  │\n│ 3   │ 3     │ 0.3     │ 'c'  │\n│ 4   │ 4     │ 0.4     │ 'd'  │\n│ 5   │ 5     │ 0.5     │ 'e'  │\n│ 6   │ 6     │ 0.6     │ 'f'  │\n│ 7   │ 7     │ 0.7     │ 'g'  │\n│ 8   │ 8     │ 0.8     │ 'h'  │\n│ 9   │ 9     │ 0.9     │ 'i'  │\n│ 10  │ 10    │ 1.0     │ 'j'  │\n\njulia> describe(df)\n3×8 DataFrame\n│ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │\n│     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │\n├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤\n│ 1   │ i        │ 5.5    │ 1   │ 5.5    │ 10  │         │          │ Int64    │\n│ 2   │ x        │ 0.55   │ 0.1 │ 0.55   │ 1.0 │         │          │ Float64  │\n│ 3   │ y        │        │ 'a' │        │ 'j' │ 10      │          │ Char     │\n\njulia> describe(df, :min, :max)\n3×3 DataFrame\n│ Row │ variable │ min │ max │\n│     │ Symbol   │ Any │ Any │\n├─────┼──────────┼─────┼─────┤\n│ 1   │ i        │ 1   │ 10  │\n│ 2   │ x        │ 0.1 │ 1.0 │\n│ 3   │ y        │ 'a' │ 'j' │\n\njulia> describe(df, :min, :sum => sum)\n3×3 DataFrame\n│ Row │ variable │ min │ sum │\n│     │ Symbol   │ Any │ Any │\n├─────┼──────────┼─────┼─────┤\n│ 1   │ i        │ 1   │ 55  │\n│ 2   │ x        │ 0.1 │ 5.5 │\n│ 3   │ y        │ 'a' │     │\n\njulia> describe(df, :min, :sum => sum, cols=:x)\n1×3 DataFrame\n│ Row │ variable │ min     │ sum     │\n│     │ Symbol   │ Float64 │ Float64 │\n├─────┼──────────┼─────────┼─────────┤\n│ 1   │ x        │ 0.1     │ 5.5     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Missings.disallowmissing","page":"Functions","title":"Missings.disallowmissing","text":"disallowmissing(df::AbstractDataFrame,\n                cols::Union{ColumnIndex, AbstractVector, Regex, Not, Between, All, Colon}=:;\n                error::Bool=true)\n\nReturn a copy of data frame df with columns cols converted from element type Union{T, Missing} to T to drop support for missing values.\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\nExamples\n\njulia> df = DataFrame(a=Union{Int,Missing}[1,2])\n2×1 DataFrame\n│ Row │ a      │\n│     │ Int64⍰ │\n├─────┼────────┤\n│ 1   │ 1      │\n│ 2   │ 2      │\n\njulia> disallowmissing(df)\n2×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n\njulia> df = DataFrame(a=[1,missing]) 2×2 DataFrame │ Row │ a       │ b      │ │     │ Int64⍰  │ Int64⍰ │ ├─────┼─────────┼────────┤ │ 1   │ 1       │ 1      │ │ 2   │ missing │ 2      │\n\njulia> disallowmissing(df, error=false) 2×2 DataFrame │ Row │ a       │ b     │ │     │ Int64⍰  │ Int64 │ ├─────┼─────────┼───────┤ │ 1   │ 1       │ 1     │ │ 2   │ missing │ 2     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.disallowmissing!","page":"Functions","title":"DataFrames.disallowmissing!","text":"disallowmissing!(df::DataFrame, cols::Colon=:; error::Bool=true)\ndisallowmissing!(df::DataFrame, cols::Union{Integer, Symbol}; error::Bool=true)\ndisallowmissing!(df::DataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};\n                 error::Bool=true)\n\nConvert columns cols of data frame df from element type Union{T, Missing} to T to drop support for missing values.\n\nIf cols is omitted all columns in the data frame are converted.\n\nIf error=false then columns containing a missing value will be skipped instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing","page":"Functions","title":"DataFrames.dropmissing","text":"dropmissing(df::AbstractDataFrame, cols::Colon=:; disallowmissing::Bool=true)\ndropmissing(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};\n            disallowmissing::Bool=true)\ndropmissing(df::AbstractDataFrame, cols::Union{Integer, Symbol};\n            disallowmissing::Bool=true)\n\nReturn a copy of data frame df excluding rows with missing values. If cols is provided, only missing values in the corresponding columns are considered.\n\nIf disallowmissing is true (the default) then columns specified in cols will be converted so as not to allow for missing values using disallowmissing!.\n\nSee also: completecases and dropmissing!.\n\nExamples\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ i     │ x       │ y       │\n│     │ Int64 │ Int64⍰  │ String⍰ │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ missing │ missing │\n│ 2   │ 2     │ 4       │ missing │\n│ 3   │ 3     │ missing │ c       │\n│ 4   │ 4     │ 2       │ d       │\n│ 5   │ 5     │ 1       │ e       │\n\njulia> dropmissing(df)\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\njulia> dropmissing(df, disallowmissing=false)\n2×3 DataFrame\n│ Row │ i     │ x      │ y       │\n│     │ Int64 │ Int64⍰ │ String⍰ │\n├─────┼───────┼────────┼─────────┤\n│ 1   │ 4     │ 2      │ d       │\n│ 2   │ 5     │ 1      │ e       │\n\njulia> dropmissing(df, :x)\n3×3 DataFrame\n│ Row │ i     │ x     │ y       │\n│     │ Int64 │ Int64 │ String⍰ │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 2     │ 4     │ missing │\n│ 2   │ 4     │ 2     │ d       │\n│ 3   │ 5     │ 1     │ e       │\n\njulia> dropmissing(df, [:x, :y])\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.dropmissing!","page":"Functions","title":"DataFrames.dropmissing!","text":"dropmissing!(df::AbstractDataFrame, cols::Colon=:; disallowmissing::Bool=true)\ndropmissing!(df::AbstractDataFrame, cols::Union{AbstractVector, Regex, Not, Between, All};\n             disallowmissing::Bool=true)\ndropmissing!(df::AbstractDataFrame, cols::Union{Integer, Symbol};\n             disallowmissing::Bool=true)\n\nRemove rows with missing values from data frame df and return it. If cols is provided, only missing values in the corresponding columns are considered.\n\nIf disallowmissing is true (the default) then the cols columns will get converted using disallowmissing!.\n\nSee also: dropmissing and completecases.\n\njulia> df = DataFrame(i = 1:5,\n                      x = [missing, 4, missing, 2, 1],\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\n5×3 DataFrame\n│ Row │ i     │ x       │ y       │\n│     │ Int64 │ Int64⍰  │ String⍰ │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ missing │ missing │\n│ 2   │ 2     │ 4       │ missing │\n│ 3   │ 3     │ missing │ c       │\n│ 4   │ 4     │ 2       │ d       │\n│ 5   │ 5     │ 1       │ e       │\n\njulia> dropmissing!(copy(df))\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\njulia> dropmissing!(copy(df), disallowmissing=false)\n2×3 DataFrame\n│ Row │ i     │ x      │ y       │\n│     │ Int64 │ Int64⍰ │ String⍰ │\n├─────┼───────┼────────┼─────────┤\n│ 1   │ 4     │ 2      │ d       │\n│ 2   │ 5     │ 1      │ e       │\n\njulia> dropmissing!(copy(df), :x)\n3×3 DataFrame\n│ Row │ i     │ x     │ y       │\n│     │ Int64 │ Int64 │ String⍰ │\n├─────┼───────┼───────┼─────────┤\n│ 1   │ 2     │ 4     │ missing │\n│ 2   │ 4     │ 2     │ d       │\n│ 3   │ 5     │ 1     │ e       │\n\njulia> dropmissing!(df3, [:x, :y])\n2×3 DataFrame\n│ Row │ i     │ x     │ y      │\n│     │ Int64 │ Int64 │ String │\n├─────┼───────┼───────┼────────┤\n│ 1   │ 4     │ 2     │ d      │\n│ 2   │ 5     │ 1     │ e      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Compat.eachrow","page":"Functions","title":"Compat.eachrow","text":"eachrow(df::AbstractDataFrame)\n\nReturn a DataFrameRows that iterates a data frame row by row, with each row represented as a DataFrameRow.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 11    │\n│ 2   │ 2     │ 12    │\n│ 3   │ 3     │ 13    │\n│ 4   │ 4     │ 14    │\n\njulia> eachrow(df)\n4-element DataFrameRows:\n DataFrameRow (row 1)\nx  1\ny  11\n DataFrameRow (row 2)\nx  2\ny  12\n DataFrameRow (row 3)\nx  3\ny  13\n DataFrameRow (row 4)\nx  4\ny  14\n\njulia> copy.(eachrow(df))\n4-element Array{NamedTuple{(:x, :y),Tuple{Int64,Int64}},1}:\n (x = 1, y = 11)\n (x = 2, y = 12)\n (x = 3, y = 13)\n (x = 4, y = 14)\n\njulia> eachrow(view(df, [4,3], [2,1]))\n2-element DataFrameRows:\n DataFrameRow (row 4)\ny  14\nx  4\n DataFrameRow (row 3)\ny  13\nx  3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Compat.eachcol","page":"Functions","title":"Compat.eachcol","text":"eachcol(df::AbstractDataFrame, names::Bool=false)\n\nReturn a DataFrameColumns that iterates an AbstractDataFrame column by column. If names is equal to false (the default) iteration returns column vectors. If names is equal to true pairs consisting of column name and column vector are yielded.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 11    │\n│ 2   │ 2     │ 12    │\n│ 3   │ 3     │ 13    │\n│ 4   │ 4     │ 14    │\n\njulia> collect(eachcol(df))\n2-element Array{AbstractArray{T,1} where T,1}:\n [1, 2, 3, 4]\n [11, 12, 13, 14]\n\njulia> map(eachcol(df)) do col\n           maximum(col) - minimum(col)\n       end\n2-element Array{Int64,1}:\n 3\n 3\n\njulia> sum.(eachcol(df))\n2-element Array{Int64,1}:\n 10\n 50\n\njulia> collect(eachcol(df, true))\n2-element Array{Pair{Symbol,AbstractArray{T,1} where T},1}:\n :x => [1, 2, 3, 4]\n :y => [11, 12, 13, 14]\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter","page":"Functions","title":"Base.filter","text":"filter(function, df::AbstractDataFrame)\n\nReturn a copy of data frame df containing only rows for which function returns true. The function is passed a DataFrameRow as its only argument.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> filter(row -> row[:x] > 1, df)\n2×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.filter!","page":"Functions","title":"Base.filter!","text":"filter!(function, df::AbstractDataFrame)\n\nRemove rows from data frame df for which function returns false. The function is passed a DataFrameRow as its only argument.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> filter!(row -> row[:x] > 1, df);\n\njulia> df\n2×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.flatten","page":"Functions","title":"DataFrames.flatten","text":"flatten(df::AbstractDataFrame, col::Union{Integer, Symbol})\n\nWhen column col of data frame df has iterable elements that define length (for example a Vector of Vectors), return a DataFrame where each element of col is flattened, meaning the column corresponding to col becomes a longer Vector where the original entries are concatenated. Elements of row i of df in columns other than col will be repeated according to the length of df[i, col]. Note that these elements are not copied, and thus if they are mutable changing them in the returned DataFrame will affect df.\n\nExamples\n\njulia> df1 = DataFrame(a = [1, 2], b = [[1, 2], [3, 4]])\n2×2 DataFrame\n│ Row │ a     │ b      │\n│     │ Int64 │ Array… │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ [1, 2] │\n│ 2   │ 2     │ [3, 4] │\n\njulia> flatten(df1, :b)\n4×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 1     │ 2     │\n│ 3   │ 2     │ 3     │\n│ 4   │ 2     │ 4     │\n\njulia> df2 = DataFrame(a = [1, 2], b = [(\"p\", \"q\"), (\"r\", \"s\")])\n2×2 DataFrame\n│ Row │ a     │ b          │\n│     │ Int64 │ Tuple…     │\n├─────┼───────┼────────────┤\n│ 1   │ 1     │ (\"p\", \"q\") │\n│ 2   │ 2     │ (\"r\", \"s\") │\n\njulia> flatten(df2, :b)\n4×2 DataFrame\n│ Row │ a     │ b      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ p      │\n│ 2   │ 1     │ q      │\n│ 3   │ 2     │ r      │\n│ 4   │ 2     │ s      │\n\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.hcat","page":"Functions","title":"Base.hcat","text":"hcat(df::AbstractDataFrame...;\n     makeunique::Bool=false, copycols::Bool=true)\nhcat(df::AbstractDataFrame..., vs::AbstractVector;\n     makeunique::Bool=false, copycols::Bool=true)\nhcat(vs::AbstractVector, df::AbstractDataFrame;\n     makeunique::Bool=false, copycols::Bool=true)\n\nHorizontally concatenate AbstractDataFrames and optionally AbstractVectors.\n\nIf AbstractVector is passed then a column name for it is automatically generated as :x1 by default.\n\nIf makeunique=false (the default) column names of passed objects must be unique. If makeunique=true then duplicate column names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf copycols=true (the default) then the DataFrame returned by hcat will contain copied columns from the source data frames. If copycols=false then it will contain columns as they are stored in the source (without copying). This option should be used with caution as mutating either the columns in sources or in the returned DataFrame might lead to the corruption of the other object.\n\nExample\n\njulia [DataFrame(A=1:3) DataFrame(B=1:3)]\n3×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n\njulia> df1 = DataFrame(A=1:3, B=1:3);\n\njulia> df2 = DataFrame(A=4:6, B=4:6);\n\njulia> df3 = hcat(df1, df2, makeunique=true)\n3×4 DataFrame\n│ Row │ A     │ B     │ A_1   │ B_1   │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 4     │ 4     │\n│ 2   │ 2     │ 2     │ 5     │ 5     │\n│ 3   │ 3     │ 3     │ 6     │ 6     │\n\njulia> df3.A === df1.A\nfalse\n\njulia> df3 = hcat(df1, df2, makeunique=true, copycols=false);\n\njulia> df3.A === df1.A\ntrue\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.insertcols!","page":"Functions","title":"DataFrames.insertcols!","text":"insertcols!(df::DataFrame, ind::Int; name=col,\n            makeunique::Bool=false)\ninsertcols!(df::DataFrame, ind::Int, (:name => col)::Pair{Symbol,<:AbstractVector};\n            makeunique::Bool=false)\n\nInsert a column into a data frame in place. Return the updated DataFrame.\n\nArguments\n\ndf : the DataFrame to which we want to add a column\nind : a position at which we want to insert a column\nname : the name of the new column\ncol : an AbstractVector giving the contents of the new column\nmakeunique : Defines what to do if name already exists in df; if it is false an error will be thrown; if it is true a new unique name will be generated by adding a suffix\n\nExamples\n\njulia> d = DataFrame(a=1:3)\n3×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> insertcols!(d, 1, b=['a', 'b', 'c'])\n3×2 DataFrame\n│ Row │ b    │ a     │\n│     │ Char │ Int64 │\n├─────┼──────┼───────┤\n│ 1   │ 'a'  │ 1     │\n│ 2   │ 'b'  │ 2     │\n│ 3   │ 'c'  │ 3     │\n\njulia> insertcols!(d, 1, :c => [2, 3, 4])\n3×3 DataFrame\n│ Row │ c     │ b    │ a     │\n│     │ Int64 │ Char │ Int64 │\n├─────┼───────┼──────┼───────┤\n│ 1   │ 2     │ 'a'  │ 1     │\n│ 2   │ 3     │ 'b'  │ 2     │\n│ 3   │ 4     │ 'c'  │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.mapcols","page":"Functions","title":"DataFrames.mapcols","text":"mapcols(f::Union{Function,Type}, df::AbstractDataFrame)\n\nReturn a DataFrame where each column of df is transformed using function f. f must return AbstractVector objects all with the same length or scalars.\n\nNote that mapcols guarantees not to reuse the columns from df in the returned DataFrame. If f returns its argument then it gets copied before being stored.\n\nExamples\n\njulia> df = DataFrame(x=1:4, y=11:14)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 11    │\n│ 2   │ 2     │ 12    │\n│ 3   │ 3     │ 13    │\n│ 4   │ 4     │ 14    │\n\njulia> mapcols(x -> x.^2, df)\n4×2 DataFrame\n│ Row │ x     │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 121   │\n│ 2   │ 4     │ 144   │\n│ 3   │ 9     │ 169   │\n│ 4   │ 16    │ 196   │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.names","page":"Functions","title":"Base.names","text":"names(df::AbstractDataFrame)\n\nReturn a `Vector{Symbol}` of names of columns contained in `df`.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nonunique","page":"Functions","title":"DataFrames.nonunique","text":"nonunique(df::AbstractDataFrame)\nnonunique(df::AbstractDataFrame, cols)\n\nReturn a Vector{Bool} in which true entries indicate duplicate rows. A row is a duplicate if there exists a prior row with all columns containing equal values (according to isequal).\n\nSee also unique and unique!.\n\nArguments\n\ndf : the AbstractDataFrame\ncols : a column indicator (Symbol, Int, Vector{Symbol}, etc.) specifying the column(s) to compare\n\nExamples\n\ndf = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10))\ndf = vcat(df, df)\nnonunique(df)\nnonunique(df, 1)\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.nrow","page":"Functions","title":"DataFrames.nrow","text":"nrow(df::AbstractDataFrame)\nncol(df::AbstractDataFrame)\n\nReturn the number of rows or columns in an AbstractDataFrame df.\n\nSee also size.\n\nExamples\n\njulia> df = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10));\n\njulia> size(df)\n(10, 3)\n\njulia> nrow(df)\n10\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.ncol","page":"Functions","title":"DataFrames.ncol","text":"nrow(df::AbstractDataFrame)\nncol(df::AbstractDataFrame)\n\nReturn the number of rows or columns in an AbstractDataFrame df.\n\nSee also size.\n\nExamples\n\njulia> df = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10));\n\njulia> size(df)\n(10, 3)\n\njulia> nrow(df)\n10\n\njulia> ncol(df)\n3\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename!","page":"Functions","title":"DataFrames.rename!","text":"rename!(df::AbstractDataFrame, vals::AbstractVector{Symbol}; makeunique::Bool=false)\nrename!(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString}; makeunique::Bool=false)\nrename!(df::AbstractDataFrame, (from => to)::Pair...)\nrename!(df::AbstractDataFrame, d::AbstractDict)\nrename!(df::AbstractDataFrame, d::AbstractArray{<:Pair})\nrename!(f::Function, df::AbstractDataFrame)\n\nRename columns of df in-place. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column takes the old name (a Symbol) and returns the new name that gets converted to a Symbol\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename! (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nSee also: rename\n\nExamples\n\njulia> df = DataFrame(i = 1, x = 2, y = 3)\n1×3 DataFrame\n│ Row │ i     │ x     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df, Dict(:i => \"A\", :x => \"X\"))\n1×3 DataFrame\n│ Row │ A     │ X     │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df, [:a, :b, :c])\n1×3 DataFrame\n│ Row │ a     │ b     │ c     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df, [:a, :b, :a])\nERROR: ArgumentError: Duplicate variable names: :a. Pass makeunique=true to make them unique using a suffix automatically.\n\njulia> rename!(df, [:a, :b, :a], makeunique=true)\n1×3 DataFrame\n│ Row │ a     │ b     │ a_1   │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> rename!(df) do x\n           uppercase(string(x))\n       end\n1×3 DataFrame\n│ Row │ A     │ B     │ A_1   │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.rename","page":"Functions","title":"DataFrames.rename","text":"rename(df::AbstractDataFrame, vals::AbstractVector{Symbol}; makeunique::Bool=false)\nrename(df::AbstractDataFrame, vals::AbstractVector{<:AbstractString}; makeunique::Bool=false)\nrename(df::AbstractDataFrame, (from => to)::Pair...)\nrename(df::AbstractDataFrame, d::AbstractDict)\nrename(df::AbstractDataFrame, d::AbstractArray{<:Pair})\nrename(f::Function, df::AbstractDataFrame)\n\nCreate a new data frame that is a copy of df with changed column names. Each name is changed at most once. Permutation of names is allowed.\n\nArguments\n\ndf : the AbstractDataFrame\nd : an AbstractDict or an AbstractVector of Pairs that maps the original names or column numbers to new names\nf : a function which for each column takes the old name (a Symbol) and returns the new name that gets converted to a Symbol\nvals : new column names as a vector of Symbols or AbstractStrings of the same length as the number of columns in df\nmakeunique : if false (the default), an error will be raised if duplicate names are found; if true, duplicate names will be suffixed with _i (i starting at 1 for the first duplicate).\n\nIf pairs are passed to rename (as positional arguments or in a dictionary or a vector) then:\n\nfrom value can be a Symbol, an AbstractString or an Integer;\nto value can be a Symbol or an AbstractString.\n\nMixing symbols and strings in to and from is not allowed.\n\nSee also: rename!\n\nExamples\n\n```julia julia> df = DataFrame(i = 1, x = 2, y = 3) 1×3 DataFrame │ Row │ i     │ x     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, :i => :A, :x => :X) 1×3 DataFrame │ Row │ A     │ X     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, :x => :y, :y => :x) 1×3 DataFrame │ Row │ i     │ y     │ x     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, [1 => :A, 2 => :X]) 1×3 DataFrame │ Row │ A     │ X     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df, Dict(\"i\" => \"A\", \"x\" => \"X\")) 1×3 DataFrame │ Row │ A     │ X     │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │\n\njulia> rename(df) do x            uppercase(string(x))        end 1×3 DataFrame │ Row │ I     │ X     │ Y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │```\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.repeat","page":"Functions","title":"Base.repeat","text":"repeat(df::AbstractDataFrame; inner::Integer = 1, outer::Integer = 1)\n\nConstruct a data frame by repeating rows in df. inner specifies how many times each row is repeated, and outer specifies how many times the full set of rows is repeated.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 4     │\n\njulia> repeat(df, inner = 2, outer = 3)\n12×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 1     │ 3     │\n│ 3   │ 2     │ 4     │\n│ 4   │ 2     │ 4     │\n│ 5   │ 1     │ 3     │\n│ 6   │ 1     │ 3     │\n│ 7   │ 2     │ 4     │\n│ 8   │ 2     │ 4     │\n│ 9   │ 1     │ 3     │\n│ 10  │ 1     │ 3     │\n│ 11  │ 2     │ 4     │\n│ 12  │ 2     │ 4     │\n\n\n\n\n\nrepeat(df::AbstractDataFrame, count::Integer)\n\nConstruct a data frame by repeating each row in df the number of times specified by count.\n\nExample\n\njulia> df = DataFrame(a = 1:2, b = 3:4)\n2×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 4     │\n\njulia> repeat(df, 2)\n4×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 3     │\n│ 2   │ 2     │ 4     │\n│ 3   │ 1     │ 3     │\n│ 4   │ 2     │ 4     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select","page":"Functions","title":"DataFrames.select","text":"select(df::AbstractDataFrame, inds...; copycols::Bool=true)\n\nCreate a new data frame that contains columns from df specified by inds and return it.\n\nArguments passed as inds... can be any index that is allowed for column indexing provided that the columns requested in each of them are unique and present in df. In particular, regular expressions, All, Between, and Not selectors  are supported.\n\nIf more than one argument is passed then they are joined as All(inds...). Note that All selects the union of columns passed to it, so columns selected in different inds... do not have to be unique. For example a call select(df, :col, All()) is valid and creates a new data frame with column :col moved to be the first, provided it is present in df.\n\nIf df is a DataFrame return a new DataFrame that contains columns from df specified by inds. If copycols=true (the default), then returned DataFrame holds copies of column vectors in df. If copycols=false, then returned DataFrame shares column vectors with df.\n\nIf df is a SubDataFrame then a SubDataFrame is returned if copycols=false and a DataFrame with freshly allocated columns otherwise.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> select(df, :b)\n3×1 DataFrame\n│ Row │ b     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 4     │\n│ 2   │ 5     │\n│ 3   │ 6     │\n\njulia> select(df, Not(:b)) # drop column :b from df\n3×1 DataFrame\n│ Row │ a     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#DataFrames.select!","page":"Functions","title":"DataFrames.select!","text":"select!(df::DataFrame, inds...)\n\nMutate df in place to retain only columns specified by inds... and return it.\n\nArguments passed as inds... can be any index that is allowed for column indexing provided that the columns requested in each of them are unique and present in df. In particular, regular expressions, All, Between, and Not selectors are supported.\n\nIf more than one argument is passed then they are joined as All(inds...). Note that All selects the union of columns passed to it, so columns selected in different inds... do not have to be unique. For example a call select!(df, :col, All()) is valid and moves column :col in the data frame to be the first, provided it is present in df.\n\nExamples\n\njulia> df = DataFrame(a=1:3, b=4:6)\n3×2 DataFrame\n│ Row │ a     │ b     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 4     │\n│ 2   │ 2     │ 5     │\n│ 3   │ 3     │ 6     │\n\njulia> select!(df, 2)\n3×1 DataFrame\n│ Row │ b     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 4     │\n│ 2   │ 5     │\n│ 3   │ 6     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.show","page":"Functions","title":"Base.show","text":"show([io::IO,] df::AbstractDataFrame;\n     allrows::Bool = !get(io, :limit, false),\n     allcols::Bool = !get(io, :limit, false),\n     allgroups::Bool = !get(io, :limit, false),\n     splitcols::Bool = get(io, :limit, false),\n     rowlabel::Symbol = :Row,\n     summary::Bool = true)\n\nRender a data frame to an I/O stream. The specific visual representation chosen depends on the width of the display.\n\nIf io is omitted, the result is printed to stdout, and allrows, allcols and allgroups default to false while splitcols defaults to true.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\ndf::AbstractDataFrame: The data frame to print.\nallrows::Bool: Whether to print all rows, rather than a subset that fits the device height. By default this is the case only if io does not have the IOContext property limit set.\nallcols::Bool: Whether to print all columns, rather than a subset that fits the device width. By default this is the case only if io does not have the IOContext property limit set.\nallgroups::Bool: Whether to print all groups rather than the first and last, when df is a GroupedDataFrame. By default this is the case only if io does not have the IOContext property limit set.\nsplitcols::Bool: Whether to split printing in chunks of columns fitting the screen width rather than printing all columns in the same block. Only applies if allcols is true. By default this is the case only if io has the IOContext property limit set.\nrowlabel::Symbol = :Row: The label to use for the column containing row numbers.\nsummary::Bool = true: Whether to print a brief string summary of the data frame.\n\nExamples\n\njulia> using DataFrames\n\njulia> df = DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]);\n\njulia> show(df, allcols=true)\n3×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ x      │\n│ 2   │ 2     │ y      │\n│ 3   │ 3     │ z      │\n\n\n\n\n\nshow(io::IO, mime::MIME, df::AbstractDataFrame)\n\nRender a data frame to an I/O stream in MIME type mime.\n\nArguments\n\nio::IO: The I/O stream to which df will be printed.\nmime::MIME: supported MIME types are: \"text/plain\", \"text/html\", \"text/latex\", \"text/csv\", \"text/tab-separated-values\"\ndf::AbstractDataFrame: The data frame to print.\n\nAdditionally selected MIME types support passing the following keyword arguments:\n\nMIME type \"text/plain\" accepts all listed keyword arguments and therir behavior is identical as for show(::IO, ::AbstractDataFrame)\nMIME type \"text/html\" accepts summary keyword argument which allows to choose whether to print a brief string summary of the data frame.\n\nExamples\n\njulia> show(stdout, MIME(\"text/latex\"), DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]))\n\\begin{tabular}{r|cc}\n        & A & B\\\\\n        \\hline\n        & Int64 & String\\\\\n        \\hline\n        1 & 1 & x \\\\\n        2 & 2 & y \\\\\n        3 & 3 & z \\\\\n\\end{tabular}\n14\n\njulia> show(stdout, MIME(\"text/csv\"), DataFrame(A = 1:3, B = [\"x\", \"y\", \"z\"]))\n\"A\",\"B\"\n1,\"x\"\n2,\"y\"\n3,\"z\"\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort","page":"Functions","title":"Base.sort","text":"sort(df::AbstractDataFrame, cols;\n     alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n     rev::Bool=false, order::Ordering=Forward)\n\nReturn a copy of data frame df sorted by column(s) cols. cols can be either a Symbol or Integer column index, or a tuple or vector of such indices.\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See sort! for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> sort(df, :x)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort(df, (:x, :y))\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort(df, (:x, :y), rev=true)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n│ 3   │ 1     │ c      │\n│ 4   │ 1     │ b      │\n\njulia> sort(df, (:x, order(:y, rev=true)))\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.sort!","page":"Functions","title":"Base.sort!","text":"sort!(df::AbstractDataFrame, cols;\n      alg::Union{Algorithm, Nothing}=nothing, lt=isless, by=identity,\n      rev::Bool=false, order::Ordering=Forward)\n\nSort data frame df by column(s) cols. cols can be either a Symbol or Integer column index, or a tuple or vector of such indices.\n\nIf alg is nothing (the default), the most appropriate algorithm is chosen automatically among TimSort, MergeSort and RadixSort depending on the type of the sorting columns and on the number of rows in df. If rev is true, reverse sorting is performed. To enable reverse sorting only for some columns, pass order(c, rev=true) in cols, with c the corresponding column index (see example below). See other methods for a description of other keyword arguments.\n\nExamples\n\njulia> df = DataFrame(x = [3, 1, 2, 1], y = [\"b\", \"c\", \"a\", \"b\"])\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 1     │ b      │\n\njulia> sort!(df, :x)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort!(df, (:x, :y))\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ b      │\n│ 2   │ 1     │ c      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\njulia> sort!(df, (:x, :y), rev=true)\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 3     │ b      │\n│ 2   │ 2     │ a      │\n│ 3   │ 1     │ c      │\n│ 4   │ 1     │ b      │\n\njulia> sort!(df, (:x, order(:y, rev=true)))\n4×2 DataFrame\n│ Row │ x     │ y      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ c      │\n│ 2   │ 1     │ b      │\n│ 3   │ 2     │ a      │\n│ 4   │ 3     │ b      │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.unique!","page":"Functions","title":"Base.unique!","text":"unique(df::AbstractDataFrame)\nunique(df::AbstractDataFrame, cols)\nunique!(df::AbstractDataFrame)\nunique!(df::AbstractDataFrame, cols)\n\nDelete duplicate rows of data frame df, keeping only the first occurrence of unique rows. When cols is specified, the return DataFrame contains complete rows, retaining in each case the first instance for which df[cols] is unique.\n\nWhen unique is called a new data frame is returned; unique! updates df in-place.\n\nSee also nonunique.\n\nArguments\n\ndf : the AbstractDataFrame\ncols :  column indicator (Symbol, Int, Vector{Symbol}, Regex, etc.)\n\nspecifying the column(s) to compare.\n\nExamples\n\ndf = DataFrame(i = 1:10, x = rand(10), y = rand([\"a\", \"b\", \"c\"], 10))\ndf = vcat(df, df)\nunique(df)   # doesn't modify df\nunique(df, 1)\nunique!(df)  # modifies df\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.vcat","page":"Functions","title":"Base.vcat","text":"vcat(dfs::AbstractDataFrame...; cols::Union{Symbol, AbstractVector{Symbol}}=:setequal)\n\nVertically concatenate AbstractDataFrames.\n\nThe cols keyword argument determines the columns of the returned data frame:\n\n:setequal: require all data frames to have the same column names disregarding order. If they appear in different orders, the order of the first provided data frame is used.\n:orderequal: require all data frames to have the same column names and in the same order.\n:intersect: only the columns present in all provided data frames are kept. If the intersection is empty, an empty data frame is returned.\n:union: columns present in at least one of the provided data frames are kept. Columns not present in some data frames are filled with missing where necessary.\nA vector of Symbols: only listed columns are kept. Columns not present in some data frames are filled with missing where necessary.\n\nThe order of columns is determined by the order they appear in the included data frames, searching through the header of the first data frame, then the second, etc.\n\nThe element types of columns are determined using promote_type, as with vcat for AbstractVectors.\n\nvcat ignores empty data frames, making it possible to initialize an empty data frame at the beginning of a loop and vcat onto it.\n\nExample\n\njulia> df1 = DataFrame(A=1:3, B=1:3);\n\njulia> df2 = DataFrame(A=4:6, B=4:6);\n\njulia> df3 = DataFrame(A=7:9, C=7:9);\n\njulia> d4 = DataFrame();\n\njulia> vcat(df1, df2)\n6×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 4     │ 4     │\n│ 5   │ 5     │ 5     │\n│ 6   │ 6     │ 6     │\n\njulia> vcat(df1, df3, cols=:union)\n6×3 DataFrame\n│ Row │ A     │ B       │ C       │\n│     │ Int64 │ Int64⍰  │ Int64⍰  │\n├─────┼───────┼─────────┼─────────┤\n│ 1   │ 1     │ 1       │ missing │\n│ 2   │ 2     │ 2       │ missing │\n│ 3   │ 3     │ 3       │ missing │\n│ 4   │ 7     │ missing │ 7       │\n│ 5   │ 8     │ missing │ 8       │\n│ 6   │ 9     │ missing │ 9       │\n\njulia> vcat(df1, df3, cols=:intersect)\n6×1 DataFrame\n│ Row │ A     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n│ 4   │ 7     │\n│ 5   │ 8     │\n│ 6   │ 9     │\n\njulia> vcat(d4, df1)\n3×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.append!","page":"Functions","title":"Base.append!","text":"append!(df1::DataFrame, df2::AbstractDataFrame; cols::Symbol=:setequal)\nappend!(df::DataFrame, table; cols::Symbol=:setequal)\n\nAdd the rows of df2 to the end of df1. If the second argument table is not an AbstractDataFrame then it is converted using DataFrame(table, copycols=false) before being appended.\n\nColumn names of  df1 and df2 must be equal. If cols is :setequal (the default) then column names may have different orders and append! is performed by matching column names. If cols is :orderequal then the order of columns in df1 and df2 or table must be the same. In particular, if table is a Dict an error is thrown as it is an unordered collection.\n\nThe above rule has the following exceptions:\n\nIf df1 has no columns then copies of columns from df2 are added to it.\nIf df2 has no columns then calling append! leaves df1 unchanged.\n\nValues corresponding to new rows are appended in-place to the column vectors of df1. Column types are therefore preserved, and new values are converted if necessary. An error is thrown if conversion fails: this is the case in particular if a column in df2 contains missing values but the corresponding column in df1 does not accept them.\n\nPlease note that append! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nnote: Note\nUse vcat instead of append! when more flexibility is needed. Since vcat does not operate in place, it is able to use promotion to find an appropriate element type to hold values from both data frames. It also accepts columns in different orders between df1 and df2.Use push! to add individual rows to a data frame.\n\nExamples\n\njulia> df1 = DataFrame(A=1:3, B=1:3);\n\njulia> df2 = DataFrame(A=4.0:6.0, B=4:6);\n\njulia> append!(df1, df2);\n\njulia> df1\n6×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 4     │ 4     │\n│ 5   │ 5     │ 5     │\n│ 6   │ 6     │ 6     │\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.push!","page":"Functions","title":"Base.push!","text":"push!(df::DataFrame, row::Union{Tuple, AbstractArray})\npush!(df::DataFrame, row::Union{DataFrameRow, NamedTuple, AbstractDict};\n      cols::Symbol=:setequal)\n\nAdd in-place one row at the end of df taking the values from row.\n\nColumn types of df are preserved, and new values are converted if necessary. An error is thrown if conversion fails.\n\nIf row is neither a DataFrameRow, NamedTuple nor AbstractDict then it must be a Tuple or an AbstractArray and columns are matched by order of appearance. In this case row must contain the same number of elements as the number of columns in df.\n\nIf row is a DataFrameRow, NamedTuple or AbstractDict then values in row are matched to columns in df based on names. The exact behavior depends on the cols argument value in the following way:\n\nIf cols=:setequal (this is the default) then row must contain exactly the same columns as df (but possibly in a different order).\nIf cols=:orderequal then row must contain the same columns in the same order (for AbstractDict this option requires that keys(row) matches names(df)  to allow for support of ordered dicts; however, if row is a Dict an error is thrown  as it is an unordered collection).\nIf cols=:intersect then row may contain more columns than df, but all column names that are present in df must be present in row and only they are used to populate a new row in df.\nIf cols=:subset then push! behaves like for :intersect but if some column is missing in row then a missing value is pushed to df.\n\nAs a special case, if df has no columns and row is a NamedTuple or DataFrameRow, columns are created for all values in row, using their names and order.\n\nPlease note that push! must not be used on a DataFrame that contains columns that are aliases (equal when compared with ===).\n\nExamples\n\njulia> df = DataFrame(A=1:3, B=1:3)\n3×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n\njulia> push!(df, (true, false))\n4×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n\njulia> push!(df, df[1, :])\n5×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n│ 5   │ 1     │ 1     │\n\njulia> push!(df, (C=\"something\", A=true, B=false), cols=:intersect)\n4×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n│ 5   │ 1     │ 1     │\n│ 6   │ 1     │ 0     │\n\njulia> push!(df, Dict(:A=>1.0, :B=>2.0))\n5×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 2     │ 2     │\n│ 3   │ 3     │ 3     │\n│ 4   │ 1     │ 0     │\n│ 5   │ 1     │ 1     │\n│ 6   │ 1     │ 0     │\n│ 7   │ 1     │ 2     │\n\n\n\n\n\n","category":"function"},{"location":"man/split_apply_combine/#The-Split-Apply-Combine-Strategy-1","page":"Split-apply-combine","title":"The Split-Apply-Combine Strategy","text":"","category":"section"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"Many data analysis tasks involve splitting a data set into groups, applying some functions to each of the groups and then combining the results. A standardized framework for handling this sort of computation is described in the paper \"The Split-Apply-Combine Strategy for Data Analysis\", written by Hadley Wickham.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The DataFrames package supports the split-apply-combine strategy through the by function, which is a shorthand for groupby followed by map and/or combine. by takes in three arguments: (1) a DataFrame, (2) one or more columns to split the DataFrame on, and (3) a specification of one or more functions to apply to each subset of the DataFrame. This specification can be of the following forms:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"a col => function pair indicating that function should be called with the vector of values for column col, which can be a column name or index\na cols => function pair indicating that function should be called with a named tuple holding columns cols, which can be a tuple or vector of names or indices\nseveral such pairs, either as positional arguments or as keyword arguments (mixing is not allowed), producing each a single separate column; keyword argument names are used as column names\nequivalently, a (named) tuple or vector of such pairs\na function which will be called with a SubDataFrame corresponding to each group; this form should be avoided due to its poor performance","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"In all of these cases, the function can return either a single row or multiple rows, with a single or multiple columns:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"a single value produces a single row and column per group\na named tuple or DataFrameRow produces a single row and one column per field\na vector produces a single column with one row per entry\na named tuple of vectors produces one column per field with one row per entry in the vectors\na DataFrame or a matrix produces as many rows and columns as it contains; note that returning a DataFrame should be avoided due to its poor performance when the number of groups is large","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The kind of return value and the number and names of columns must be the same for all groups.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"As a special case, if multiple pairs or a tuple of vectors or pairs is passed (forms 3 and 4 above), each function is required to return a single value or vector, which will produce each a separate column.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The name for the resulting column can be chosen either by passing a named tuple of pairs, or by returning a named tuple or a data frame. If no name is provided, it is generated automatically. For functions taking a single column (first form), the input column name is concatenated with the function name: for standard functions like mean this will produce columns with names like SepalLength_mean; for anonymous functions like x -> 2 * sqrt(x), the produced columns will be SepalLength_function. For functions taking multiple columns (second form), names are x1, x2, etc.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"We show several examples of the by function applied to the iris dataset below:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> using DataFrames, CSV, Statistics\n\njulia> iris = DataFrame(CSV.File(joinpath(dirname(pathof(DataFrames)), \"../docs/src/assets/iris.csv\")));\n\njulia> first(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 5.1         │ 3.5        │ 1.4         │ 0.2        │ setosa        │\n│ 2   │ 4.9         │ 3.0        │ 1.4         │ 0.2        │ setosa        │\n│ 3   │ 4.7         │ 3.2        │ 1.3         │ 0.2        │ setosa        │\n│ 4   │ 4.6         │ 3.1        │ 1.5         │ 0.2        │ setosa        │\n│ 5   │ 5.0         │ 3.6        │ 1.4         │ 0.2        │ setosa        │\n│ 6   │ 5.4         │ 3.9        │ 1.7         │ 0.4        │ setosa        │\n\njulia> last(iris, 6)\n6×5 DataFrame\n│ Row │ SepalLength │ SepalWidth │ PetalLength │ PetalWidth │ Species       │\n│     │ Float64⍰    │ Float64⍰   │ Float64⍰    │ Float64⍰   │ Categorical…⍰ │\n├─────┼─────────────┼────────────┼─────────────┼────────────┼───────────────┤\n│ 1   │ 6.7         │ 3.3        │ 5.7         │ 2.5        │ virginica     │\n│ 2   │ 6.7         │ 3.0        │ 5.2         │ 2.3        │ virginica     │\n│ 3   │ 6.3         │ 2.5        │ 5.0         │ 1.9        │ virginica     │\n│ 4   │ 6.5         │ 3.0        │ 5.2         │ 2.0        │ virginica     │\n│ 5   │ 6.2         │ 3.4        │ 5.4         │ 2.3        │ virginica     │\n│ 6   │ 5.9         │ 3.0        │ 5.1         │ 1.8        │ virginica     │\n\njulia> by(iris, :Species, :PetalLength => mean)\n3×2 DataFrame\n│ Row │ Species    │ PetalLength_mean │\n│     │ String⍰    │ Float64          │\n├─────┼────────────┼──────────────────┤\n│ 1   │ setosa     │ 1.462            │\n│ 2   │ versicolor │ 4.26             │\n│ 3   │ virginica  │ 5.552            │\n\njulia> by(iris, :Species, N = :Species => length) # Chosen column is arbitrary\n3×2 DataFrame\n│ Row │ Species       │ N     │\n│     │ Categorical…⍰ │ Int64 │\n├─────┼───────────────┼───────┤\n│ 1   │ setosa        │ 50    │\n│ 2   │ versicolor    │ 50    │\n│ 3   │ virginica     │ 50    │\n\njulia> by(iris, :Species, N = :Species => length, mean = :PetalLength => mean) # Column for length is arbitrary\n3×3 DataFrame\n│ Row │ Species    │ N     │ mean    │\n│     │ String⍰    │ Int64 │ Float64 │\n├─────┼────────────┼───────┼─────────┤\n│ 1   │ setosa     │ 50    │ 1.462   │\n│ 2   │ versicolor │ 50    │ 4.26    │\n│ 3   │ virginica  │ 50    │ 5.552   │\n\njulia> by(iris, :Species, [:PetalLength, :SepalLength] =>\n              x -> (a=mean(x.PetalLength)/mean(x.SepalLength), b=sum(x.PetalLength)))\n3×3 DataFrame\n│ Row │ Species    │ a        │ b       │\n│     │ String⍰    │ Float64  │ Float64 │\n├─────┼────────────┼──────────┼─────────┤\n│ 1   │ setosa     │ 0.29205  │ 73.1    │\n│ 2   │ versicolor │ 0.717655 │ 213.0   │\n│ 3   │ virginica  │ 0.842744 │ 277.6   │","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The by function also supports the do block form. However, as noted above, this form is slow and should therefore be avoided when performance matters.","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> by(iris, :Species) do df\n          (m = mean(df.PetalLength), s² = var(df.PetalLength))\n       end\n3×3 DataFrame\n│ Row │ Species       │ m       │ s²        │\n│     │ Categorical…⍰ │ Float64 │ Float64   │\n├─────┼───────────────┼─────────┼───────────┤\n│ 1   │ setosa        │ 1.462   │ 0.0301592 │\n│ 2   │ versicolor    │ 4.26    │ 0.220816  │\n│ 3   │ virginica     │ 5.552   │ 0.304588  │","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"A second approach to the Split-Apply-Combine strategy is implemented in the aggregate function, which also takes three arguments: (1) a DataFrame, (2) one or more columns to split the DataFrame on, and (3) one or more functions that are used to compute a summary of each subset of the DataFrame. Each function is applied to each column that was not used to split the DataFrame, creating new columns of the form $name_$function like with by (see above). We show several examples of the aggregate function applied to the iris dataset below:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> aggregate(iris, :Species, length)\n3×5 DataFrame\n│ Row │ Species       │ SepalLength_length │ SepalWidth_length │ PetalLength_length │ PetalWidth_length │\n│     │ Categorical…⍰ │ Int64              │ Int64             │ Int64              │ Int64             │\n├─────┼───────────────┼────────────────────┼───────────────────┼────────────────────┼───────────────────┤\n│ 1   │ setosa        │ 50                 │ 50                │ 50                 │ 50                │\n│ 2   │ versicolor    │ 50                 │ 50                │ 50                 │ 50                │\n│ 3   │ virginica     │ 50                 │ 50                │ 50                 │ 50                │\n\njulia> aggregate(iris, :Species, [sum, mean])\n3×9 DataFrame. Omitted printing of 2 columns\n│ Row │ Species       │ SepalLength_sum │ SepalWidth_sum │ PetalLength_sum │ PetalWidth_sum │ SepalLength_mean │ SepalWidth_mean │\n│     │ Categorical…⍰ │ Float64         │ Float64        │ Float64         │ Float64        │ Float64          │ Float64         │\n├─────┼───────────────┼─────────────────┼────────────────┼─────────────────┼────────────────┼──────────────────┼─────────────────┤\n│ 1   │ setosa        │ 250.3           │ 171.4          │ 73.1            │ 12.3           │ 5.006            │ 3.428           │\n│ 2   │ versicolor    │ 296.8           │ 138.5          │ 213.0           │ 66.3           │ 5.936            │ 2.77            │\n│ 3   │ virginica     │ 329.4           │ 148.7          │ 277.6           │ 101.3          │ 6.588            │ 2.974           │","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"If you only want to split the data set into subsets, use the groupby function:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for subdf in groupby(iris, :Species)\n           println(size(subdf, 1))\n       end\n50\n50\n50","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"To also get the values of the grouping columns along with each group, use the pairs function:","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"julia> for (key, subdf) in pairs(groupby(iris, :Species))\n           println(\"Number of data points for $(key.Species): $(nrow(subdf))\")\n       end\nNumber of data points for setosa: 50\nNumber of data points for versicolor: 50\nNumber of data points for virginica: 50","category":"page"},{"location":"man/split_apply_combine/#","page":"Split-apply-combine","title":"Split-apply-combine","text":"The value of key in the previous example is a DataFrames.GroupKey object, which can be used in a similar fashion to a NamedTuple.","category":"page"},{"location":"man/getting_started/#Getting-Started-1","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting_started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The DataFrames package is available through the Julia package system and can be installed using the following commands:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"DataFrames\")","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Throughout the rest of this tutorial, we will assume that you have installed the DataFrames package and have already typed using DataFrames to bring all of the relevant variables into your current namespace.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nBy default Jupyter Notebook will limit the number of rows and columns when displaying a data frame to roughly fit the screen size (like in the REPL).You can override this behavior by setting the ENV[\"COLUMNS\"] or ENV[\"LINES\"] variables to hold the maximum width and height of output in characters respectively before using the notebook function.Alternatively, you may want to set the maximum number of data frame rows to print to 100 and the maximum output width in characters to 1000 for every Julia session using some Jupyter kernel file (numbers 100 and 1000 are only examples and can be adjusted). In such case add a \"COLUMNS\": \"1000\", \"LINES\": \"100\" entry to the \"env\" variable in this Jupyter kernel file. See here for information about location and specification of Jupyter kernels.","category":"page"},{"location":"man/getting_started/#The-DataFrame-Type-1","page":"Getting Started","title":"The DataFrame Type","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Objects of the DataFrame type represent a data table as a series of vectors, each corresponding to a column or variable. The simplest way of constructing a DataFrame is to pass column vectors using keyword arguments or pairs:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using DataFrames\n\njulia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n4×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ F      │\n│ 3   │ 3     │ F      │\n│ 4   │ 4     │ M      │\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Columns can be directly (i.e. without copying) accessed via df.col or df[!, :col]. The latter syntax is more flexible as it allows passing a variable holding the name of the column, and not only a literal name. Note that column names are symbols (:col or Symbol(\"col\")) rather than strings (\"col\"). Columns can also be accessed using an integer index specifying their position. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Since df[!, :col] does not make a copy, changing the elements of the column vector returned by this syntax will affect the values stored in the original df. To get a copy of the column use df[:, :col]: changing the vector returned by this syntax does not change df.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df.A\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4\n\njulia> df.A === df[!, :A]\ntrue\n\njulia> df.A === df[:, :A]\nfalse\n\njulia> df.A == df[:, :A]\ntrue\n\njulia> df.A === df[!, 1]\ntrue\n\njulia> df.A === df[:, 1]\nfalse\n\njulia> df.A == df[:, 1]\ntrue\n\njulia> firstcolumn = :A\n:A\n\njulia> df[!, firstcolumn] === df.A\ntrue\n\njulia> df[:, firstcolumn] === df.A\nfalse\n\njulia> df[:, firstcolumn] == df.A\ntrue","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Column names can be obtained using the names function:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> names(df)\n2-element Array{Symbol,1}:\n :A\n :B","category":"page"},{"location":"man/getting_started/#Constructing-Column-by-Column-1","page":"Getting Started","title":"Constructing Column by Column","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"It is also possible to start with an empty DataFrame and add columns to it one by one:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame()\n0×0 DataFrame\n\n\njulia> df.A = 1:8\n1:8\n\njulia> df.B = [\"M\", \"F\", \"F\", \"M\", \"F\", \"M\", \"M\", \"F\"]\n8-element Array{String,1}:\n \"M\"\n \"F\"\n \"F\"\n \"M\"\n \"F\"\n \"M\"\n \"M\"\n \"F\"\n\njulia> df\n8×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ F      │\n│ 3   │ 3     │ F      │\n│ 4   │ 4     │ M      │\n│ 5   │ 5     │ F      │\n│ 6   │ 6     │ M      │\n│ 7   │ 7     │ M      │\n│ 8   │ 8     │ F      │\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The DataFrame we build in this way has 8 rows and 2 columns. This can be checked using the size function:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> size(df, 1)\n8\n\njulia> size(df, 2)\n2\n\njulia> size(df)\n(8, 2)\n","category":"page"},{"location":"man/getting_started/#Constructing-Row-by-Row-1","page":"Getting Started","title":"Constructing Row by Row","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"It is also possible to fill a DataFrame row by row. Let us construct an empty data frame with two columns (note that the first column can only contain integers and the second one can only contain strings):","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A = Int[], B = String[])\n0×2 DataFrame","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Rows can then be added as tuples or vectors, where the order of elements matches that of columns:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, (1, \"M\"))\n1×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n\njulia> push!(df, [2, \"N\"])\n2×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ N      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Rows can also be added as Dicts, where the dictionary keys match the column names:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> push!(df, Dict(:B => \"F\", :A => 3))\n3×2 DataFrame\n│ Row │ A     │ B      │\n│     │ Int64 │ String │\n├─────┼───────┼────────┤\n│ 1   │ 1     │ M      │\n│ 2   │ 2     │ N      │\n│ 3   │ 3     │ F      │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Note that constructing a DataFrame row by row is significantly less performant than constructing it all at once, or column by column. For many use-cases this will not matter, but for very large DataFrames  this may be a consideration.","category":"page"},{"location":"man/getting_started/#Constructing-from-another-table-type-1","page":"Getting Started","title":"Constructing from another table type","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"DataFrames supports the Tables.jl interface for interacting with tabular data. This means that a DataFrame can be used as a \"source\" to any package that expects a Tables.jl interface input, (file format packages, data manipulation packages, etc.). A DataFrame can also be a sink for any Tables.jl interface input. Some example uses are:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])\n\n# write DataFrame out to CSV file\nCSV.write(\"dataframe.csv\", df)\n\n# store DataFrame in an SQLite database table\nSQLite.load!(df, db, \"dataframe_table\")\n\n# transform a DataFrame through Query.jl package\ndf = df |> @map({a=_.a + 1, _.b}) |> DataFrame","category":"page"},{"location":"man/getting_started/#Working-with-Data-Frames-1","page":"Getting Started","title":"Working with Data Frames","text":"","category":"section"},{"location":"man/getting_started/#Examining-the-Data-1","page":"Getting Started","title":"Examining the Data","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The default printing of DataFrame objects only includes a sample of rows and columns that fits on screen:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500)\n500×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 3     │ 1     │ 2     │\n│ 3   │ 5     │ 1     │ 3     │\n│ 4   │ 7     │ 1     │ 4     │\n⋮\n│ 496 │ 991   │ 10    │ 496   │\n│ 497 │ 993   │ 10    │ 497   │\n│ 498 │ 995   │ 10    │ 498   │\n│ 499 │ 997   │ 10    │ 499   │\n│ 500 │ 999   │ 10    │ 500   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Printing options can be adjusted by calling the show function manually: show(df, allrows=true) prints all rows even if they do not fit on screen and show(df, allcols=true) does the same for columns.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The first and last functions can be used to look at the first and last rows of a data frame (respectively):","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> first(df, 6)\n6×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 3     │ 1     │ 2     │\n│ 3   │ 5     │ 1     │ 3     │\n│ 4   │ 7     │ 1     │ 4     │\n│ 5   │ 9     │ 1     │ 5     │\n│ 6   │ 11    │ 1     │ 6     │\n\njulia> last(df, 6)\n6×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 989   │ 10    │ 495   │\n│ 2   │ 991   │ 10    │ 496   │\n│ 3   │ 993   │ 10    │ 497   │\n│ 4   │ 995   │ 10    │ 498   │\n│ 5   │ 997   │ 10    │ 499   │\n│ 6   │ 999   │ 10    │ 500   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Also notice that when DataFrame is printed to the console or rendered in HTML (e.g. in Jupyter Notebook) you get an information about type of elements held in its columns. For example in this case:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> DataFrame(a = 1:2, b = [1.0, missing],\n                 c = categorical('a':'b'), d = [1//2, missing])\n2×4 DataFrame\n│ Row │ a     │ b        │ c            │ d         │\n│     │ Int64 │ Float64⍰ │ Categorical… │ Rationa…⍰ │\n├─────┼───────┼──────────┼──────────────┼───────────┤\n│ 1   │ 1     │ 1.0      │ 'a'          │ 1//2      │\n│ 2   │ 2     │ missing  │ 'b'          │ missing   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"we can observe that:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"the first column :a can hold elements of type Int64;\nthe second column :b can hold Float64 or Missing, which is indicated by ⍰ printed after the name of type;\nthe third column :c can hold categorical data; here we notice …, which indicates that the actual name of the type was long and got truncated;\nthe type information in fourth column :d presents a situation where the name is both truncated and the type allows Missing.","category":"page"},{"location":"man/getting_started/#Taking-a-Subset-1","page":"Getting Started","title":"Taking a Subset","text":"","category":"section"},{"location":"man/getting_started/#Indexing-syntax-1","page":"Getting Started","title":"Indexing syntax","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Specific subsets of a data frame can be extracted using the indexing syntax, similar to matrices. The colon : indicates that all items (rows or columns depending on its position) should be retained:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[1:3, :]\n3×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 3     │ 1     │ 2     │\n│ 3   │ 5     │ 1     │ 3     │\n\njulia> df[[1, 5, 10], :]\n3×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 9     │ 1     │ 5     │\n│ 3   │ 19    │ 1     │ 10    │\n\njulia> df[:, [:A, :B]]\n500×2 DataFrame\n│ Row │ A     │ B     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 3     │ 1     │\n│ 3   │ 5     │ 1     │\n│ 4   │ 7     │ 1     │\n⋮\n│ 496 │ 991   │ 10    │\n│ 497 │ 993   │ 10    │\n│ 498 │ 995   │ 10    │\n│ 499 │ 997   │ 10    │\n│ 500 │ 999   │ 10    │\n\njulia> df[1:3, [:B, :A]]\n3×2 DataFrame\n│ Row │ B     │ A     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 1     │\n│ 2   │ 1     │ 3     │\n│ 3   │ 1     │ 5     │\n\njulia> df[[3, 1], [:C]]\n2×1 DataFrame\n│ Row │ C     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 3     │\n│ 2   │ 1     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Do note that df[!, [:A]] and df[:, [:A]] return a DataFrame object, while df[!, :A] and df[:, :A] return a vector:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[!, [:A]]\n500×1 DataFrame\n│ Row │ A     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 3     │\n│ 3   │ 5     │\n│ 4   │ 7     │\n⋮\n│ 496 │ 991   │\n│ 497 │ 993   │\n│ 498 │ 995   │\n│ 499 │ 997   │\n│ 500 │ 999   │\n\njulia> df[!, [:A]] == df[:, [:A]]\ntrue\n\njulia> df[!, :A]\n500-element Array{Int64,1}:\n   1\n   3\n   5\n   7\n   9\n  11\n   ⋮\n 991\n 993\n 995\n 997\n 999\n\njulia> df[!, :A] == df[:, :A]\ntrue","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"In the first cases, [:A] is a vector, indicating that the resulting object should be a DataFrame, since a vector can contain one or more column names. On the other hand, :A is a single symbol, indicating that a single column vector should be extracted. Note that in the first case a vector is required to be passed (not just any iterable), so e.g. df[:, (:x1, :x2)] is not allowed, but df[:, [:x1, :x2]] is valid.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"It is also possible to use a regular expression as a selector of columns matching it:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(x1=1, x2=2, y=3)\n1×3 DataFrame\n│ Row │ x1    │ x2    │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> df[!, r\"x\"]\n1×2 DataFrame\n│ Row │ x1    │ x2    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 2     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"A Not selector (from the InvertedIndices package) can be used to select all columns excluding a specific subset:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[!, Not(:x1)]\n1×2 DataFrame\n│ Row │ x2    │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Finally, you can use Not and All selectors in more complex column selection scenarios. The following examples move all columns whose names match r\"x\" regular expression respectively to the front and to the end of a data frame:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(r=1, x1=2, x2=3, y=4)\n1×4 DataFrame\n│ Row │ r     │ x1    │ x2    │ y     │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │ 4     │\n\njulia> df[:, All(r\"x\", :)]\n1×4 DataFrame\n│ Row │ x1    │ x2    │ r     │ y     │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 2     │ 3     │ 1     │ 4     │\n\njulia> df[:, All(Not(r\"x\"), :)]\n1×4 DataFrame\n│ Row │ r     │ y     │ x1    │ x2    │\n│     │ Int64 │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 4     │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The indexing syntax can also be used to select rows based on conditions on variables:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[df.A .> 500, :]\n250×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 501   │ 6     │ 251   │\n│ 2   │ 503   │ 6     │ 252   │\n│ 3   │ 505   │ 6     │ 253   │\n│ 4   │ 507   │ 6     │ 254   │\n⋮\n│ 246 │ 991   │ 10    │ 496   │\n│ 247 │ 993   │ 10    │ 497   │\n│ 248 │ 995   │ 10    │ 498   │\n│ 249 │ 997   │ 10    │ 499   │\n│ 250 │ 999   │ 10    │ 500   │\n\njulia> df[(df.A .> 500) .& (300 .< df.C .< 400), :]\n99×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 601   │ 7     │ 301   │\n│ 2   │ 603   │ 7     │ 302   │\n│ 3   │ 605   │ 7     │ 303   │\n│ 4   │ 607   │ 7     │ 304   │\n⋮\n│ 95  │ 789   │ 8     │ 395   │\n│ 96  │ 791   │ 8     │ 396   │\n│ 97  │ 793   │ 8     │ 397   │\n│ 98  │ 795   │ 8     │ 398   │\n│ 99  │ 797   │ 8     │ 399   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Where a specific subset of values needs to be matched, the in() function can be applied:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df[in.(df.A, Ref([1, 5, 601])), :]\n3×3 DataFrame\n│ Row │ A     │ B     │ C     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 1     │ 1     │\n│ 2   │ 5     │ 1     │ 3     │\n│ 3   │ 601   │ 7     │ 301   │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Equivalently, the in function can be called with a single argument to create a function object that tests whether each value belongs to the subset (partial application of in): df[in([1, 5, 601]).(df.A), :].","category":"page"},{"location":"man/getting_started/#Column-selection-using-select-and-select!-1","page":"Getting Started","title":"Column selection using select and select!","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"You can also use the select and select! functions to select columns in a data frame.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The select function creates a new data frame:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(x1=1, x2=2, y=3)\n1×3 DataFrame\n│ Row │ x1    │ x2    │ y     │\n│     │ Int64 │ Int64 │ Int64 │\n├─────┼───────┼───────┼───────┤\n│ 1   │ 1     │ 2     │ 3     │\n\njulia> select(df, Not(:x1)) # drop column :x1 in a new data frame\n1×2 DataFrame\n│ Row │ x2    │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 2     │ 3     │\n\njulia> select(df, r\"x\") # select columns containing 'x' character\n1×2 DataFrame\n│ Row │ x1    │ x2    │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 1     │ 2     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"It is important to note that select always returns a data frame, even if a single column is selected (as opposed to indexing syntax).","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select(df, :x1)\n1×1 DataFrame\n│ Row │ x1    │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n\njulia> df[:, :x1]\n1-element Array{Int64,1}:\n 1","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"By default select copies columns of a passed source data frame. In order to avoid copying, pass copycols=false:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df2 = select(df, :x1)\n1×1 DataFrame\n│ Row │ x1    │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n\njulia> df2.x1 === df.x1\nfalse\n\njulia> df2 = select(df, :x1, copycols=false)\n1×1 DataFrame\n│ Row │ x1    │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n\njulia> df2.x1 === df.x1\ntrue","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"To perform the selection operation in-place use select!:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> select!(df, Not(:x1));\n\njulia> df\n1×2 DataFrame\n│ Row │ x2    │ y     │\n│     │ Int64 │ Int64 │\n├─────┼───────┼───────┤\n│ 1   │ 2     │ 3     │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"While the DataFrames package provides basic data manipulation capabilities, users are encouraged to use querying frameworks for more convenient and powerful operations:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"the Query.jl package provides a LINQ-like interface to a large number of data sources\nthe DataFramesMeta.jl package provides interfaces similar to LINQ and dplyr","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"See the Data manipulation frameworks section for more information.","category":"page"},{"location":"man/getting_started/#Summarizing-Data-1","page":"Getting Started","title":"Summarizing Data","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The describe function returns a data frame summarizing the elementary statistics and information about each column:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A = 1:4, B = [\"M\", \"F\", \"F\", \"M\"])\n\njulia> describe(df)\n2×8 DataFrame\n│ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │\n│     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │\n├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤\n│ 1   │ A        │ 2.5    │ 1   │ 2.5    │ 4   │         │          │ Int64    │\n│ 2   │ B        │        │ F   │        │ M   │ 2       │          │ String   │\n","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"If you are interested in describing only a subset of columns then the easiest way to do it is to pass a subset of an original data frame to describe like this:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> describe(df[!, [:A]))\n1×8 DataFrame\n│ Row │ variable │ mean    │ min   │ median  │ max   │ nunique │ nmissing │ eltype   │\n│     │ Symbol   │ Float64 │ Int64 │ Float64 │ Int64 │ Nothing │ Nothing  │ DataType │\n├─────┼──────────┼─────────┼───────┼─────────┼───────┼─────────┼──────────┼──────────┤\n│ 1   │ A        │ 2.5     │ 1     │ 2.5     │ 4     │         │          │ Int64    │","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Of course, one can also compute descriptive statistics directly on individual columns:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> using Statistics\n\njulia> mean(df.A)\n2.5","category":"page"},{"location":"man/getting_started/#Column-Wise-Operations-1","page":"Getting Started","title":"Column-Wise Operations","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We can also apply a function to each column of a DataFrame with the aggregate function. For example:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)\n4×2 DataFrame\n│ Row │ A     │ B       │\n│     │ Int64 │ Float64 │\n├─────┼───────┼─────────┤\n│ 1   │ 1     │ 4.0     │\n│ 2   │ 2     │ 3.0     │\n│ 3   │ 3     │ 2.0     │\n│ 4   │ 4     │ 1.0     │\n\njulia> aggregate(df, sum)\n1×2 DataFrame\n│ Row │ A_sum │ B_sum   │\n│     │ Int64 │ Float64 │\n├─────┼───────┼─────────┤\n│ 1   │ 10    │ 10.0    │\n\njulia> aggregate(df, [sum, prod])\n1×4 DataFrame\n│ Row │ A_sum │ B_sum   │ A_prod │ B_prod  │\n│     │ Int64 │ Float64 │ Int64  │ Float64 │\n├─────┼───────┼─────────┼────────┼─────────┤\n│ 1   │ 10    │ 10.0    │ 24     │ 24.0    │","category":"page"},{"location":"man/getting_started/#Handling-of-Columns-Stored-in-a-DataFrame-1","page":"Getting Started","title":"Handling of Columns Stored in a DataFrame","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Functions that transform a DataFrame to produce a new DataFrame always perform a copy of the columns by default, for example:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0)\n4×2 DataFrame\n│ Row │ A     │ B       │\n│     │ Int64 │ Float64 │\n├─────┼───────┼─────────┤\n│ 1   │ 1     │ 4.0     │\n│ 2   │ 2     │ 3.0     │\n│ 3   │ 3     │ 2.0     │\n│ 4   │ 4     │ 1.0     │\n\njulia> df2 = copy(df);\n\njulia> df2.A === df.A\nfalse","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"On the other hand, in-place functions, whose names end with !, may mutate the column vectors of the DataFrame they take as an argument, for example:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 3     │\n│ 2   │ 1     │\n│ 3   │ 2     │\n\njulia> sort!(df)\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 1     │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> x\n3-element Array{Int64,1}:\n 1\n 2\n 3\n\njulia> df.x[1] = 100\n100\n\njulia> df\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 100   │\n│ 2   │ 2     │\n│ 3   │ 3     │\n\njulia> x\n3-element Array{Int64,1}:\n 100\n   2\n   3","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"In-place functions are safe to call, except when a view of the DataFrame (created via a view, @view or groupby) or when a DataFrame created with copycols=false (or with the DataFrame! function) are in use.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"It is possible to have a direct access to a column col of a DataFrame df using the syntaxes df.col, df[!, :col], via the eachcol function, by accessing a parent of a view of a column of a DataFrame, or simply by storing the reference to the column vector before the DataFrame was created with copycols=false (or with the DataFrame! function).","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"julia> x = [3, 1, 2];\n\njulia> df = DataFrame(x=x)\n3×1 DataFrame\n│ Row │ x     │\n│     │ Int64 │\n├─────┼───────┤\n│ 1   │ 3     │\n│ 2   │ 1     │\n│ 3   │ 2     │\n\njulia> df.x == x\ntrue\n\njulia> df[1] !== x\ntrue\n\njulia> eachcol(df, false)[1] === df.x\ntrue","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Note that a column obtained from a DataFrame using one of these methods should not be mutated without caution.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The exact rules of handling columns of a DataFrame are explained in The design of handling of columns of a DataFrame section of the manual.","category":"page"},{"location":"man/getting_started/#Importing-and-Exporting-Data-(I/O)-1","page":"Getting Started","title":"Importing and Exporting Data (I/O)","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"For reading and writing tabular data from CSV and other delimited text files, use the CSV.jl package.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"If you have not used the CSV.jl package before then you may need to install it first:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"CSV\")","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The CSV.jl functions are not loaded automatically and must be imported into the session.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"using CSV","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"A dataset can now be read from a CSV file at path input using","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"DataFrame(CSV.File(input))","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"A DataFrame can be written to a CSV file at path output using","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"df = DataFrame(x = 1, y = 2)\nCSV.write(output, df)","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The behavior of CSV functions can be adapted via keyword arguments. For more information, see ?CSV.File, ?CSV.read and ?CSV.write, or checkout the online CSV.jl documentation.","category":"page"},{"location":"man/missing/#Missing-Data-1","page":"Missing Data","title":"Missing Data","text":"","category":"section"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"In Julia, missing values in data are represented using the special object missing, which is the single instance of the type Missing.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> missing\r\nmissing\r\n\r\njulia> typeof(missing)\r\nMissing\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The Missing type lets users create Vectors and DataFrame columns with missing values. Here we create a vector with a missing value and the element-type of the returned vector is Union{Missing, Int64}.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> x = [1, 2, missing]\r\n3-element Array{Union{Missing, Int64},1}:\r\n 1\r\n 2\r\n  missing\r\n\r\njulia> eltype(x)\r\nUnion{Missing, Int64}\r\n\r\njulia> Union{Missing, Int}\r\nUnion{Missing, Int64}\r\n\r\njulia> eltype(x) == Union{Missing, Int}\r\ntrue\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"missing values can be excluded when performing operations by using skipmissing, which returns a memory-efficient iterator.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> skipmissing(x)\r\nBase.SkipMissing{Array{Union{Missing, Int64},1}}(Union{Missing, Int64}[1, 2, missing])\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The output of skipmissing can be passed directly into functions as an argument. For example, we can find the sum of all non-missing values or collect the non-missing values into a new missing-free vector.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> sum(skipmissing(x))\r\n3\r\n\r\njulia> collect(skipmissing(x))\r\n2-element Array{Int64,1}:\r\n 1\r\n 2\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The function coalesce can be used to replace missing values with another value (note the dot, indicating that the replacement should be applied to all entries in x):","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> coalesce.(x, 0)\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 0\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The functions dropmissing and dropmissing! can be used to remove the rows containing missing values from a DataFrame and either create a new DataFrame or mutate the original in-place respectively.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> df = DataFrame(i = 1:5,\r\n                      x = [missing, 4, missing, 2, 1],\r\n                      y = [missing, missing, \"c\", \"d\", \"e\"])\r\n\r\njulia> dropmissing(df)\r\n2×3 DataFrame\r\n│ Row │ i     │ x      │ y       │\r\n│     │ Int64 │ Int64⍰ │ String⍰ │\r\n├─────┼───────┼────────┼─────────┤\r\n│ 1   │ 4     │ 2      │ d       │\r\n│ 2   │ 5     │ 1      │ e       │","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"One can specify the column(s) in which to search for rows containing missing values to be removed.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, :x)\r\n3×3 DataFrame\r\n│ Row │ i     │ x      │ y       │\r\n│     │ Int64 │ Int64⍰ │ String⍰ │\r\n├─────┼───────┼────────┼─────────┤\r\n│ 1   │ 2     │ 4      │ missing │\r\n│ 2   │ 4     │ 2      │ d       │\r\n│ 3   │ 5     │ 1      │ e       │","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"By default the dropmissing and dropmissing! functions keep the Union{T,Missing} element type in columns selected for row removal. To remove the Missing part, if present, set the disallowmissing option to true (it will become the default behavior in the future).","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> dropmissing(df, disallowmissing=true)\r\n2×3 DataFrame\r\n│ Row │ i     │ x     │ y      │\r\n│     │ Int64 │ Int64 │ String │\r\n├─────┼───────┼───────┼────────┤\r\n│ 1   │ 4     │ 2     │ d      │\r\n│ 2   │ 5     │ 1     │ e      │","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The Missings.jl package provides a few convenience functions to work with missing values.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The function Missings.replace returns an iterator which replaces missing elements with another value:","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> using Missings\r\n\r\njulia> Missings.replace(x, 1)\r\nMissings.EachReplaceMissing{Array{Union{Missing, Int64},1},Int64}(Union{Missing, Int64}[1, 2, missing], 1)\r\n\r\njulia> collect(Missings.replace(x, 1))\r\n3-element Array{Int64,1}:\r\n 1\r\n 2\r\n 1\r\n\r\njulia> collect(Missings.replace(x, 1)) == coalesce.(x, 1)\r\ntrue\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The function nonmissingtype returns the element-type T in Union{T, Missing}.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> eltype(x)\r\nUnion{Int64, Missing}\r\n\r\njulia> nonmissingtype(eltype(x))\r\nInt64\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"The missings function constructs Vectors and Arrays supporting missing values, using the optional first argument to specify the element-type.","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"julia> missings(1)\r\n1-element Array{Missing,1}:\r\n missing\r\n\r\njulia> missings(3)\r\n3-element Array{Missing,1}:\r\n missing\r\n missing\r\n missing\r\n\r\njulia> missings(1, 3)\r\n1×3 Array{Missing,2}:\r\n missing  missing  missing\r\n\r\njulia> missings(Int, 1, 3)\r\n1×3 Array{Union{Missing, Int64},2}:\r\n missing  missing  missing\r\n","category":"page"},{"location":"man/missing/#","page":"Missing Data","title":"Missing Data","text":"See the Julia manual for more information about missing values.","category":"page"},{"location":"#DataFrames.jl-1","page":"Introduction","title":"DataFrames.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Welcome to the DataFrames documentation!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with tabular data manipulation using the DataFrames.jl package. For more illustrations of its usage in conjunction with other packages, the DataFrames Tutorial using Jupyter Notebooks is a good complementary resource.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If there is something you expect DataFrames to be capable of, but cannot figure out how to do, please reach out with questions in Domains/Data on Discourse.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please report bugs by opening an issue.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can follow the source links throughout the documentation to jump right to the source files on GitHub to make pull requests for improving the documentation and function capabilities.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please review DataFrames contributing guidelines before submitting your first PR!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Information on specific versions can be found on the Release page.","category":"page"},{"location":"#Package-Manual-1","page":"Introduction","title":"Package Manual","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"man/getting_started.md\",\n         \"man/joins.md\",\n         \"man/split_apply_combine.md\",\n         \"man/reshaping_and_pivoting.md\",\n         \"man/sorting.md\",\n         \"man/categorical.md\",\n         \"man/missing.md\",\n         \"man/querying_frameworks.md\"]\nDepth = 2","category":"page"},{"location":"#API-1","page":"Introduction","title":"API","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without DataFrames. qualifier after loading the DataFrames.jl package with using DataFrames) types and functions are considered a part of the public API of the DataFrames.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"All types and functions that are part of public API are guaranteed to go through a deprecation period before being changed or removed.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please be warned that while Julia allows you to access internal functions or types of DataFrames.jl these can change without warning between versions of DataFrames.jl. In particular it is not safe to directly access fields of types that are a part of public API of the DataFrames.jl package using e.g. the getfield function. Whenever some operation on fields of defined types is considered allowed an appropriate exported function should be used instead.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\", \"lib/indexing.md\"]\nDepth = 2","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"lib/types.md\", \"lib/functions.md\"]","category":"page"}]
}
