<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · DataFrames.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="DataFrames.jl logo"/></a><h1>DataFrames.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Introduction</a></li><li><span class="toctext">User Guide</span><ul><li class="current"><a class="toctext" href>Getting Started</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#The-DataFrame-Type-1">The <code>DataFrame</code> Type</a></li><li class="toplevel"><a class="toctext" href="#write-DataFrame-out-to-CSV-file-1">write DataFrame out to CSV file</a></li><li class="toplevel"><a class="toctext" href="#store-DataFrame-in-an-SQLite-database-table-1">store DataFrame in an SQLite database table</a></li><li class="toplevel"><a class="toctext" href="#transform-a-DataFrame-through-Query.jl-package-1">transform a DataFrame through Query.jl package</a></li><li class="toplevel"><a class="toctext" href="#replacement-on-a-subset-of-columns-[:c,-:d]-1">replacement on a subset of columns [:c, :d]</a></li><li class="toplevel"><a class="toctext" href="#replacement-on-entire-data-frame-1">replacement on entire data frame</a></li><li class="toplevel"><a class="toctext" href="#do-not-operate-in-place-(df-would-also-work)-1">do not operate in-place (<code>df =</code> would also work)</a></li><li class="toplevel"><a class="toctext" href="#operate-in-place-after-allowing-for-missing-1">operate in-place after allowing for missing</a></li></ul></li><li><a class="toctext" href="../joins/">Joins</a></li><li><a class="toctext" href="../split_apply_combine/">Split-apply-combine</a></li><li><a class="toctext" href="../reshaping_and_pivoting/">Reshaping</a></li><li><a class="toctext" href="../sorting/">Sorting</a></li><li><a class="toctext" href="../categorical/">Categorical Data</a></li><li><a class="toctext" href="../missing/">Missing Data</a></li><li><a class="toctext" href="../querying_frameworks/">Data manipulation frameworks</a></li></ul></li><li><span class="toctext">API</span><ul><li><a class="toctext" href="../../lib/types/">Types</a></li><li><a class="toctext" href="../../lib/functions/">Functions</a></li><li><a class="toctext" href="../../lib/indexing/">Indexing</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>User Guide</li><li><a href>Getting Started</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/DataFrames.jl/blob/master/docs/src/man/getting_started.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Getting Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Getting-Started-1" href="#Getting-Started-1">Getting Started</a></h1><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The DataFrames package is available through the Julia package system and can be installed using the following commands:</p><pre><code class="language-julia">using Pkg
Pkg.add(&quot;DataFrames&quot;)</code></pre><p>Throughout the rest of this tutorial, we will assume that you have installed the DataFrames package and have already typed <code>using DataFrames</code> to bring all of the relevant variables into your current namespace.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>By default Jupyter Notebook will limit the number of rows and columns when displaying a data frame to roughly fit the screen size (like in the REPL).</p><p>You can override this behavior by changing the values of the <code>ENV[&quot;COLUMNS&quot;]</code> and <code>ENV[&quot;LINES&quot;]</code> variables to hold the maximum width and height of output in characters respectively.</p><p>Alternatively, you may want to set the maximum number of data frame rows to print to <code>100</code> and the maximum output width in characters to <code>1000</code> for every Julia session using some Jupyter kernel file (numbers <code>100</code> and <code>1000</code> are only examples and can be adjusted). In such case add a <code>&quot;COLUMNS&quot;: &quot;1000&quot;, &quot;LINES&quot;: &quot;100&quot;</code> entry to the <code>&quot;env&quot;</code> variable in this Jupyter kernel file. See <a href="https://jupyter-client.readthedocs.io/en/stable/kernels.html">here</a> for information about location and specification of Jupyter kernels.</p></div></div><h2><a class="nav-anchor" id="The-DataFrame-Type-1" href="#The-DataFrame-Type-1">The <code>DataFrame</code> Type</a></h2><p>Objects of the <code>DataFrame</code> type represent a data table as a series of vectors, each corresponding to a column or variable. The simplest way of constructing a <code>DataFrame</code> is to pass column vectors using keyword arguments or pairs:</p><pre><code class="language-julia-repl">julia&gt; using DataFrames

julia&gt; df = DataFrame(A = 1:4, B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;])
4×2 DataFrame
│ Row │ A     │ B      │
│     │ Int64 │ String │
├─────┼───────┼────────┤
│ 1   │ 1     │ M      │
│ 2   │ 2     │ F      │
│ 3   │ 3     │ F      │
│ 4   │ 4     │ M      │
</code></pre><p>Columns can be directly (i.e. without copying) accessed via <code>df.col</code>, <code>df.&quot;col&quot;</code>, <code>df[!, :col]</code> or <code>df[!, &quot;col&quot;]</code>. The two latter syntaxes are more flexible as they allow passing a variable holding the name of the column, and not only a literal name. Note that column names can be either symbols (written as <code>:col</code>, <code>:var&quot;col&quot;</code> or <code>Symbol(&quot;col&quot;)</code>) or strings (written as <code>&quot;col&quot;</code>). Columns can also be accessed using an integer index specifying their position.</p><p>Since <code>df[!, :col]</code> does not make a copy, changing the elements of the column vector returned by this syntax will affect the values stored in the original <code>df</code>. To get a copy of the column use <code>df[:, :col]</code>: changing the vector returned by this syntax does not change <code>df</code>.</p><pre><code class="language-julia-repl">julia&gt; df.A
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; df.&quot;A&quot;
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; df.A === df[!, :A]
true

julia&gt; df.A === df[:, :A]
false

julia&gt; df.A == df[:, :A]
true

julia&gt; df.A === df[!, &quot;A&quot;]
true

julia&gt; df.A === df[:, &quot;A&quot;]
false

julia&gt; df.A == df[:, &quot;A&quot;]
true

julia&gt; df.A === df[!, 1]
true

julia&gt; df.A === df[:, 1]
false

julia&gt; df.A == df[:, 1]
true

julia&gt; firstcolumn = :A
:A

julia&gt; df[!, firstcolumn] === df.A
true

julia&gt; df[:, firstcolumn] === df.A
false

julia&gt; df[:, firstcolumn] == df.A
true</code></pre><p>Column names can be obtained as strings using the <code>names</code> function:</p><pre><code class="language-julia-repl">julia&gt; names(df)
2-element Array{String,1}:
 &quot;A&quot;
 &quot;B&quot;
 ```

To get column names as `Symbol`s use the `propertynames` function:</code></pre><p>julia&gt; propertynames(df) 2-element Array{Symbol,1}:  :A  :B</p><pre><code class="language-none">
!!! note

    DataFrames.jl allows to use `Symbol`s (like `:A`) and strings (like `&quot;A&quot;`)
    for all column indexing operations for convenience.
    However, using `Symbol`s is slightly faster and should generally be preferred.


### Constructing Column by Column

It is also possible to start with an empty `DataFrame` and add columns to it one by one:
</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame() 0×0 DataFrame</p><p>julia&gt; df.A = 1:8 1:8</p><p>julia&gt; df.B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;] 8-element Array{String,1}:  &quot;M&quot;  &quot;F&quot;  &quot;F&quot;  &quot;M&quot;  &quot;F&quot;  &quot;M&quot;  &quot;M&quot;  &quot;F&quot;</p><p>julia&gt; df 8×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │ │ 2   │ 2     │ F      │ │ 3   │ 3     │ F      │ │ 4   │ 4     │ M      │ │ 5   │ 5     │ F      │ │ 6   │ 6     │ M      │ │ 7   │ 7     │ M      │ │ 8   │ 8     │ F      │</p><pre><code class="language-none">
The `DataFrame` we build in this way has 8 rows and 2 columns.
This can be checked using the `size` function:
</code></pre><p>jldoctest dataframe julia&gt; size(df, 1) 8</p><p>julia&gt; size(df, 2) 2</p><p>julia&gt; size(df) (8, 2)</p><pre><code class="language-none">
### Constructing Row by Row

It is also possible to fill a `DataFrame` row by row. Let us construct an empty data frame with two columns (note that the first column can only contain integers and the second one can only contain strings):
</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(A = Int[], B = String[]) 0×2 DataFrame</p><pre><code class="language-none">
Rows can then be added as tuples or vectors, where the order of elements matches that of columns:
</code></pre><p>jldoctest dataframe julia&gt; push!(df, (1, &quot;M&quot;)) 1×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │</p><p>julia&gt; push!(df, [2, &quot;N&quot;]) 2×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │ │ 2   │ 2     │ N      │</p><pre><code class="language-none">
Rows can also be added as `Dict`s, where the dictionary keys match the column names:
</code></pre><p>jldoctest dataframe julia&gt; push!(df, Dict(:B =&gt; &quot;F&quot;, :A =&gt; 3)) 3×2 DataFrame │ Row │ A     │ B      │ │     │ Int64 │ String │ ├─────┼───────┼────────┤ │ 1   │ 1     │ M      │ │ 2   │ 2     │ N      │ │ 3   │ 3     │ F      │</p><pre><code class="language-none">
Note that constructing a `DataFrame` row by row is significantly less performant than
constructing it all at once, or column by column. For many use-cases this will not matter,
but for very large `DataFrame`s  this may be a consideration.

### Constructing from another table type

DataFrames supports the [Tables.jl](https://github.com/JuliaData/Tables.jl) interface for
interacting with tabular data. This means that a `DataFrame` can be used as a &quot;source&quot;
to any package that expects a Tables.jl interface input, (file format packages,
data manipulation packages, etc.). A `DataFrame` can also be a sink for any Tables.jl
interface input. Some example uses are:
</code></pre><p>julia df = DataFrame(a=[1, 2, 3], b=[:a, :b, :c])</p><h1><a class="nav-anchor" id="write-DataFrame-out-to-CSV-file-1" href="#write-DataFrame-out-to-CSV-file-1">write DataFrame out to CSV file</a></h1><p>CSV.write(&quot;dataframe.csv&quot;, df)</p><h1><a class="nav-anchor" id="store-DataFrame-in-an-SQLite-database-table-1" href="#store-DataFrame-in-an-SQLite-database-table-1">store DataFrame in an SQLite database table</a></h1><p>SQLite.load!(df, db, &quot;dataframe_table&quot;)</p><h1><a class="nav-anchor" id="transform-a-DataFrame-through-Query.jl-package-1" href="#transform-a-DataFrame-through-Query.jl-package-1">transform a DataFrame through Query.jl package</a></h1><p>df = df |&gt; @map({a=_.a + 1, _.b}) |&gt; DataFrame</p><pre><code class="language-none">
A particular common case of a collection that supports the
[Tables.jl](https://github.com/JuliaData/Tables.jl) interface is
a vector of `NamedTuple`s:</code></pre><p>julia&gt; v = [(a=1,b=2), (a=3,b=4)] 2-element Array{NamedTuple{(:a, :b),Tuple{Int64,Int64}},1}:  (a = 1, b = 2)  (a = 3, b = 4)</p><p>julia&gt; df = DataFrame(v) 2×2 DataFrame │ Row │ a     │ b     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 2     │ │ 2   │ 3     │ 4     │</p><pre><code class="language-none">You can also easily convert a data frame back to a vector of `NamedTuple`s:</code></pre><p>julia&gt; using Tables</p><p>julia&gt; Tables.rowtable(df) 2-element Array{NamedTuple{(:a, :b),Tuple{Int64,Int64}},1}:  (a = 1, b = 2)  (a = 3, b = 4)</p><pre><code class="language-none">
## Working with Data Frames

### Examining the Data

The default printing of `DataFrame` objects only includes a sample of rows and columns that fits on screen:
</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(A = 1:2:1000, B = repeat(1:10, inner=50), C = 1:500) 500×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 3     │ 1     │ 2     │ │ 3   │ 5     │ 1     │ 3     │ │ 4   │ 7     │ 1     │ 4     │ ⋮ │ 496 │ 991   │ 10    │ 496   │ │ 497 │ 993   │ 10    │ 497   │ │ 498 │ 995   │ 10    │ 498   │ │ 499 │ 997   │ 10    │ 499   │ │ 500 │ 999   │ 10    │ 500   │</p><pre><code class="language-none">
Printing options can be adjusted by calling the `show` function manually: `show(df, allrows=true)` prints all rows even if they do not fit on screen and `show(df, allcols=true)` does the same for columns.

The `first` and `last` functions can be used to look at the first and last rows of a data frame (respectively):
</code></pre><p>jldoctest dataframe julia&gt; first(df, 6) 6×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 3     │ 1     │ 2     │ │ 3   │ 5     │ 1     │ 3     │ │ 4   │ 7     │ 1     │ 4     │ │ 5   │ 9     │ 1     │ 5     │ │ 6   │ 11    │ 1     │ 6     │</p><p>julia&gt; last(df, 6) 6×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 989   │ 10    │ 495   │ │ 2   │ 991   │ 10    │ 496   │ │ 3   │ 993   │ 10    │ 497   │ │ 4   │ 995   │ 10    │ 498   │ │ 5   │ 997   │ 10    │ 499   │ │ 6   │ 999   │ 10    │ 500   │</p><pre><code class="language-none">
Also notice that when `DataFrame` is printed to the console or rendered in HTML (e.g. in Jupyter Notebook) you get an information about type of elements held in its columns. For example in this case:
</code></pre><p>jldoctest dataframe julia&gt; DataFrame(a = 1:2, b = [1.0, missing],                  c = categorical(&#39;a&#39;:&#39;b&#39;), d = [1//2, missing]) 2×4 DataFrame │ Row │ a     │ b        │ c    │ d         │ │     │ Int64 │ Float64? │ Cat… │ Rationa…? │ ├─────┼───────┼──────────┼──────┼───────────┤ │ 1   │ 1     │ 1.0      │ &#39;a&#39;  │ 1//2      │ │ 2   │ 2     │ missing  │ &#39;b&#39;  │ missing   │</p><pre><code class="language-none">
we can observe that:

* the first column `:a` can hold elements of type `Int64`;
* the second column `:b` can hold `Float64` or `Missing`, which is indicated by `?` printed after the name of type;
* the third column `:c` can hold categorical data; here we notice `…`, which indicates that the actual name of the type was long and got truncated;
* the type information in fourth column `:d` presents a situation where the name is both truncated and the type allows `Missing`.

### Taking a Subset

#### Indexing syntax

Specific subsets of a data frame can be extracted using the indexing syntax, similar to matrices. The colon `:` indicates that all items (rows or columns depending on its position) should be retained:
</code></pre><p>jldoctest dataframe julia&gt; df[1:3, :] 3×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 3     │ 1     │ 2     │ │ 3   │ 5     │ 1     │ 3     │</p><p>julia&gt; df[[1, 5, 10], :] 3×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 9     │ 1     │ 5     │ │ 3   │ 19    │ 1     │ 10    │</p><p>julia&gt; df[:, [:A, :B]] 500×2 DataFrame │ Row │ A     │ B     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 1     │ │ 2   │ 3     │ 1     │ │ 3   │ 5     │ 1     │ │ 4   │ 7     │ 1     │ ⋮ │ 496 │ 991   │ 10    │ │ 497 │ 993   │ 10    │ │ 498 │ 995   │ 10    │ │ 499 │ 997   │ 10    │ │ 500 │ 999   │ 10    │</p><p>julia&gt; df[1:3, [:B, :A]] 3×2 DataFrame │ Row │ B     │ A     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 1     │ │ 2   │ 1     │ 3     │ │ 3   │ 1     │ 5     │</p><p>julia&gt; df[[3, 1], [:C]] 2×1 DataFrame │ Row │ C     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 3     │ │ 2   │ 1     │</p><pre><code class="language-none">
Do note that `df[!, [:A]]` and `df[:, [:A]]` return a `DataFrame` object, while `df[!, :A]` and `df[:, :A]` return a vector:
</code></pre><p>jldoctest dataframe julia&gt; df[!, [:A]] 500×1 DataFrame │ Row │ A     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │ │ 2   │ 3     │ │ 3   │ 5     │ │ 4   │ 7     │ ⋮ │ 496 │ 991   │ │ 497 │ 993   │ │ 498 │ 995   │ │ 499 │ 997   │ │ 500 │ 999   │</p><p>julia&gt; df[!, [:A]] == df[:, [:A]] true</p><p>julia&gt; df[!, :A] 500-element Array{Int64,1}:    1    3    5    7    9   11    ⋮  991  993  995  997  999</p><p>julia&gt; df[!, :A] == df[:, :A] true</p><pre><code class="language-none">
In the first case, `[:A]` is a vector, indicating that the resulting object should be a `DataFrame`. On the other hand, `:A` is a single symbol, indicating that a single column vector should be extracted. Note that in the first case a vector is required to be passed (not just any iterable), so e.g. `df[:, (:x1, :x2)]` is not allowed, but `df[:, [:x1, :x2]]` is valid.

It is also possible to use a regular expression as a selector of columns matching it:</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(x1=1, x2=2, y=3) 1×3 DataFrame │ Row │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │</p><p>julia&gt; df[!, r&quot;x&quot;] 1×2 DataFrame │ Row │ x1    │ x2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 2     │</p><pre><code class="language-none">
A `Not` selector (from the [InvertedIndices](https://github.com/mbauman/InvertedIndices.jl) package) can be used to select all columns excluding a specific subset:
</code></pre><p>jldoctest dataframe julia&gt; df[!, Not(:x1)] 1×2 DataFrame │ Row │ x2    │ y     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 2     │ 3     │</p><pre><code class="language-none">
Finally, you can use `Not` and `All` selectors in more complex column selection scenarios.
The following examples move all columns whose names match `r&quot;x&quot;` regular expression respectively to the front and to the end of a data frame:</code></pre><p>julia&gt; df = DataFrame(r=1, x1=2, x2=3, y=4) 1×4 DataFrame │ Row │ r     │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┼───────┤ │ 1   │ 1     │ 2     │ 3     │ 4     │</p><p>julia&gt; df[:, All(r&quot;x&quot;, :)] 1×4 DataFrame │ Row │ x1    │ x2    │ r     │ y     │ │     │ Int64 │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┼───────┤ │ 1   │ 2     │ 3     │ 1     │ 4     │</p><p>julia&gt; df[:, All(Not(r&quot;x&quot;), :)] 1×4 DataFrame │ Row │ r     │ y     │ x1    │ x2    │ │     │ Int64 │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┼───────┤ │ 1   │ 1     │ 4     │ 2     │ 3     │</p><pre><code class="language-none">
The indexing syntax can also be used to select rows based on conditions on variables:
</code></pre><p>jldoctest dataframe julia&gt; df[df.A .&gt; 500, :] 250×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 501   │ 6     │ 251   │ │ 2   │ 503   │ 6     │ 252   │ │ 3   │ 505   │ 6     │ 253   │ │ 4   │ 507   │ 6     │ 254   │ ⋮ │ 246 │ 991   │ 10    │ 496   │ │ 247 │ 993   │ 10    │ 497   │ │ 248 │ 995   │ 10    │ 498   │ │ 249 │ 997   │ 10    │ 499   │ │ 250 │ 999   │ 10    │ 500   │</p><p>julia&gt; df[(df.A .&gt; 500) .&amp; (300 .&lt; df.C .&lt; 400), :] 99×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 601   │ 7     │ 301   │ │ 2   │ 603   │ 7     │ 302   │ │ 3   │ 605   │ 7     │ 303   │ │ 4   │ 607   │ 7     │ 304   │ ⋮ │ 95  │ 789   │ 8     │ 395   │ │ 96  │ 791   │ 8     │ 396   │ │ 97  │ 793   │ 8     │ 397   │ │ 98  │ 795   │ 8     │ 398   │ │ 99  │ 797   │ 8     │ 399   │</p><pre><code class="language-none">Where a specific subset of values needs to be matched, the `in()` function can be applied:
</code></pre><p>jldoctest dataframe julia&gt; df[in.(df.A, Ref([1, 5, 601])), :] 3×3 DataFrame │ Row │ A     │ B     │ C     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 1     │ 1     │ │ 2   │ 5     │ 1     │ 3     │ │ 3   │ 601   │ 7     │ 301   │</p><pre><code class="language-none">
Equivalently, the `in` function can be called with a single argument to create
a function object that tests whether each value belongs to the subset
(partial application of `in`): `df[in([1, 5, 601]).(df.A), :]`.

#### Column selection using `select` and `select!`, `transform` and `transform!`

You can also use the [`select`](@ref) and [`select!`](@ref) functions to select,
rename and transform columns in a data frame.

The `select` function creates a new data frame:</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6]) 2×3 DataFrame │ Row │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 3     │ 5     │ │ 2   │ 2     │ 4     │ 6     │</p><p>julia&gt; select(df, Not(:x1)) # drop column :x1 in a new data frame 2×2 DataFrame │ Row │ x2    │ y     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 3     │ 5     │ │ 2   │ 4     │ 6     │</p><p>julia&gt; select(df, r&quot;x&quot;) # select columns containing &#39;x&#39; character 2×2 DataFrame │ Row │ x1    │ x2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 3     │ │ 2   │ 2     │ 4     │</p><p>julia&gt; select(df, :x1 =&gt; :a1, :x2 =&gt; :a2) # rename columns 2×2 DataFrame │ Row │ a1    │ a2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 3     │ │ 2   │ 2     │ 4     │</p><p>julia&gt; select(df, :x1, :x2 =&gt; (x -&gt; x .- minimum(x)) =&gt; :x2) # transform columns 2×2 DataFrame │ Row │ x1    │ x2    │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 1     │ 0     │ │ 2   │ 2     │ 1     │</p><p>julia&gt; select(df, :x2, :x2 =&gt; ByRow(sqrt)) # transform columns by row 2×2 DataFrame │ Row │ x2    │ x2_sqrt │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 3     │ 1.73205 │ │ 2   │ 4     │ 2.0     │</p><pre><code class="language-none">
It is important to note that `select` always returns a data frame,
even if a single column is selected (as opposed to indexing syntax).</code></pre><p>jldoctest dataframe julia&gt; select(df, :x1) 1×1 DataFrame │ Row │ x1    │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │</p><p>julia&gt; df[:, :x1] 1-element Array{Int64,1}:  1</p><pre><code class="language-none">
By default `select` copies columns of a passed source data frame.
In order to avoid copying, pass `copycols=false`:</code></pre><p>julia&gt; df2 = select(df, :x1) 1×1 DataFrame │ Row │ x1    │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │</p><p>julia&gt; df2.x1 === df.x1 false</p><p>julia&gt; df2 = select(df, :x1, copycols=false) 1×1 DataFrame │ Row │ x1    │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │</p><p>julia&gt; df2.x1 === df.x1 true</p><pre><code class="language-none">
To perform the selection operation in-place use `select!`:</code></pre><p>jldoctest dataframe julia&gt; select!(df, Not(:x1));</p><p>julia&gt; df 1×2 DataFrame │ Row │ x2    │ y     │ │     │ Int64 │ Int64 │ ├─────┼───────┼───────┤ │ 1   │ 2     │ 3     │</p><pre><code class="language-none">
`transform` and `transform!` functions work identically to `select` and `select!` with the only difference that
they retain all columns that are present in the source data frame. Here are some more advanced examples.

First we show how to generate a column that is a sum of all other columns in the data frame
using the `All()` selector:
</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(x1=[1, 2], x2=[3, 4], y=[5, 6]) 2×3 DataFrame │ Row │ x1    │ x2    │ y     │ │     │ Int64 │ Int64 │ Int64 │ ├─────┼───────┼───────┼───────┤ │ 1   │ 1     │ 3     │ 5     │ │ 2   │ 2     │ 4     │ 6     │</p><p>julia&gt; transform(df, All() =&gt; +) 2×4 DataFrame │ Row │ x1    │ x2    │ y     │ x1<em>x2</em>y_+ │ │     │ Int64 │ Int64 │ Int64 │ Int64     │ ├─────┼───────┼───────┼───────┼───────────┤ │ 1   │ 1     │ 3     │ 5     │ 9         │ │ 2   │ 2     │ 4     │ 6     │ 12        │</p><pre><code class="language-none">Using the `ByRow` wrapper, we can easily compute for each row the name of column with the highest score:</code></pre><p>julia&gt; using Random</p><p>julia&gt; Random.seed!(1);</p><p>julia&gt; df = DataFrame(rand(10, 3), [:a, :b, :c]) 10×3 DataFrame │ Row │ a          │ b         │ c         │ │     │ Float64    │ Float64   │ Float64   │ ├─────┼────────────┼───────────┼───────────┤ │ 1   │ 0.236033   │ 0.555751  │ 0.0769509 │ │ 2   │ 0.346517   │ 0.437108  │ 0.640396  │ │ 3   │ 0.312707   │ 0.424718  │ 0.873544  │ │ 4   │ 0.00790928 │ 0.773223  │ 0.278582  │ │ 5   │ 0.488613   │ 0.28119   │ 0.751313  │ │ 6   │ 0.210968   │ 0.209472  │ 0.644883  │ │ 7   │ 0.951916   │ 0.251379  │ 0.0778264 │ │ 8   │ 0.999905   │ 0.0203749 │ 0.848185  │ │ 9   │ 0.251662   │ 0.287702  │ 0.0856352 │ │ 10  │ 0.986666   │ 0.859512  │ 0.553206  │</p><p>julia&gt; transform(df, AsTable(:) =&gt; ByRow(argmax) =&gt; :prediction) 10×4 DataFrame │ Row │ a          │ b         │ c         │ prediction │ │     │ Float64    │ Float64   │ Float64   │ Symbol     │ ├─────┼────────────┼───────────┼───────────┼────────────┤ │ 1   │ 0.236033   │ 0.555751  │ 0.0769509 │ b          │ │ 2   │ 0.346517   │ 0.437108  │ 0.640396  │ c          │ │ 3   │ 0.312707   │ 0.424718  │ 0.873544  │ c          │ │ 4   │ 0.00790928 │ 0.773223  │ 0.278582  │ b          │ │ 5   │ 0.488613   │ 0.28119   │ 0.751313  │ c          │ │ 6   │ 0.210968   │ 0.209472  │ 0.644883  │ c          │ │ 7   │ 0.951916   │ 0.251379  │ 0.0778264 │ a          │ │ 8   │ 0.999905   │ 0.0203749 │ 0.848185  │ a          │ │ 9   │ 0.251662   │ 0.287702  │ 0.0856352 │ b          │ │ 10  │ 0.986666   │ 0.859512  │ 0.553206  │ a          │</p><pre><code class="language-none">In the following, most complex, example below we compute row-wise sum, number of elements, and mean,
while ignoring missing values.</code></pre><p>julia&gt; using Statistics</p><p>julia&gt; df = DataFrame(x=[1, 2, missing], y=[1, missing, missing]);</p><p>julia&gt; transform(df, AsTable(:) .=&gt;                      ByRow.([sum∘skipmissing,                              x -&gt; count(!ismissing, x),                              mean∘skipmissing]) .=&gt;                      [:sum, :n, :mean]) 3×5 DataFrame │ Row │ x       │ y       │ sum   │ n     │ mean    │ │     │ Int64?  │ Int64?  │ Int64 │ Int64 │ Float64 │ ├─────┼─────────┼─────────┼───────┼───────┼─────────┤ │ 1   │ 1       │ 1       │ 2     │ 2     │ 1.0     │ │ 2   │ 2       │ missing │ 2     │ 1     │ 2.0     │ │ 3   │ missing │ missing │ 0     │ 0     │ NaN     │</p><pre><code class="language-none">
While the DataFrames.jl package provides basic data manipulation capabilities,
users are encouraged to use querying frameworks for more convenient and powerful operations:
- the [Query.jl](https://github.com/davidanthoff/Query.jl) package provides a
[LINQ](https://msdn.microsoft.com/en-us/library/bb397926.aspx)-like interface to a large number of data sources
- the [DataFramesMeta.jl](https://github.com/JuliaStats/DataFramesMeta.jl)
package provides interfaces similar to LINQ and [dplyr](https://dplyr.tidyverse.org)

See the [Data manipulation frameworks](@ref) section for more information.

### Summarizing Data

The `describe` function returns a data frame summarizing the elementary statistics and information about each column:
</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(A = 1:4, B = [&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;])</p><p>julia&gt; describe(df) 2×8 DataFrame │ Row │ variable │ mean   │ min │ median │ max │ nunique │ nmissing │ eltype   │ │     │ Symbol   │ Union… │ Any │ Union… │ Any │ Union…  │ Nothing  │ DataType │ ├─────┼──────────┼────────┼─────┼────────┼─────┼─────────┼──────────┼──────────┤ │ 1   │ A        │ 2.5    │ 1   │ 2.5    │ 4   │         │          │ Int64    │ │ 2   │ B        │        │ F   │        │ M   │ 2       │          │ String   │</p><pre><code class="language-none">
If you are interested in describing only a subset of columns then the easiest way to do it is to
pass a subset of an original data frame to `describe` like this:</code></pre><p>jldoctest dataframe julia&gt; describe(df[!, [:A])) 1×8 DataFrame │ Row │ variable │ mean    │ min   │ median  │ max   │ nunique │ nmissing │ eltype   │ │     │ Symbol   │ Float64 │ Int64 │ Float64 │ Int64 │ Nothing │ Nothing  │ DataType │ ├─────┼──────────┼─────────┼───────┼─────────┼───────┼─────────┼──────────┼──────────┤ │ 1   │ A        │ 2.5     │ 1     │ 2.5     │ 4     │         │          │ Int64    │</p><pre><code class="language-none">
Of course, one can also compute descriptive statistics directly on individual columns:</code></pre><p>jldoctest dataframe julia&gt; using Statistics</p><p>julia&gt; mean(df.A) 2.5</p><pre><code class="language-none">
We can also apply a function to each column of a `DataFrame` using `select`. For example:</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0) 4×2 DataFrame │ Row │ A     │ B       │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 1     │ 4.0     │ │ 2   │ 2     │ 3.0     │ │ 3   │ 3     │ 2.0     │ │ 4   │ 4     │ 1.0     │</p><p>julia&gt; select(df, names(df) .=&gt; sum) 1×2 DataFrame │ Row │ A<em>sum │ B</em>sum   │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 10    │ 10.0    │</p><p>julia&gt; select(df, names(df) .=&gt; sum, names(df) .=&gt; prod) 1×4 DataFrame │ Row │ A<em>sum │ B</em>sum   │ A<em>prod │ B</em>prod  │ │     │ Int64 │ Float64 │ Int64  │ Float64 │ ├─────┼───────┼─────────┼────────┼─────────┤ │ 1   │ 10    │ 10.0    │ 24     │ 24.0    │</p><pre><code class="language-none">
### Handling of Columns Stored in a `DataFrame`

Functions that transform a `DataFrame` to produce a
new `DataFrame` always perform a copy of the columns by default, for example:
</code></pre><p>jldoctest dataframe julia&gt; df = DataFrame(A = 1:4, B = 4.0:-1.0:1.0) 4×2 DataFrame │ Row │ A     │ B       │ │     │ Int64 │ Float64 │ ├─────┼───────┼─────────┤ │ 1   │ 1     │ 4.0     │ │ 2   │ 2     │ 3.0     │ │ 3   │ 3     │ 2.0     │ │ 4   │ 4     │ 1.0     │</p><p>julia&gt; df2 = copy(df);</p><p>julia&gt; df2.A === df.A false</p><pre><code class="language-none">
On the other hand, in-place functions, whose names end with `!`, may mutate the column vectors of the
`DataFrame` they take as an argument, for example:
</code></pre><p>jldoctest dataframe julia&gt; x = [3, 1, 2];</p><p>julia&gt; df = DataFrame(x=x) 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 3     │ │ 2   │ 1     │ │ 3   │ 2     │</p><p>julia&gt; sort!(df) 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 1     │ │ 2   │ 2     │ │ 3   │ 3     │</p><p>julia&gt; x 3-element Array{Int64,1}:  1  2  3</p><p>julia&gt; df.x[1] = 100 100</p><p>julia&gt; df 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 100   │ │ 2   │ 2     │ │ 3   │ 3     │</p><p>julia&gt; x 3-element Array{Int64,1}:  100    2    3</p><pre><code class="language-none">
In-place functions are safe to call, except when a view of the `DataFrame`
(created via a `view`, `@view` or [`groupby`](@ref))
or when a `DataFrame` created with `copycols=false` (or with the `DataFrame!` function)
are in use.

It is possible to have a direct access to a column `col` of a `DataFrame` `df`
using the syntaxes `df.col`, `df[!, :col]`, via the [`eachcol`](@ref) function,
by accessing a `parent` of a `view` of a column of a `DataFrame`,
or simply by storing the reference to the column vector before the `DataFrame`
was created with `copycols=false` (or with the `DataFrame!` function).
</code></pre><p>jldoctest dataframe julia&gt; x = [3, 1, 2];</p><p>julia&gt; df = DataFrame(x=x) 3×1 DataFrame │ Row │ x     │ │     │ Int64 │ ├─────┼───────┤ │ 1   │ 3     │ │ 2   │ 1     │ │ 3   │ 2     │</p><p>julia&gt; df.x == x true</p><p>julia&gt; df[1] !== x true</p><p>julia&gt; eachcol(df)[1] === df.x true</p><pre><code class="language-none">
Note that a column obtained from a `DataFrame` using one of these methods should
not be mutated without caution.

The exact rules of handling columns of a `DataFrame` are explained in
[The design of handling of columns of a `DataFrame`](@ref man-columnhandling) section of the manual.

## Replacing Data

Several approaches can be used to replace some values with others in a data frame. Some apply the replacement to all values in a data frame, and others to individual columns or subset of columns.

Do note that in-place replacement requires that the replacement value can be converted to the column&#39;s element type. In particular, this implies that replacing a value with `missing` requires a call to `allowmissing!` if the column did not allow for missing values.

Replacement operations affecting a single column can be performed using `replace!`:</code></pre><p>jldoctest replace julia&gt; df = DataFrame(a = [&quot;a&quot;, &quot;None&quot;, &quot;b&quot;, &quot;None&quot;], b = 1:4, c = [&quot;None&quot;, &quot;j&quot;, &quot;k&quot;, &quot;h&quot;], d = [&quot;x&quot;, &quot;y&quot;, &quot;None&quot;, &quot;z&quot;]) 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ None   │ x      │ │ 2   │ None   │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ None   │ │ 4   │ None   │ 4     │ h      │ z      │</p><p>julia&gt; replace!(df.a, &quot;None&quot; =&gt; &quot;c&quot;) 4-element Array{String,1}:  &quot;a&quot;  &quot;c&quot;  &quot;b&quot;  &quot;c&quot;</p><p>julia&gt; df 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ None   │ x      │ │ 2   │ c      │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ None   │ │ 4   │ c      │ 4     │ h      │ z      │</p><pre><code class="language-none">This is equivalent to `df.a = replace(df.a, &quot;None&quot; =&gt; &quot;c&quot;)`, but operates in-place, without allocating a new column vector.

Replacement operations on multiple columns or on the whole data frame can be performed in-place using the broadcasting syntax:</code></pre><p>jldoctest replace</p><h1><a class="nav-anchor" id="replacement-on-a-subset-of-columns-[:c,-:d]-1" href="#replacement-on-a-subset-of-columns-[:c,-:d]-1">replacement on a subset of columns [:c, :d]</a></h1><p>julia&gt; df[:, [:c, :d]] .= ifelse.(df[!, [:c, :d]] .== &quot;None&quot;, &quot;c&quot;, df[!, [:c, :d]]) 4×2 DataFrame │ Row │ c      │ d      │ │     │ String │ String │ ├─────┼────────┼────────┤ │ 1   │ c      │ x      │ │ 2   │ j      │ y      │ │ 3   │ k      │ c      │ │ 4   │ h      │ z      │</p><p>julia&gt; df 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ c      │ x      │ │ 2   │ c      │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ c      │ │ 4   │ c      │ 4     │ h      │ z      │</p><h1><a class="nav-anchor" id="replacement-on-entire-data-frame-1" href="#replacement-on-entire-data-frame-1">replacement on entire data frame</a></h1><p>julia&gt; df .= ifelse.(df .== &quot;c&quot;, &quot;None&quot;, df) 4×4 DataFrame │ Row │ a      │ b     │ c      │ d      │ │     │ String │ Int64 │ String │ String │ ├─────┼────────┼───────┼────────┼────────┤ │ 1   │ a      │ 1     │ None   │ x      │ │ 2   │ None   │ 2     │ j      │ y      │ │ 3   │ b      │ 3     │ k      │ None   │ │ 4   │ None   │ 4     │ h      │ z      │</p><pre><code class="language-none">Do note that in the above examples, changing `.=` to just `=` will allocate new column vectors instead of applying the operation in-place.

When replacing values with `missing`, if the columns do not already allow for missing values, one has to either avoid in-place operation and use `=` instead of `.=`, or call `allowmissing!` beforehand:</code></pre><p>jldoctest replace</p><h1><a class="nav-anchor" id="do-not-operate-in-place-(df-would-also-work)-1" href="#do-not-operate-in-place-(df-would-also-work)-1">do not operate in-place (<code>df =</code> would also work)</a></h1><p>julia&gt; df2 = ifelse.(df .== &quot;None&quot;, missing, df) 4×4 DataFrame │ Row │ a       │ b     │ c       │ d       │ │     │ String? │ Int64 │ String? │ String? │ ├─────┼─────────┼───────┼─────────┼─────────┤ │ 1   │ a       │ 1     │ missing │ x       │ │ 2   │ missing │ 2     │ j       │ y       │ │ 3   │ b       │ 3     │ k       │ missing │ │ 4   │ missing │ 4     │ h       │ z       │</p><h1><a class="nav-anchor" id="operate-in-place-after-allowing-for-missing-1" href="#operate-in-place-after-allowing-for-missing-1">operate in-place after allowing for missing</a></h1><p>julia&gt; allowmissing!(df) 4×4 DataFrame │ Row │ a       │ b      │ c       │ d       │ │     │ String? │ Int64? │ String? │ String? │ ├─────┼─────────┼────────┼─────────┼─────────┤ │ 1   │ a       │ 1      │ None    │ x       │ │ 2   │ None    │ 2      │ j       │ y       │ │ 3   │ b       │ 3      │ k       │ None    │ │ 4   │ None    │ 4      │ h       │ z       │</p><p>julia&gt; df .= ifelse.(df .== &quot;None&quot;, missing, df) 4×4 DataFrame │ Row │ a       │ b     │ c       │ d       │ │     │ String? │ Int64 │ String? │ String? │ ├─────┼─────────┼───────┼─────────┼─────────┤ │ 1   │ a       │ 1     │ missing │ x       │ │ 2   │ missing │ 2     │ j       │ y       │ │ 3   │ b       │ 3     │ k       │ missing │ │ 4   │ missing │ 4     │ h       │ z       │</p><pre><code class="language-none">

## Importing and Exporting Data (I/O)

For reading and writing tabular data from CSV and other delimited text files, use the [CSV.jl](https://github.com/JuliaData/CSV.jl) package.

If you have not used the CSV.jl package before then you may need to install it first:</code></pre><p>julia using Pkg Pkg.add(&quot;CSV&quot;)</p><pre><code class="language-none">
The CSV.jl functions are not loaded automatically and must be imported into the session.</code></pre><p>julia using CSV</p><pre><code class="language-none">
A dataset can now be read from a CSV file at path `input` using</code></pre><p>julia DataFrame(CSV.File(input))</p><pre><code class="language-none">
A `DataFrame` can be written to a CSV file at path `output` using</code></pre><p>julia df = DataFrame(x = 1, y = 2) CSV.write(output, df) ```</p><p>The behavior of CSV functions can be adapted via keyword arguments. For more information, see <code>?CSV.File</code>, <code>?CSV.read</code> and <code>?CSV.write</code>, or checkout the online <a href="https://juliadata.github.io/CSV.jl/stable/">CSV.jl documentation</a>.</p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../joins/"><span class="direction">Next</span><span class="title">Joins</span></a></footer></article></body></html>
